.. _db2fedsvrcfg.rst:
	
====================================================
INCOMPLETE INVESTIGATION REPORT ON db2fedsvrcfg TOOL
====================================================
:Date: |today|

.. topic:: Background
   
        | :download:`ODBC Data Source Customization<FedSvr_Beta_Topic_ODBC_customization.ppt>`
        | :download:`ODBC Data Source Customization phase2 <ODSC_phase2_overview.ppt>`
        | :download:`Inside db2fedsvrcfg<Inside_db2fedsvrcfg.ppt>`


0. Remarks after meeting
-------------------------

	* "Performance" = "pushdown"
	
	* We don't care about **CASE III**, **CASE IV** logic for now
	
	* Tool value: check capacity of the remote data source
	
		server option set to ``Y`` doesn't necessarily indicate Federation Server can pushdown. But, server option set to ``N``, Federation Server will definitely **cannot** pushdown.
	
	* Tool essential:
		
		It doesn't use Federation Server at all. For **case I**, It uses ODBC-API to create test_table remotely, then it issues queries to query remote table that the tool just created, and 
		compared the ``result_list`` with the expected result_list (by ``judge``). 
		
	
	
	
1. Intro
--------

	According to `knowledge center <http://www-01.ibm.com/support/knowledgecenter/SSEPGG_10.5.0/com.ibm.swg.im.iis.found.conn.fw.odb.doc/topics/iiynwodb_cftut.html>`_ , 
	"db2fedsvrcfg" asserts only for "Optimize performance", and it is really unclear to me that what is the measure for "performance"? 
	How to judge whether "performance" is optimized or not? 
	Whether this tool is worth to modify or not still depends on the relationship between "pushdown" and "performance". 
	Based upon my limited understanding, this tool doesn't give a clear indication on whether it tests "pushdown" or not. 
	Based upon ``db2odbct_analyze`` function, it might test "pushdown" b/c it implements strict test against ``rc = operation->query()`` result. This can tell from ``judge`` function.
	Strict in the sense that even a query with certain server option can be pushdown, the query result should match exactly with the expected query return in order to be ``Y``.

	
	The following example demonstrates what I mean for "strict", in *db2odbct_analyze.C*, function ``analyze``
	
	.. sourcecode:: c++
		:linenos:
		:emphasize-lines: 12,18-19,21
	
		case SQLQG_SERVER_CHAR_BLANKPADDED_COMPARISON_OPTION_ID:
		{
			// Issue the analyze statement.
			rc = operation->query();
			if (rc == RC_OK)
			{
				// skip some code
				judge = judge_result(a_option, result_list);
				// skip some code
				if (judge == false)
				{
					optimized_value = "N"
					analysis_completed = true;
				}
			}
			else if (rc == RC_NO_DATA_FOUND)
			{
				// No data returned is assumed as the data source did not process
				// the WHERE clause portion with blank padded comparison.
				rc = RC_OK;
				optimized_value = "N";
				// skip some code
			}
		
		}
		
	[12, 18-19]:
		Essentially, this block indicates that when ``DB2_CHAR_BLANKPADDED_COMPARISON`` (represented by ``SQLQG_SERVER_CHAR_BLANKPADDED_COMPARISON_OPTION_ID``)
		is set to ``Y``, remote data source cannot process it (b/c ``rc == RC_NO_DATA_FOUND``). This indicates that this server option doesn't really affect pushdown.
		However, this message cannot convey to user b/c when ``judge`` is ``false``, ``optimized_value`` will also be set to ``N``. This implies that 
		``rc = operation->query()`` can issue to remote data source and there is ``result_list`` returned. But ``result_list`` doesn't match the predefined return data type,
		data value, or number of data. This makes interpretation of ``N`` for ``optimized_value`` hard because one cannot determine whether it is due to *cannot pushdown* or 
		*can pushdown but return result invalid*
		
	In order to clarify the concept of "optimized", I think one need to carefully examine ``judge_result`` function in ``db2odbct_analyze`` and other ``optimized_value`` determination
	logic as well. 
	
	Maybe certain server option has directly link with "optimized performance", and that server option set to "Y" will imply the improve in "performance", which verified by code that are
	not well encaptured inside the tool?
	
2. Important code flow
----------------------

		*db2fedsvrcfg.C* (main)
				+
				+ <---------------------- ``LoadTuningLibrary(...)`` 
				+
		*db2odbct.C*
				+
				+ <---------------------- ``analyze_data_source(...)``
				+
		*db2odbct.C* {*db2odbct_elements* : server option manipulation, tuning_table_info manipulation, result_list manipulation
				+	  *db2odbct_common*   : server option definition, tuning_table definition
				+	  *db2odbct_statment* : DDL generation}
				+	  *db2odbct_operation*: DDL operation}
				+
				+ <----------------------- ``rc = analyzer->analyze(option)``
		
		*db2odbct_analyze.C*
			

.. _analyze-logic:			

3. Analyze logic
----------------

	Encoded in ``analyze`` function in *db2odbct_analyze.C*. There are four types of logic corresponding to different set of server options.
	
	
	**CASE I**
	
		# include:
			|  case SQLQG_SERVER_VARCHAR_BLANKPADDED_COMPARISON_OPTION_ID
			|  case SQLQG_SERVER_CHAR_BLANKPADDED_COMPARISON_OPTION_ID
				
		# structure:
		
			1. .. code-block:: c++
				:caption: Construct Tuning_ANALYZE_Stmt_Generator
					
					Tuning_ANALYZE_Stmt_Generator *generator = 
							new Tuning_ANALYZE_Stmt_Generator(m_connection, m_table_list, option_id);`
								
			2. .. code-block:: c++
				:caption: Analyze SQL statement generate
					
					TString stmt = generator->generate(); [detail see db2odbct_statement]
							
			3. .. code-block:: c++
				:caption: Create Operation
					
					Tuning_Query_Operation *operation = m_connection->create_query_operation((const char*)stmt);

			4. .. code-block:: c++
				:caption: Issue the analyze statement
					
					rc = operation->query();
							
			5. .. code-block:: c++
				:caption: Retrieve result for judgement
					
					rc = operation->fetch(&result_list);
			
			6. .. code-block:: c++
				:caption: Judge result
					
					judge = judge_result(a_option, result_list);
							
			7. .. code-block:: c++
				:caption: Based upon "judge" valeSet optimized value
						
					if (rc == RC_OK) && (result_list != NULL)
						if (judge == true)
						{
							optimized_value = "Y";
							analysis_completed = true;
						}
						if (judge == false)
						{
							optimized_value = "N";
							analysis_completed = true;
						}
							
					if (rc == RC_NO_DATA_FOUND)
						optimized_value = "N"
			
				
	**CASE II**
	
		# include:
			|  case SQLQG_SERVER_COLFUNC_EXPR_OPTION_ID:
			|  case SQLQG_SERVER_FUNCTION_IN_COUNT_OPTION_ID:
			|  case SQLQG_SERVER_COUNT_NON_DISTINCT_OPTION_ID:
			|  case SQLQG_SERVER_OUTER_JOINS_OPTION_ID:
			|  case SQLQG_SERVER_NESTED_TAB_EXPR_OPTION_ID:
			|  case SQLQG_SERVER_ORDER_BY_OPTION_ID:
			|  case SQLQG_SERVER_SELECT_DISTINCT_OPTION_ID:
			|  case SQLQG_SERVER_COLFUNC_DISTINCT_OPTION_ID:
			|  case SQLQG_SERVER_GROUP_BY_OPTION_ID:
			|  case SQLQG_SERVER_BASIC_PRED_RHS_SCALAR_SQ_OPTION_ID:
			|  case SQLQG_SERVER_UNION_ALL_OPTION_ID:
			|  case SQLQG_SERVER_COLFUNC_OPTION_ID:
			|  case SQLQG_SERVER_EXISTS_PRED_OPTION_ID:
	
		# structure:
		
			step 1 - 4 are the same case as **CASE I**
			
			5. .. code-block:: c++
				
				if (rc == RC_OK)
					optimized_value = "Y";
					
	**CASE III**
	
		# include: 
			|  case SQLQG_SERVER_MAX_SEL_SIZE_OPTION_ID:
			|  case SQLQG_SERVER_MAX_OB_SIZE_OPTION_ID:
			|  case SQLQG_SERVER_MAX_GB_SIZE_OPTION_ID:
			
		# structure:
		
			
					
				1. uses three values: ``min_value``, ``max_value``, ``default_value``
				
					.. code-block: c++
						:caption: initialization
					
							max_value = atoi(SQLQG_MAX_GB_SIZE_MAX);
							min_value = atoi(SQLQG_MAX_GB_SIZE_MIN);
							default_value = atoi(SQLQG_MAX_GB_SIZE_DEFAULT);
					
				2.	start loop:
					
					|  2.1 then ``new_value``, ``old_value`` to search
						
						.. code-block:: c++
							:caption: initialization:
							
								new_value = default_value;
								old_value = min_value;
							
						.. code-block:: c++
							:caption: When the previous statement failed try with smaller value
						
								new_value = old_value + (new_value - old_value) / 2;
						
						.. code-block:: c++ 
							:caption: When the previous statement succeeded, try with larger value.
						
								new_value = new_value + (new_value - old_value);
								old_value = old_value + (new_value - old_value) / 2;
						
					2.2 then set the new value to generate a new statement
					
					2.3 then issue the analysis statement with new value
						.. code-block:: c++
						
							if (rc == RC_OK)
								//then we find the ideal value, which is new_value
							else
								// Store the rc as the information for making a decision of generation 
								// of the next analysis statement.
								prev_rc = rc;
					
					2.4 loop will terminate when
						.. code-block:: c++
						 
							// Terminate the analysis if the statement succeeds and the difference becomes 
							// smaller than the threshold.
							if ((stmt_generation_count > 1) && 
								((abs(old_value - new_value) < threshold) ||(new_value == max_value)))
							{
								analysis_completed = true;
							}
							
	**CASE IV**
	
		# include: 
			case SQLQG_SERVER_UPD_SET_DEFAULT_OPTION_ID:
				
		# structure:
					
			1. .. code-block:: c++
				:caption: Construct Tuning_ANALYZE_Stmt_Generator
							
							Tuning_ANALYZE_Stmt_Generator *generator = 
								new Tuning_ANALYZE_Stmt_Generator(m_connection, m_table_list, option_id);
								
			2. .. code-block:: c++
				:caption: Analyze SQL statement generate
							
							TString stmt = generator->generate(); [detail see db2odbct_statement]
							
			3. .. code-block:: c++
				:caption: Create Operation (here is diff: create_IUD_operation )
							
							Tuning_IUD_Operation *operation = 
								m_connection->create_IUD_operation((const char*)stmt);

			4. .. code-block:: c++ 		
						
							int row_updated = 0;
							rc = operation->iud_row(&row_updated);
					
			5. .. code-block:: c++ 
				
							if (row_updated == 1)
								judge = true;
								optimized_value = "Y";
								
								
	
	**Remarks on CASE I**
	
		``judge`` function
	
			The following server options will be checked and invoke ``check_existance_int``
		
				|  SQLQG_SERVER_VARCHAR_BLANKPADDED_COMPARISON_OPTION_ID
				|  SQLQG_SERVER_CHAR_BLANKPADDED_COMPARISON_OPTION_ID
				|  SQLQG_SERVER_COLFUNC_EXPR_OPTION_ID
				|  SQLQG_SERVER_FUNCTION_IN_COUNT_OPTION_ID
				|  SQLQG_SERVER_COUNT_NON_DISTINCT_OPTION_ID
			
			The following server options will not be checked and return ``true``
		
				|  SQLQG_SERVER_BASIC_PRED_RHS_SCALAR_SQ_OPTION_ID
				|  SQLQG_SERVER_COLFUNC_DISTINCT_OPTION_ID
				|  SQLQG_SERVER_COLFUNC_OPTION_ID
				|  SQLQG_SERVER_EXISTS_PRED_OPTION_ID
				|  SQLQG_SERVER_GROUP_BY_OPTION_ID
				|  SQLQG_SERVER_MAX_GB_SIZE_OPTION_ID
				|  SQLQG_SERVER_MAX_OB_SIZE_OPTION_ID
				|  SQLQG_SERVER_MAX_SEL_SIZE_OPTION_ID
				|  SQLQG_SERVER_NESTED_TAB_EXPR_OPTION_ID
				|  SQLQG_SERVER_ORDER_BY_OPTION_ID
				|  SQLQG_SERVER_OUTER_JOINS_OPTION_ID
				|  SQLQG_SERVER_SELECT_DISTINCT_OPTION_ID
				|  SQLQG_SERVER_UNION_ALL_OPTION_ID
				|  SQLQG_SERVER_UPD_SET_DEFAULT_OPTION_ID
				
		``check_existance_int`` function
		
			Logic:
				It will compare ``a_result_data`` one by one 
				
					.. code-block:: c++
					
						Tuning_Result_Data *a_result_data = result_list->get_first_result_data();
						a_result_data = (Tuning_Result_Data *)a_result_data->get_next_result_data();
					
				Then, compare ``a_result_data`` data type (``a_result_data->get_data_type()``), 
				data value (``a_result_data->get_int_value()``) 
				with the predefined value: ``rsdt_int`` & ``value`` 
					
				If ``a_result_data`` valid, then ``foundNum++``, if ``foundNum == count``, then return ``true``
	
			Example:
			
				.. code-block:: c++
					
					 case SQLQG_SERVER_CHAR_BLANKPADDED_COMPARISON_OPTION_ID:
					{
						// Check if 'blank-padded comparison' is executed correctly.
						result = check_existance_int(result_list, 56, 1);
						break;
					}
					
				.. code-block:: sql
				 :caption: Analyze statement
				
					SELECT IT1C1 FROM IITEST1 WHERE IT1C4 = 'F'
					
				
				See IITEST1 table: from *db2odbct_common.h*, ``56`` matches expected result from analyze statement.			

	
4. More info
------------

* YaQiong's *db2fedsvrcfg tool investigation* report

* Zeyuan's detailed version of `db2fedsvrcfg study note <../../_static/db2fedsvrcfg/db2fedsvrcfg.txt>`_

* Zhi Tong & Huang Xue's `server attributes summary <../../_static/db2fedsvrcfg/db2fedsvrcfg_enhancement_(2015-11-09_Rev1_modified_by_hx).xls>`_
		
