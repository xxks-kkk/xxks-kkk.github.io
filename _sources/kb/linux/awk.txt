.. _awk.rst:

###########
AWK
###########

Last Update: |today|

************
Case Study
************

Search pattern for each line
-----------------------------

**GOAL:** Kill all the processes containing keyword "quicktest"

::

    (iidev20@maradona) /home/iidev20
    $ ps -ef | grep -i quicktest
    iidev20 49814180        1   0   Jan 12      -  0:00 quicktest 55556,671,760.mod OP 2 ITR 3000 CLIENT 5 NCLIENT 30 SEED 1452586352
    iidev20 49945254        1   0   Jan 12      -  0:00 quicktest 55556,671,760.mod OP 2 ITR 3000 CLIENT 15 NCLIENT 30 SEED 1452586362
    iidev20 50010822        1   0   Jan 12      -  0:00 quicktest 55556,671,760.mod OP 2 ITR 3000 CLIENT 14 NCLIENT 30 SEED 1452586361
    iidev20 51124770        1   0   Jan 12      -  0:00 quicktest 55556,671,760.mod OP 2 ITR 3000 CLIENT 9 NCLIENT 30 SEED 1452586356
    iidev20 51911254        1   0   Jan 12      -  0:00 quicktest 55556,671,760.mod OP 2 ITR 3000 CLIENT 26 NCLIENT 30 SEED 1452586373
    iidev20 52238890        1   0   Jan 12      -  0:00 quicktest 55556,671,760.mod OP 2 ITR 3000 CLIENT 11 NCLIENT 30 SEED 1452586358
    iidev20 52501070        1   0   Jan 12      -  0:00 quicktest 55556,671,760.mod OP 2 ITR 3000 CLIENT 10 NCLIENT 30 SEED 1452586357
    iidev20 54401732        1   0   Jan 12      -  0:00 quicktest 55556,671,760.mod OP 2 ITR 3000 CLIENT 20 NCLIENT 30 SEED 1452586367
    iidev20 54794868        1   0   Jan 12      -  0:00 quicktest 55556,671,760.mod OP 2 ITR 3000 CLIENT 22 NCLIENT 30 SEED 1452586369
    iidev20 29825944        1   0   Jan 12      -  0:00 quicktest 55556,671,760.mod OP 2 ITR 3000 CLIENT 8 NCLIENT 30 SEED 1452586355
    iidev20 35789764        1   0   Jan 12      -  0:00 quicktest 55556,671,760.mod OP 2 ITR 3000 CLIENT 19 NCLIENT 30 SEED 1452586366
    iidev20 36838170        1   0   Jan 12      -  0:00 quicktest 55556,671,760.mod OP 2 ITR 3000 CLIENT 13 NCLIENT 30 SEED 1452586360
    iidev20 36903922        1   0   Jan 12      -  0:00 quicktest 55556,671,760.mod OP 2 ITR 3000 CLIENT 24 NCLIENT 30 SEED 1452586371

.. topic:: Solution

      ::

         kill -9 `ps -ef | grep $USER | awk '$9 ~ /quicktest/ {print $2}'`

.. note::

     ``$9 ~ /quicktest/`` means that "looking for 'quicktest' within $9"

Pass shell variable as a /pattern/ to awk
------------------------------------------

**GOAL:** Truncate a `db2trace flow file <http://www.ibm.com/support/knowledgecenter/SSEPGG_10.5.0/com.ibm.db2.luw.admin.trb.doc/doc/c0020802.html?lang=en>`_ for a specific range of trace point numbers

Usually, the trace file generated by db2 can be extremely large (can easily get to several gigabytes if you are
not carefully enough), and it is hard to browse in the text editor. During my work, I usually ``grep`` the key
word of certain function calls (of course, you can use mask to format trace file as well), and try to dig through
the call stack in between. Thus, my interest is on part of trace file, and I want to cut the trace file based upon
the trace point numbers located through ``grep``.

The following is one sample flw file::

    ...

    pid = 19834 tid = 1 node = 0

    846         sqlbPFPrefetcherEntryPoint entry
    847         sqlbPFPrefetcherEntryPoint data [probe 0]
    848         | sqlbPFInitPrefetcher entry
    849         | sqlbPFInitPrefetcher data [probe 0]
    850         | | sqlbConnectToSharedMemory entry
    851         | | sqlbConnectToSharedMemory exit
    852         | | sqlbInitEDU entry
    853         | | | sqlbGetBPConfig entry
    854         | | | sqlbGetBPConfig data [probe 0]
    855         | | | sqlbGetBPConfig exit
    856         | | | SqlbFileTbl::SqlbFileTbl entry
    857         | | | SqlbFileTbl::SqlbFileTbl exit
    858         | | sqlbInitEDU exit
    859         | sqlbPFInitPrefetcher exit
    860         | sqlbpfRemoveFromQ entry

    ...

The number 846, 847, ... are the trace point number, and the key observation here is that those numbers are unique. Thus,
we can have the following shell script to parse the flow file

.. code-block:: shell

    #!/bin/sh                                                                                                                     

    printf "Trace file: %s\n" "$3"
    printf "Trace point number lower bound: %d\n" "$1"
    printf "Trace point number  upper bound: %d\n" "$2"

    lowerboundlineno=`awk -v p="$1" '$0 ~ p {print NR}' $3`
    printf "Trace point number lower bound line number in $3 : %d\n" "$lowerboundlineno"

    upperboundlineno=`awk -v p="$2" '$0 ~ p {print NR}' $3`
    printf "Trace point number upper bound line number in $3 : %d\n\n" "$upperboundlineno"

    awk -v a="$lowerboundlineno" -v b="$upperboundlineno" 'NR>=a && NR<=b' "$3"

.. topic:: Keys

    - ``-v`` to pass shell variable to awk. If you want to pass more than one shell variable to awk, you need to use
      multiple ``-v`` options (ie. ``awk -v var1=2 -v var2="HI" 'BEGIN{print var1; print var2}'``)

    - Use awk's ``~`` operator and not ``\pattern\``. awk will not work if you use 
      ``lowerboundlineno=`awk -v p="$1" '/p/ {print NR}' "$3"```. For some reason, even though ``p`` is assigned with 
      value say 856, since it is put inside ``/.../``, the pattern is ``p`` itself, and awk will match rows containing
      ``p``, not 856. So, **Use ~ for passing shell variable as pattern not /.../**

.. seealso::

    Please reference `IBM developerWorks tutorial <http://www.ibm.com/developerworks/data/library/techarticle/dm-0409melnyk/index.html>`_ and `IBM Knowledge center <http://www.ibm.com/support/knowledgecenter/SSEPGG_10.5.0/com.ibm.db2.luw.admin.trb.doc/com.ibm.db2.luw.admin.trb.doc-gentopic1.html?lang=en>`_ if you want to learn more about db2trace facility.

Work with ``ps aux``
----------------------

**GOAL:** Detect whether there is memory leak issue for certain application?

During the work, I run into an issue that client observes memory leak for our product and I need to invesitgate into it. First things first, I need to at least
make sure if memory leak problem exists. I use a small shell script to take snapshot of product's memory usage every certain time period and it looks like below::

  Tue Mar 22 03:44:22 CDT 2016
  iidev20  62786192  0.9  0.0 29760 29800      - A      Mar 16 592:48 db2fmp (C)
  Tue Mar 22 03:45:13 CDT 2016
  iidev20  62786192  0.9  0.0 29760 29800      - A      Mar 16 592:52 db2fmp (C)
  Tue Mar 22 03:45:19 CDT 2016
  iidev20  62786192  0.9  0.0 29760 29800      - A      Mar 16 592:53 db2fmp (C)
  Tue Mar 22 03:45:26 CDT 2016
  iidev20  62786192  0.9  0.0 29760 29800      - A      Mar 16 592:53 db2fmp (C)
  Tue Mar 22 04:04:44 CDT 2016
  iidev20  40504624  0.5  0.0 29200 29240      - A    04:02:54  0:04 db2fmp (C)
  Tue Mar 22 04:14:45 CDT 2016
  iidev20  40504624  0.8  0.0 37784 37824      - A    04:02:54  0:47 db2fmp (C)

  ...

This result is generated from `ps aux` and what I'm really interested is the `RSS` column (ie 29800, 29800, ...). How do I ignore all other info for now and
extract that column from my result ("log_fenced_bad.txt") in order to further analyze it through plotting? AWK!::

  awk '!(NR%2) {print $6}' log_fenced_bad.txt

.. note::

   - ``$6`` refers to 6th column of every line separate by white space, which happen to be our `RSS` column
   - ``NR%2`` checks if the line number is even or odd. In our case, we only print `$6` when line number is odd.

This will get us::

  29800
  29800
  29800
  29800
  29240
  37824

  ...

************
Resources
************

- `AWK short tutorial <http://coolshell.cn/articles/9070.html>`_
- `AWK Language Programming for Utah.edu <http://www.math.utah.edu/docs/info/gawk_toc.html>`_
