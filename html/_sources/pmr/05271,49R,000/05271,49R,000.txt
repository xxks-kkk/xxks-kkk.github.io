.. _05271,49R,000:

#############
05271,49R,000
#############

Last Update: |today|

.. _link:

****
Link
****

https://w3-01.sso.ibm.com/software/servdb/crm/secure/l3PmrRecord1.do?&pmrno=05271&bno=49R&cno=000&createDate=O15/04/07&method=retrieveCRMWithDate

********
Abstract
********

A parameter (``fetchFlag`` representing a row count to be fetched from Oracle side) being passed to Oracle OCIStmtExecute call is a negative value,
which leads to a trap on Oracle side.

************
Environment
************

::

	Linux/X8664
	DB2 Release Info
	Server is running DB2 partitioned database environment(2 partitions)
	DB21085I  This instance or install (instance name, where applicable:
	"db2inst1") uses "64" bits and DB2 code release "SQL10013" with level
	identifier "0204010E".
	Informational tokens are "DB2 v10.1.0.3", "special_33885", "IP23516_33885", and
	Fix Pack "3".
	Product is installed at "/opt/IBM/WSII/V10.1_sb33885".


*************
Problem
*************

See :ref:`CRM <link>` and `Intel Revisit <../../_static/pmr/05271,49R,000/Intel_Revisit.html>`_

In short, negative ``fetchFlag`` value sent as iter(N) to call Oracle API: OCIStmtExecute leads to Oracle trap.

*************
Analysis
*************

**11/18/15:**
	1. Finish revisiting intel discussion posts, and briefly extract some `highlights <../../_static/pmr/05271,49R,000/Intel_Revisit.html>`_ through them.
	
	2. Current situation:
	
		The previous fix works when Intel creates a new server with ``DB2_REQUESTS_IO_BLOCK_BUF`` set no greater than 512. However, since Intel already creates
		the server with ``DB2_REQUESTS_IO_BLOCK_BUF`` equal to 1024, and part of fix that intends to tolerate 1024 doesn't work. "Tolerate" here means that
		we internally chang 1024 to 512 during the ``unfencedServer:: initialize_server`` in ``sqlqg_unfenced_server.C``. So, technically the fix works partially.
		
	3. The key statements are:
	
		.. code-block:: c++
		
				fetchFlag = m_output_data->num_rows;
		
				rc = m_api->call_OCIStmtExecute(m_connection->m_svchp, 
                                                                m_stmthp, 
                                                                m_stmtErr, 
                                                                (ub4) fetchFlag,
								(ub4) 0, 
                                                                (CONST OCISnapshot *) NULL, 
                                                                (OCISnapshot *) NULL, OCI_DEFAULT);
												
		Now I'm thinking we cannot allow the maximum value of ``fetchFlag`` to overflow 
                the maximum value of ``ub4``.
		
	4. Investigation on ``ub4``:
	
		- First, ``ub4`` is defined as ``unsigned int``
		
			.. code-block:: c++
			
				typedef unsigned int  ub4;  
				
		.. seealso:: http://docs.oracle.com/cd/A87860_01/doc/appdev.817/a76975/oci03typ.htm
		
		- The maximum value of ``ub4`` is defined as ``UB4MAXVAL``
		
			.. code-block:: c++
			
				#define UB4MAXVAL ((ub4)UINT_MAX)
				
		.. seealso:: http://docs.oracle.com/cd/A87860_01/doc/appdev.817/a76975/oci03typ.htm
		
		- The size of ``UINT_MAX`` is defined as 4294967295, which matchs with the largest possible value of **uint32**
		
		.. seealso:: https://docs.oracle.com/cd/E19455-01/806-5194/casestudy-28/index.html
		
	5. Actually this is quite strange for me because I already modified the data type of ``fetchFlag`` 
           from **sqlint32** to **Uint32**. So, I guess I will try to add sanity check on the maximum value 
           of ``fetchFlag`` each time when ``fetchFlag = m_output_data->num_rows`` appears.
	   
	   .. todo:: 
	       
                I also need to find the official doc on ``OCIStmtExecute`` to see what exactly requirement for 
                intake arguments

**11/19/15:**

        1. I dig through ``OCIStmtExecute()`` official documentation on 
           `Oracle <https://docs.oracle.com/database/121/LNOCI/oci17msc001.htm#LNOCI17163>`_, and find out that
           ``fetchFlag`` is actually ``ub4 iters``, which is defined as follows:
           ::

                iters (IN)

                For non-SELECT statements, the number of times this statement is executed is equal to iters - rowoff.

                For SELECT statements, if iters is nonzero, then defines must have been done for the statement handle. 
                The execution fetches iters rows into these predefined buffers and prefetches more rows depending upon 
                the prefetch row count. If you do not know how many rows the SELECT statement will retrieve, 
                set iters to zero.

                This function returns an error if iters=0 for non-SELECT statements.

                Note:

                        For array DML operations, set iters <= 32767 to get better performance.

           32767 is actually equals to the maximum value of ``Sint16``

*************
Fix & Tests
*************

See the previous code fix record `here <../../_static/pmr/05271,49R,000/05271,49R,000.sh>`_

.. warning:: this fix doesn't work

Code change from previous **doesn't work** fix:

.. code-block:: bash

        The branch name got is: temp_iidev20_db2_v101fp3_hzy 

        /vbs/engn/include/sqlqg_df.h@@/main/db2_v101base/db2_v101fp3/temp_iidev20_db2_v101fp3_hzy/3
        /vbs/engn/sqqg/sqlqg_api_fmp.C@@/main/temp_iidev20_db2_v101fp3_hzy/1
        /vbs/engn/sqqg/sqlqg_unfenced_server.C@@/main/db2_v101base/temp_iidev20_db2_v101fp3_hzy/2
        /vbs/engn/sqqg_net8/sqlqg_net8_operation.C@@/main/db2_v101base/db2_v101fp3/temp_iidev20_db2_v101fp3_hzy/2

**11/19/15:**

        **root cause found:**
                
        In ``sqlqg_net8_operation.C``, ``allocate_output_data_buffer`` function, ``num_rows`` is assigned as
        ``int`` type, which is **4 byte**. 

        .. code-block:: c++
                
                int num_rows=0; // Number of rows in the buffer

                num_rows = (Wrapper_Utilities::get_rqrioblk() - row_size)/row_data_size;

        However, it is assigned to a data type ``short`` in the following:

        .. code-block:: c++

                m_output_data->num_rows = num_rows;

        ``m_output_data`` is a struct pointer that points to ``Net8_data_buffer``, which is defined
        in ``Sqlqg_net8_operation.h`` as follows:

        .. code-block:: c++

                // Structure used to describe a set of rows fetched from/sent to(?) Oracle.
                typedef struct Net8_data_buffer
                {
                        short num_rows;   // number of rows in buffer.
                        short index_of_next_row; // next row to process
                        struct Net8_column_buffer* column; // pointer to column header of next row to process
                } Net8_data_buffer;

        As can see from above, ``short`` is **2 byte**, while ``int`` is **4 byte**. Assign ``int`` to ``short`` 
        will definitely lead to a **overflow**.         
                
        .. note::
           1. In 32-bit system, ``int`` is **always** 16 bit. In 64-bit system, ``int`` is **usually** 32 bit.
           2. ``short`` is equivalent to ``Sint16``

	**fix:**

                Add check condition right after the statement ``num_rows = (Wrapper_Utilities::get_rqrioblk() -
                row_size)/row_data_size;`` like follows:
        
                .. code-block:: c++

                        if (num_rows > 32767) // 32767 is max val of Sint16
                        {
                           num_rows = 32767;
                        } 
                
                Even we haven't changed the data type for either ``short`` or ``int`` but bound the maximum value of
                ``int`` data type ``num_rows`` to 32767 is equivalent to change its data type from ``int`` to ``short``

                .. note::
                    
                        The reason we don't change the data type of either ``short`` or ``int`` because
                        it may have other unforseenable impact on the downstream call stack that may make
                        difference on what data type they are referencing.

                Also, rollback the previous code change fix, it doesn't make any impact at all.

**11/20:**
        Testing procedure:

                1. ``ssh 82`` and first ``selview`` the view that **doesn't** contain my fix (i.e. 
                   iidev20_db2_v101fp3_linuxamd64_n130918_hzyintel) and then ``uselvl``

                2. connect to db (run ``db2 -tvf intel.clp``) `intel.clp <../../_static/pmr/05271,49R,000/intel.clp>`_
				
				3. describe SYSCAT: ``db2 "select OPTION,SETTING from syscat.SERVEROPTIONS where SERVERNAME='ORARDB'"``
				
				4. ctsetview "iidev20_db2_v101fp3_linuxamd64_n130918_hzy"
				
				5. ``uselvl``
				
				6. connect to db
				
				7. ``db2 -tvf intel2.clp`` `intel2.clp <../../_static/pmr/05271,49R,000/intel2.clp>`_
				
				8. ``grep -i 1992 intel.flw`` and found that ``Net8_Statement::allocate_output_array_buffer data [probe 1992]`` has the
					corresponding number 72607
				
				9. In intel.fmt, 72607 line has the following::
				
					72607   data DB2 UDB net8 wrapper Net8_Statement::allocate_output_array_buffer fnc (3.3.63.167.0.1992)
					    pid 31043 tid 1083185472 cpid -1 node 0 probe 1992
						bytes 12
 
						Data1   (PD_TYPE_DEFAULT,4) Hexdump:
						FF7F 0000                                  ....
						
					which is 32767
	
				.. note:: 
					
						Here the number should be interpreted in the reverse order. That is ``0000 7FFF`` because
						the system uses little endian. 
						Also notice that each hex digit is 4 bits, we need 8 hex digits to represent the 32 bit value
						(since ``num_row`` print out by trace is int with size of 4 bytes), so the 4 bytes are: 00 00
						7F FF where each byte requires 2 hex digits. When we say "reverse order", we really mean to reverse
						the bytes not single hex digits. In other words, we should trea 2 hex digits as a single unit, and reverse
						them. *Not reverse by each single hex digit*
						
				.. seealso::
					
						- This `article <https://www.cs.umd.edu/class/sum2003/cmsc311/Notes/Data/endian.html>`_ has nice introduction to endian.
						- To know what endian you system follows, run ``lscpu``. This `post <http://unix.stackexchange.com/questions/88934/is-there-a-system-command-in-linux-that-reports-the-endianness>`_ provides other commands if ``lscpu`` doesn't work.
						- You can use ``man limits.h`` to get list of variables and ``getconf [varName]`` to figure out value (i.e. ``getconf INT_MAX``, ``getconf CHAR_BIT``) More `info here <http://unix.stackexchange.com/questions/115222/possible-to-find-out-the-sizes-of-data-types-int-float-double-on-a-syst>`_
						
						
				10. ``grep -i execute intel.flw`` and found ``Next8_Statement::execute data [probe 20]`` has the corresponding number 72628
				
				11. In intel.fmt, 72628 line has the following::
				
					72628   data DB2 UDB net8 wrapper Net8_Statement::execute fnc (3.3.63.156.0.20)
						pid 31043 tid 1083185472 cpid -1 node 0 probe 20
						bytes 12
 
						Data1   (PD_TYPE_SINT,4) signed integer:
						32767
					
				This proves that ``fetchFlag`` value indeed set to 32767

Succint Fix Summary
===================
	
	- Root cause:
                Oracle wrapper uses ``num_rows`` as int but it is assigned to ``num_row`` with data type short 
                in ``Net8_data_buffer``, which leads to overflow. This overflowed ``num_rows`` value (already negative) 
                is assigned to ``fetchFlag`` and cause Oracle trap.

        - Solution:
                Add check condition right before the calculated int ``num_rows`` got assigned to the ``Net8_data_buffer``
                struct member: short ``num_rows`` to prevent the value goes beyond the maximum value of Sint16, 
                which is 32767

        - Files List：
                The branch name got is: temp_iidev20_db2_v101fp3_hzy
 
                .. note:: 
 
                       The effective code change resides in 
                       /vbs/engn/sqqg_net8/sqlqg_net8_operation.C@@/main/db2_v101base/db2_v101fp3/temp_iidev20_db2_v101fp3_hzy/8
                       The rest of code changes are roll back from previous code fix.
 
        - UT:
 
                Simulates the Intel situation with the following setup:
 
                1. Create server with DB2_IO_MAX_BUFF 1024
                2. Trace the ``num_rows`` value after check condition as 32767
                3. Trace the ``fetchFlag`` value right before Oracle API call as 32767
 
                .. note::

                       the code change with trace code added: 
                       /vbs/engn/sqqg_net8/sqlqg_net8_operation.C@@/main/db2_v101base/db2_v101fp3/temp_iidev20_db2_v101fp3_hzy/7 within the same branch as above.

**********
Remarks
**********

Take extra care on the data type. It may have huge impact on the running result.
