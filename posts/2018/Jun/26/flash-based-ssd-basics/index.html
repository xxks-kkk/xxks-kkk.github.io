<!DOCTYPE html>
<!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js"> <!--<![endif]-->
    <head>
        <meta charset="utf-8">
        <title>    Flash-based SSD Basics
</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta content="This is the homepage of Zeyuan (Zack) Hu" name="description">
        <meta content="Zeyuan Hu, Zeyuan, Zack Hu, zack, zeyuan hu, zeyuan ibm, IBM, Zeyuan IBM, UW Madison, University of Wisconsin Madison, zeyuan wisc, zeyuan IBM, zeyuan federation" name="keywords">
        <meta content="Zeyuan Hu" name="author">
        <link href='https://fonts.googleapis.com/css?family=Gentium+Book+Basic|Merriweather:400,300' rel='stylesheet' type='text/css'>
        <link rel="stylesheet" href="../../../../../theme/css/cid.css">
        <!-- add font-awesome -->
        <script defer src="../../../../../theme/fa-5/svg-with-js/js/fontawesome-all.js"></script>
        <link rel="stylesheet" href="../../../../../theme/academicons/css/academicons.css"/>
        <link href="https://zhu45.org/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="Ze-Yuan Hu's page Atom Feed" />
        <link href="https://zhu45.org/feeds/all.rss.xml" type="application/rss+xml" rel="alternate" title="Ze-Yuan Hu's page RSS Feed" />
        <link href="../../../../../theme/images/favicon.ico" rel="icon">
    </head>
    <body>
        <!--[if lt IE 7]>
            <p class="chromeframe">You are using an <strong>outdated</strong> browser. Please <a href="http://browsehappy.com/">upgrade your browser</a> or <a href="http://www.google.com/chromeframe/?redirect=true">activate Google Chrome Frame</a> to improve your experience.</p>
        <![endif]-->
            <div class="container">
<header class="blog-header">
        <h1 id="site-title"><a href="../../../../..">Ze-Yuan Hu's page</a></h1>
    <p></p>
    <nav>
        <!--<a href="../../../../../zeyuan-hus-resume.html" style="padding: 10px">RESUME</a>-->
        <!-- <a href="../../../../../archives" style="padding: 10px">ARCHIVES</a> -->
            <a href="../../../../../blog2" style="padding: 10px">BLOG</a>
            <a href="../../../../../projects.html" style="padding: 10px">PROJECTS</a>
            <a href="../../../../../links.html" style="padding: 10px">LINKS</a>
    </nav>
</header>
    <div class="post">
        <header>
            <h1 class="post-title">Flash-based SSD Basics</h1>
            <div class="panel">
                <div class="panel-body">
<footer class="post-info">
    <span class="label label-default">Date</span>
    <span class="published">
        <i class="fa fa-calendar"></i><time datetime="2018-06-26T23:24:00+08:00"> Jun 26, 2018</time>
    </span>





<span class="label label-default">Tags</span>
	<a href="../../../../../tag/ssd.html">ssd</a>
        /
	<a href="../../../../../tag/storage.html">storage</a>
    
</footer><!-- /.post-info -->                </div>
            </div>
        </header>
        
        <article>
            <html><body><div class="toc">
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#raw-flash">Raw Flash</a><ul>
<li><a href="#storing-a-single-bit">Storing a Single Bit</a></li>
<li><a href="#from-bits-to-banksplanes">From Bits to Banks/Planes</a></li>
<li><a href="#basic-flash-operations">Basic Flash Operations</a></li>
<li><a href="#flash-performance-and-reliability">Flash Performance and Reliability</a></li>
</ul>
</li>
<li><a href="#from-raw-flash-to-flash-based-ssds">From Raw Flash to Flash-Based SSDs</a><ul>
<li><a href="#the-organization-of-flash-based-ssd">The organization of Flash-based SSD</a></li>
<li><a href="#build-flash-translation-layer-ftl">Build Flash Translation Layer (FTL)</a></li>
</ul>
</li>
<li><a href="#summary">Summary</a></li>
</ul>
</div>
<h2 id="introduction">Introduction</h2>
<p>In this post, we highlight the key points from <a href="http://pages.cs.wisc.edu/~remzi/OSTEP/file-ssd.pdf">Chapter 44: Flash-based SSDs from OSTEP</a>.</p>
<p>Solid-state storage device (SSD) is built out of transistors (like memory and processors) but it can retain information without power. First, we introduce the physical properties of the raw flash. Then, we focus on building a persistent storage device (i.e. NAND-based flash-based SSD)based on those physical properties.</p>
<p>Please note that I organize the post based on my own understanding of the chapter: the organization may not reflect the actual organization of the chapter. 
I also add a few illustrations to reflect the concepts in the chapter. Black &amp; white pictures are taken from the book while the color ones are the drawings on my own.</p>
<h2 id="raw-flash">Raw Flash</h2>
<p>In this section, we introduce the raw flash using the bottom-up approach by first introducing the basic building block: transistor (i.e. cell). Then,
we organize those cells into flash planes, which consist of physical blocks and pages. Finally, we introduce the basic operations supported
by the raw flash and possible performance and reliability considerations when we build a persistent storage device.</p>
<h3 id="storing-a-single-bit">Storing a Single Bit</h3>
<ul>
<li>Single-level cell (SLC) flash: a transistor (cell) stores a single bit (1 or 0)</li>
<li>Multi-level cell (MLC) flash: a transistor (cell) stores two bits (00, 01, 10,11)</li>
<li>Triple-level cell (TLC) flash: a transistor (cell) encodes 3 bits.</li>
</ul>
<h3 id="from-bits-to-banksplanes">From Bits to Banks/Planes</h3>
<ul>
<li>Flash chips are organized into <strong>banks</strong> or <strong>planes</strong>, which consists
of a large number of cells. </li>
</ul>
<p><img alt="A flash plane" class="img-responsive" src="/images/ssd.png"/></p>
<ul>
<li>
<p>A <strong>bank</strong> (<strong>plane</strong>) is accessed in two different sized units:</p>
<ul>
<li><strong>blocks</strong> (<strong>erase blocks</strong>): 128KB or 256KB</li>
<li><strong>pages</strong>: 4KB</li>
</ul>
</li>
</ul>
<h3 id="basic-flash-operations">Basic Flash Operations</h3>
<ul>
<li>
<p>Three low-level flash chip operations:</p>
<ul>
<li>
<p><strong>Read (a page)</strong>:</p>
<ul>
<li>read any page by specifying page number</li>
<li><strong>random access</strong> device: being able to access any location uniformly quickly (regardless of location on the device and the location of previous request)</li>
</ul>
</li>
<li>
<p><strong>Erase (a block)</strong>: </p>
<ul>
<li>Before writing to a page within a flash, the device needs
to first erase the entire block the page within</li>
<li>Need to make sure we save the contents of the to-be-erased blocks before executing the erase</li>
<li>The entire block is reset and each page within is read to be 
programmed</li>
</ul>
</li>
<li>
<p><strong>Program (a page)</strong>:</p>
<ul>
<li>Modified the page and write the modification to flash</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img alt="Three flash operation demonstrations" class="img-responsive" src="/images/read-erase-program.png"/></p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>We use <span class="math">\(\texttt{INVALID}\)</span>, <span class="math">\(\texttt{ERASED}\)</span>, and <span class="math">\(\texttt{VALID}\)</span>
to represents three states of a page. One should note that write to a page with state <span class="math">\(\texttt{E}\)</span> doesn't cause the entire block to be erased.
However, to write to a page with state <span class="math">\(\texttt{V}\)</span>, the device requires
the whole block to be erased.</p>
</div>
<p><img alt="Raw Flash Performance" class="img-responsive" src="/images/raw-flash-performance.png"/></p>
<h3 id="flash-performance-and-reliability">Flash Performance and Reliability</h3>
<ul>
<li>
<p><strong>wear out</strong>: when a flash block is erased and programmed, it slowly
accures a little bit of extra charge. Over time, as that extra charge
builds up, it becomes increasingly diffcult to differentiate between a 0
and a 1. At the point where it becomes impossible, the block becomes unusable.</p>
</li>
<li>
<p><strong>disturbance</strong>: when accessing a particular page within a flash, it
is possible that some bits get flipped in neighboring pages; such bit
flips are known as <strong>read disturbs</strong> or <strong>program disturbs</strong>, depending
on whether the page is being read or programmed, respectively.</p>
</li>
</ul>
<h2 id="from-raw-flash-to-flash-based-ssds">From Raw Flash to Flash-Based SSDs</h2>
<ul>
<li>Goal: standard storage interface is bocked-based one, where blocks
(sectors) of size 512 bytes can be read or written, given a block address.
Thus, flash-based SSD is to provide that standard block interface
atop the raw flash chips inside it.</li>
</ul>
<h3 id="the-organization-of-flash-based-ssd">The organization of Flash-based SSD</h3>
<ul>
<li>
<p>SSD consists of:</p>
<ul>
<li>flash chips: for persistent storage </li>
<li>volatile memory (SRAM): caching, buffering data, mapping tables</li>
<li>control logic (FTL)</li>
</ul>
</li>
</ul>
<p><img alt="SSD structure" class="img-responsive" src="/images/ssd-structure.png"/></p>
<h3 id="build-flash-translation-layer-ftl">Build Flash Translation Layer (FTL)</h3>
<ul>
<li>
<p>Flash Translation Layer (FTL):</p>
<ul>
<li>translate client reads &amp; writes on logical blocks -&gt; flash read, erase, program on physical blocks &amp; pages</li>
<li>performance:<ul>
<li>use multiple flash chips in parallel</li>
<li>reduce write amplification: the total write traffic (in bytes) issued to the flash chips by the FTL divided by the total write traffic (in bytes) issued by the client to the SSD.</li>
</ul>
</li>
<li>reliability:<ul>
<li><strong>wear leveling</strong> (prevent wear out): spread writes across the blocks of the flash as evenly as possible, ensuring that all of the blocks of the device wear out at roughly the same time;</li>
<li>prevent disturbance: program pages within an erased block <em>in order</em>, from low page to high page</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Direct-mapped FTL:</p>
<ul>
<li>1-1 mapping between logic page and physical page<ul>
<li>read of a logical page <span class="math">\(N\)</span> mapped to read of a physical page <span class="math">\(N\)</span>
directly</li>
<li>overwrtie of a logical page <span class="math">\(N\)</span> leads to the write amplification:<ul>
<li>read in the entire block that contains physical page <span class="math">\(N\)</span></li>
<li>erase the block</li>
<li>program the page <span class="math">\(N\)</span> along with the old pages within the block</li>
</ul>
</li>
</ul>
</li>
<li>can lead to wear out if the user repeated update the same logical 
page (e.g., update the same file system metadata over and over)</li>
</ul>
</li>
<li>
<p>Log-structured FTL:</p>
<ul>
<li>
<p>Upon a write to a logical block <span class="math">\(N\)</span>, the device appends the write
to the the next free spot in the currently-being-written-to block.</p>
</li>
<li>
<p>Write: the SSD finds a location for the write, usually just picking
the next free page; it then programs that page with the block's contents, and records the logical-to-physical mapping in its mapping
table.</p>
</li>
<li>
<p>Read: subsequent reads use the table to translate the logical block
address presented by the client into the physical page number required to read the data.</p>
</li>
<li>
<p>advantages: </p>
<ul>
<li>we avoid the overwrite of the physical page (by always writing to the next free page), which can cause the expensive erase
operation and write amplification.</li>
<li>FTL spreads the write across all pages and perform wear leveling
to increase the lifetime of the device.</li>
</ul>
</li>
<li>
<p>disadvantages:</p>
<ul>
<li>need to periodically perform garbage collection, which can increase write amplification and reduce performance</li>
<li>high cost of in-memory mapping tables (the larger the device,
the more memory such tables need)</li>
</ul>
</li>
<li>
<p>crash recovery:</p>
<ul>
<li>Since mapping table is stored in memory, we may lose it when
device loses power. To handle this, we can store some mapping
information in <strong>out-of-band (OOB)</strong> area within each page and
reconstruct the mapping table in memory.</li>
<li>Use logging and checking to speed up recovery.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img alt="log-structured FTL" class="img-responsive" src="/images/log-structured-ftl.png"/></p>
<ul>
<li>
<p>Garbage Collection (dead-block reclamation):</p>
<ul>
<li>garbage: old versions of data around the drive that takes up the space<ul>
<li>Ex: immediately follow the picture above, we write(100) with
content "c1". The original "a1" is no longer needed, which is
considered as garbage.</li>
</ul>
</li>
<li>garbage collection: the process of finding garbage blocks and
reclaiming them for future use. We can find a block that contains
one or more garbage pages, read in the live (non-garbage) pages from
that block, write out those live pages to the log, and (finally)
reclaim the entire block for use in writing.</li>
<li>determine the dead pages: the physical block contains the logical
block addresses it is holding. We can then determine the dead pages by comparing the logical block addresses in the mapping table with the logical block addresses in the physical block (e.g., physical block holds logical block address 2000 but 2000 inside the mapping
table pointing to the physical page that is outside of the current
physical block. Thus, we know the physical page that holds 2000
inside the physical block is the dead page).</li>
<li>The ideal candidate for reclamation is a block that consists of
only dead pages; in this case, the block can immediately be erased
and used for new data, without expensive data migration.</li>
<li>reduce GC costs: <strong>overprovision</strong> the device (adding extra
flash capacity)</li>
</ul>
</li>
<li>
<p>Block-Based Mapping:</p>
<ul>
<li>Instead of keeping one record per page in the mapping table, we keep
one record per block. Doing so will reduce the size of mapping table by a factor of <span class="math">\(\frac{Size_{block}}{Size_{page}}\)</span>.</li>
<li>Read: The read of a logical block address is shown in picture below. The whole read process greatly mimics the virtual address translation. The mapping table plays a role as the page table in the virtual memory system (map virtual pages to physical frames).</li>
<li>Write: if the client writes to logical block 2002 with content c',
FTL has to read in 2000, 2001, and 2003 and then write out all four
logical blocks in a new location (e.g. physical pages 08,09,10,11 with values a, b, c', d), updating the mapping table accordingly (because we try to overwrite a physical page).</li>
<li>disadvantage: performance decrease for the writes smaller than
the physical block size of the device (if the writes equal to
the physical block size, we can erase the whole block and do write
directly instead of saving some old data and rewrite them again
into new location.)</li>
</ul>
</li>
</ul>
<p><img alt="block-based read process" class="img-responsive" src="/images/block-based-mapping-ftl.png"/></p>
<ul>
<li>Hybrid Mapping</li>
</ul>
<h2 id="summary">Summary</h2>
<ul>
<li>
<p>Overwriting a page requires us to erase the whole block that the page resides in before we can write the page. This naturally introduces the
write amplification as we must first move any data we care about to
another location.</p>
</li>
<li></li>
</ul>
<script type="text/javascript">if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width < 768) ? "left" : align;
        indent = (screen.width < 768) ? "0em" : indent;
        linebreak = (screen.width < 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
</script></body></html>
        </article>

<!--        <footer>
            <p>This entry is posted in <a href="../../../../../category/2018.html">2018</a>.</p>
        </footer>-->

<div class="comments">
    <div id="disqus_thread"></div>
    <script type="text/javascript">
        var disqus_shortname = 'zhu45-org';
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>

    </div>


<footer class="blog-footer">
    <p class="disclaimer">
        Zeyuan Hu &copy; 2015-2018.
    </p>
</footer>
            </div>
<script>
    var _gaq=[['_setAccount','UA-37565522-2'],['_trackPageview']];
    (function(d,t){var g=d.createElement(t),s=d.getElementsByTagName(t)[0];
    g.src=('https:'==location.protocol?'//ssl':'//www')+'.google-analytics.com/ga.js';
    s.parentNode.insertBefore(g,s)}(document,'script'));
</script>
    </body>
</html>