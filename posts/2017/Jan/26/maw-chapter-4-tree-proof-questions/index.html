<!DOCTYPE html>
<html lang="en">
  <head>
        <title>MAW Chapter 4: Tree proof questions</title>
        <meta charset="utf-8" />
        <meta content="This is the homepage of Zeyuan (Jerry) Hu" name="description">
        <meta content="Zeyuan Hu, Zeyuan, Jerry Hu, Jerry, zeyuan hu, zeyuan ibm, IBM, Zeyuan IBM, UW Madison, University of Wisconsin Madison, Zeyuan wisc, zeyuan wisc, zeyuan IBM, zeyuan federation" name="keywords">
        <meta content="Zeyuan Hu" name="author">
        <link rel="stylesheet" href="../../../../../theme/css/main.css" type="text/css" />
        <link rel="stylesheet" href="../../../../../theme/css/font-awesome.min.css" type="text/css" />
        <link href='../../../../../theme/images/favicon.ico' rel='icon' type='image/x-icon'/>
        <link href="../../../../../None" type="application/atom+xml" rel="alternate" title="Tech Stuff ATOM Feed" />


        <!--[if IE]>
                <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

        <!--[if lte IE 7]>
                <link rel="stylesheet" type="text/css" media="all" href="../../../../../css/ie.css"/>
                <script src="../../../../../js/IE8.js" type="text/javascript"></script><![endif]-->

        <!--[if lt IE 7]>
                <link rel="stylesheet" type="text/css" media="all" href="../../../../../css/ie6.css"/><![endif]-->

</head>

<body id="index" class="home">
        <header id="banner" class="body">
          <!-- <h1><a href="../../../../../index.html"><img src="../../../../../theme/images/logo2.png" alt="Tech Stuff" /><br /><strong>A tmp place to rest</strong></a></h1> -->
          <!-- <h1><a href="../../../../../index.html">Tech Stuff<br /><strong>A tmp place to rest</strong></a></h1> -->
                <nav><ul>
                    <li ><a href="../../../../../about-zack.html">About Zack</a></li>
                    <li ><a href="../../../../../projects.html">Projects</a></li>
                    <li ><a href="../../../../../quotes.html">Quotes</a></li>
                <li><a href="../../../../..">Blog</a></li>
                <li><a href="../../../../../archives/index.html">Archives</a></li>
                </ul></nav>
        </header><!-- /#banner -->

<section id="content" class="body">
<article>
      <header> <h1 class="entry-title"><a href="../../../../../posts/2017/Jan/26/maw-chapter-4-tree-proof-questions/"
        rel="bookmark" title="Permalink to MAW Chapter 4: Tree proof questions">MAW Chapter 4: Tree proof questions</a></h1>  </header>
        <div class="entry-content">
<footer class="post-info">
    <p><i class="fa fa-calendar-o fa-fw"></i> <abbr style="padding: 0 1px" class="published" title="2017-01-26T17:41:00+08:00">Thu 26 Jan 2017, 17:41</abbr></p>

<p><i class="fa fa-folder-open fa-fw"></i> <a href="../../../../../category/data-struct-and-algo-analysis-in-c.html">Data Struct and Algo Analysis in C</a> </p>
<p><i class="fa fa-tags fa-fw"></i>&nbsp;<a href="../../../../../tag/trees.html">trees</a> <a href="../../../../../tag/proof.html">proof</a> </p></p></footer><!-- /.post-info --><!-- /.post-info -->
        <p>There are a lot of written proof questions in Chapter 4. Those questions offer
great insights on the general techniques in solving algorithmatic proving questions.
So, I decide to record them in this single post. Of course, this post will be continually
updated as I work through the chapter.</p>
<h2>Insights</h2>
<ul>
<li>Recursive tree definition is a natural fit with induction (i.e., MAW 4.5, 4.6, 4.7).</li>
<li>Usually there are two ways to prove a problem in tree, one direction is from induction
  and the other one is from basic tree property (i.e., MAW 4.4, 4.6).</li>
</ul>
<h2>Solutions</h2>
<h3>MAW 4.4</h3>
<blockquote>
<p>Show that in a binary tree of <span class="math">\(N\)</span> nodes, there are <span class="math">\(N + 1\)</span> <code>NULL</code> pointers
representing children.</p>
</blockquote>
<p><strong>Proof:</strong>
For a binary tree with <span class="math">\(N\)</span> nodes, there are two types of edges (pointers): </p>
<ol>
<li>edges that are doesn't exist (<code>NULL</code> pointers).</li>
<li>edges that exist to connect nodes (not <code>NULL</code> pointers).</li>
</ol>
<p>Let's first calculate the number of pointers in total, regardless whether the pointer
is <code>NULL</code> or not. Since each node has <span class="math">\(2\)</span> outgoing pointers, 
there are <span class="math">\(2N\)</span> pointers in total. Next, we need to calculate the number of edges that actuall
exist. Since each edge connects some node to its parent, and every node except 
the root has one parent. In other words, each node, except the root node, has one incoming
pointer from its parent. So, we have <span class="math">\(N-1\)</span> edges existing. Thus the remaining
<span class="math">\(2N - (N-1) = N+1\)</span> edges are actually non-existing. Thus, we have <span class="math">\(N+1\)</span> <code>NULL</code> pointers.</p>
<h3>MAW 4.5</h3>
<blockquote>
<p>Show that the maximum number of nodes in a binary tree of height <span class="math">\(H\)</span> is <span class="math">\(2^{H+1}-1\)</span>.</p>
</blockquote>
<p><strong>Proof:</strong> 
Let's prove this by induction.</p>
<p><em>Base case:</em> <span class="math">\(H = 0\)</span>. A binary tree of height <span class="math">\(0\)</span> has only one node, root. <span class="math">\(2^{H+1}-1\)</span> equals
one for <span class="math">\(H = 0\)</span>. Therefore ture for <span class="math">\(H = 0\)</span>.</p>
<p><em>Inductive Hypothesis:</em> Assume that the maximum number of nodes in a binary tree of height <span class="math">\(H\)</span> is
<span class="math">\(2^{H+1}-1\)</span> for <span class="math">\(H = 1, 2, ..., k\)</span>. Consider a tree <span class="math">\(T\)</span> of height <span class="math">\(k+1\)</span>. The root of <span class="math">\(T\)</span> has 
a left subtree and a right subtree each of which has height at most <span class="math">\(k\)</span>. These can have
at most <span class="math">\(2^{k+1}-1\)</span> nodes each by the inductive hypothesis. Adding the root node gives the 
maximum number of nodes in a binary tree of height <span class="math">\(k+1\)</span>, </p>
<div class="math">$$
\begin{equation} 
2(2^{k+1} - 1) + 1 = 2^{(k+1)+1} - 1 
\end{equation}
$$</div>
<p>Remarks:</p>
<p>The maximum condition achieves when we have <em>perfect binary tree</em>.</p>
<div class="math">$$
\begin{equation}
n = \sum_{i=0}^{h} 2^i = 2^{h+1} - 1 \text{where n is the number of nodes} 
\end{equation}
$$</div>
<h3>MAW 4.6</h3>
<blockquote>
<p>A <em>full node</em> is a node with two children. Prove that the number of full nodes
plus one is equal to the number of leaves in a nonempty binary tree.</p>
</blockquote>
<p>Let's use two methods to prove this question.</p>
<p><em>Method 1:</em></p>
<p><strong>Proof:</strong>
Let's use the following notation for our proof:</p>
<div class="math">$$
\begin{eqnarray*}
N &amp; = &amp; \text{number of nodes in a nonempty binary tree} \\
F &amp; = &amp; \text{number of full nodes} \\
H &amp; = &amp; \text{number of nodes with one child} \\
L &amp; = &amp; \text{number of leaves}
\end{eqnarray*}
$$</div>
<p>Then, we have <span class="math">\(N = F + H + L \label{eq:1}\)</span>. We can get another equation based on the number of 
edges: <span class="math">\(N - 1 = 2F + H \label{eq:2}\)</span>. <span class="math">\(N-1\)</span> is the number of edges for a <span class="math">\(N\)</span> node binary tree 
and <span class="math">\(2F + H\)</span> is another way to calculate the number of edges. Now based on these 
two euqations we have:</p>
<div class="math">$$
\begin{eqnarray*}
2F + H + 1 &amp; = &amp; F + H + L \\
F + 1 &amp; = &amp; L
\end{eqnarray*}
$$</div>
<p><em>Method 2:</em></p>
<p><strong>Proof:</strong>
Let's prove by induction. If there are <span class="math">\(N\)</span> full nodes in a non-empty binary tree
then there are <span class="math">\(N+1\)</span> leaves.</p>
<p><em>Base case:</em> <span class="math">\(N = 0\)</span> This is ture because the tree has one node and the root is 
a leaf.</p>
<p><em>Inductive hypothesis:</em> Suppose the theorem holds for <span class="math">\(N = 1, 2, ..., k\)</span>. Then we 
want to show that if there are <span class="math">\(k+1\)</span> full nodes in a non-empty binary tree then there 
are <span class="math">\(k+2\)</span> leaves. Pick a leaf node and keep removing its parent recursively 
(i.e., remove its parent and then parent's parent and so on) until a full node
is reached. That is, you are traversing from a leaf along the path towards the root,
while removing the nodes along the path before a full node is reached. This full node
becomes a non-full node because one of its child node is removed. At this point the
tree will have one less leaf and one less full node.</p>
<p><img alt="" src="../../../../../images/maw-4-6.PNG" /></p>
<p>Therefore, the tree has <span class="math">\(k\)</span> full nodes after the nodes are removed. By the inductive
hypothesis there are <span class="math">\(k+1\)</span> leaves. Add all the nodes that were removed back into the 
tree the same way to create the original tree. We are adding one full node and 
one leaf node. Therefore, we have <span class="math">\(k+1\)</span> full nodes with <span class="math">\(k+2\)</span> leaves.</p>
<h3>MAW 4.7</h3>
<blockquote>
<p>Suppose a binary tree has leaves <span class="math">\(l_{1}, l_{2}, ..., l_{M}\)</span> at depths
<span class="math">\(d_{1}, d_{2}, ...,d_{M}\)</span>, repectively. Prove that <span class="math">\(\sum_{i=1}^M 2^{-d_{i}} \leq 1\)</span>
and determine when the quality is true.</p>
</blockquote>
<p><strong>Proof:</strong>
Let's prove this by induction. </p>
<p><em>Base case:</em> when <span class="math">\(M = 1\)</span>, there is one node: the root is a leaf wit depth zero. Then
the sum is one, and claim holds.</p>
<p><em>Inductive hypothesis:</em> Suppose the theorem is true for all trees with at most <span class="math">\(k\)</span> nodes.
Consider any tree with <span class="math">\(k+1\)</span> nodes. Such a tree consists of an <span class="math">\(i\)</span> node left subtree and 
a <span class="math">\(k-i\)</span> node right subtree. By the inductive hypothesis, the sum for the left subtree
leaves is at most one with respect to the left tree root. Because all leaves are one deeper
with respect to the original tree than with respect to the subtree, the sum is at
most <span class="math">\(1/2\)</span> with respect to the root. Similar logic implies that the sum for leaves 
in the right subtree is at most <span class="math">\(1/2\)</span> proving the theorem.</p>
<p>The equality is true if and only if every internal node is a full node. In other words,
no nodes have one child. Suppose there is a node with one child, and the equality still
holds. Each time we remove two nodes to create a new tree that has a node with no child.
This new tree has the same property has the previous one, and by the statement we proved
above, we should have the same sum as the old, which is one. Eventually, we are left
with two node, one of them is root. Now, we calculate the sum, which gives <span class="math">\(1/2\)</span>. This 
is contradiction to the equality.</p>
<p>* ---- Note ---- *</p>
<blockquote>
<p>This problem is called <a href="https://en.wikipedia.org/wiki/Kraft%E2%80%93McMillan_inequality">Kraft–McMillan inequality</a>,
  which is one of fundamental theorem in Information theory. I find <a href="https://www.youtube.com/playlist?list=PLE125425EC837021F">this youtube playlist about information theory</a>
  is really good as an intro to the field because it doesn't make the material look very daunting and super technical,
  which some <a href="http://circuit.ucsd.edu/~yhk/ece154c-spr16/pdfs/LectureNotes01.pdf">lecture note</a> manages to achieve.</p>
</blockquote>
<h3>MAW 4.14</h3>
<blockquote>
<p>Prove that the depth of a random binary search tree (depth of the deepest node) is <span class="math">\(O(\log N)\)</span>, on average.</p>
</blockquote>
<p>This question can be restated like the following: suppose that we insert <span class="math">\(n\)</span> distinct elements into an 
initially empty tree. Assuming that the <span class="math">\(n!\)</span> permutations are equally likely to occur, then show that
the average height of the tree is <span class="math">\(O(\log N)\)</span>.</p>
<p>Before we dive into the proof, let's think about how we can construct a random binary search tree.
We construct a tree <span class="math">\(T\)</span> by inserting in order randomly selected <span class="math">\(n\)</span> distinct elements into an 
initially empty tree. Here the actual values of the elements do not matter. What matters is the position
of the inserted element in the <span class="math">\(n\)</span> elements. Thus, we construct a random binary search tree as the following:</p>
<p>An element <span class="math">\(i\)</span> from the <span class="math">\(n\)</span> elements is selected uniformly ar random and is inserted to the empty tree. Then all 
the other elements are inserted. Here all the elements greater than <span class="math">\(i\)</span> go into the right subtree of <span class="math">\(i\)</span>
and all the elements smaller than <span class="math">\(i\)</span> go into the left subtree. Thus, the height of the tree constructed
is one plus the larger of the height of the left subtree and the height of the right subtree.</p>
<p><strong>Proof:</strong>
Following our construction process above, if we randomly choose the <span class="math">\(i^{th}\)</span> key, the left
subtree has <span class="math">\(i-1\)</span> elements and the right subtree has <span class="math">\(n-i\)</span> elements. Let <span class="math">\(h_{n}\)</span> be the
height of a randomly built binary search tree on <span class="math">\(n\)</span> keys. Then we have</p>
<div class="math">$$
\begin{equation} 
h_{n} = 1 + max(h_{i-1}, h_{n-i}) \label{eqn:1}
\end{equation}
$$</div>
<p>Now, let's define <span class="math">\(Y_{n} = 2^{h_n}\)</span>. If we can show 
that <span class="math">\(E[Y_n]\)</span> is polynomial in <span class="math">\(n\)</span>, we then have <span class="math">\(E[h_n] = O(\log n)\)</span>. Again, <span class="math">\(Y_n\)</span> 
depends on <span class="math">\(i\)</span> not <span class="math">\(n\)</span>. Let's represent \ref{eqn:1} in terms of <span class="math">\(Y_n\)</span>:</p>
<div class="math">$$
\begin{eqnarray*}
h_{n} &amp;=&amp; 1 + max(h_{i-1}, h_{n-i}) \\
2^{h_n} &amp;=&amp; 2^{1 + max(h_{i-1}, h_{n-i})} \\
        &amp;=&amp; 2 \cdot 2^{max(h_{i-1}, h_{n-i})} \\
        &amp;=&amp; 2 \cdot max(2^{h_{i-1}}, 2^{h_{n-i}}) \\
Y_n     &amp;=&amp; 2 \cdot max(Y_{i-1}, Y_{n-i}) 
\end{eqnarray*}
$$</div>
<p>Now, let's calculate <span class="math">\(E[Y_n]\)</span>. Here, <span class="math">\(I=i\)</span> means we pick <span class="math">\(i_{th}\)</span> element as our 
first element inserting into the empty tree.Since, we pick the first insertion element equally
likely, then <span class="math">\(P(I=i) = 1/n\)</span>.</p>
<div class="math">$$
\begin{eqnarray*}
E[Y_n] &amp;=&amp; \sum_{i=1}^n E[Y_n|I=i]P(I=i) \\
       &amp;=&amp; \sum_{i=1}^n E[Y_n|I=i]\frac{1}{n} \\
       &amp;=&amp; \frac{2}{n}\sum_{i=1}^n E[max(Y_{i-1},Y_{n-i})] \\
       &amp;\le&amp; \frac{2}{n}\sum_{i=1}^n (E[Y_{i-1}] + E[Y_{n-i}])
\end{eqnarray*}
$$</div>
<p>Now we expand the last summation as</p>
<div class="math">$$
\begin{equation}
(E[Y_0] + E[Y_{n-1}]) + \dots + (E[Y_{n-1}] + E[Y_0]) = 2\sum_{i=0}^{n-1}E[Y_i]
\end{equation}
$$</div>
<p>Thus, we have</p>
<div class="math">$$
\begin{equation}
E[Y_n] \le \frac{4}{n}\sum_{i=0}^{n-1}E[Y_i]
\end{equation}
$$</div>
<p>Then, we will show that for all integers <span class="math">\(n&gt;0\)</span>, </p>
<div class="math">$$
\begin{eqnarray*}
E[Y_n] &amp;\le&amp; \frac{1}{4}\dbinom{n+3}{3} \\
       &amp;=&amp; \frac{1}{4}\cdot\frac{(n+3)(n+2)(n+1)}{6} \\ 
       &amp;=&amp; O(n^3)
\end{eqnarray*}
$$</div>
<p>Then, we use <em>Jensen's inequality</em>, which states that <span class="math">\(f(E[X]) \le E[f(X)]\)</span> provided
the expectations exist and are finite, and f(x) is convex. Let this <span class="math">\(X\)</span> be <span class="math">\(h_n\)</span> and
<span class="math">\(f(x) = 2^x\)</span>, then <span class="math">\(E[f(X)] = E[Y_n]\)</span>. So, we have</p>
<div class="math">$$
\begin{equation}
2^{E[h_n]} \le \frac{1}{4}\dbinom{n+3}{3} = O(n^3)
\end{equation}
$$</div>
<p>By taking the log of both sides, we have <span class="math">\(E[h_n] = O(\log n)\)</span></p>
<p><strong>Remarks:</strong></p>
<ul>
<li>Let's first prove <span class="math">\(\sum_{i=0}^{n-1}\dbinom{i+3}{3} = \dbinom{n+3}{4}\)</span></li>
</ul>
<p><strong>Proof:</strong> Use <em>Pascal's identity:</em> <span class="math">\(\dbinom{n}{k} = \dbinom{n-1}{k-1} + \dbinom{n-1}{k}\)</span>
Also using the simple identity <span class="math">\(\dbinom{4}{4} = 1 = \dbinom{3}{3}\)</span>. We have:</p>
<div class="math">$$
\begin{eqnarray*}
\dbinom{n+3}{4} &amp;=&amp; \dbinom{n+2}{3} + \dbinom{n+2}{4} \\
                &amp;=&amp; \dbinom{n+2}{3} + \dbinom{n+1}{3} + \dbinom{n+1}{4} \\
                &amp;=&amp; \dbinom{n+2}{3} + \dbinom{n+!}{3} + \dbinom{n}{3} + \dbinom{n}{4} \\
                &amp;\vdots&amp; \\
                &amp;=&amp; \dbinom{n+2}{3} + \dbinom{n+!}{3} + \dbinom{n}{3} + \dots + \dbinom{4}{3} + \dbinom{4}{4} \\
                &amp;=&amp; \sum_{i=0}^{n-1}\dbinom{i+3}{3}
\end{eqnarray*}
$$</div>
<ul>
<li>Let's prove <span class="math">\(E[Y_n] \le \frac{1}{4}\dbinom{n+3}{3}\)</span> by induction.</li>
</ul>
<p><strong>Proof:</strong> <em>Base case:</em> <span class="math">\(n=1\)</span>. </p>
<div class="math">$$
\begin{equation}
1 = Y_1 = E[Y_1] \le \frac{1}{4}\dbinom{1+3}{3} = 1.
\end{equation}
$$</div>
<p><em>Inductive Hypothesis:</em> Assume that <span class="math">\(E[Y_i]\le\frac{1}{4}\dbinom{i+3}{3}\)</span> for all <span class="math">\(i&lt;n\)</span>. Then,</p>
<div class="math">$$
\begin{eqnarray*}
E[Y_n] &amp;\le&amp; \frac{4}{n}\sum_{i=0}^{n-1}E[Y_i] \\
       &amp;\le&amp; \frac{1}{4}\dbinom{i+3}{3} \\
       &amp;=&amp;   \frac{1}{n}\sum_{i=0}^{n-1}\dbinom{i+3}{3} \\
       &amp;=&amp;   \frac{1}{n}\dbinom{n+3}{4} \\
       &amp;=&amp;   \frac{1}{n}\frac{(n+3)!}{4!(n-1)!} \\
       &amp;=&amp;   \frac{1}{4}\frac{(n+3)!}{3!n!} \\
       &amp;=&amp;   \frac{1}{4}\frac{n+3}{3}
\end{eqnarray*}
$$</div>
<p>* ---- Note ---- *</p>
<blockquote>
<p>I <a href="https://www.cs.bgu.ac.il/~fds112/wiki.files/P05.pdf">reference this lecture note</a> when I try to develop the proof. 
Overall, I share the similar proof with this one. However, we have slightly difference in terms of how we 
define <span class="math">\(E[Y_n]\)</span>. The note defines an indicator random variables <span class="math">\(Z_{n,i} = I\{I=i\}\)</span>, where <span class="math">\(I=i\)</span> means we pick <span class="math">\(i_{th}\)</span> element as our 
first element inserting into the empty tree. Since, we pick the first insertion element equally
likely, then <span class="math">\(P(I=i) = \frac{1}{n}\)</span>, and thus, <span class="math">\(E[Z_{n,i}] = \frac{1}{n}\)</span> by <span class="math">\(E[I_A] = P(A)\)</span>. Then, he defines <span class="math">\(Y_n = \sum_{i=1}^nZ_{n,i} \cdot (2 \cdot max(Y_{i-1}, Y_{n-i}))\)</span>
because only one <span class="math">\(Z_{n,i}\)</span> can be <span class="math">\(1\)</span> and all others are <span class="math">\(0\)</span>. It seems right but when he calculates the <span class="math">\(E[Y_n]\)</span>, he states that
<span class="math">\(Z_{n,i}\)</span> is independent of <span class="math">\(Y_{i-1}\)</span> and <span class="math">\(Y_{n-i}\)</span>. However, I don't think so as the height of the tree <span class="math">\(h_n\)</span>, which <span class="math">\(Y_n\)</span> is constructed from 
depends on which element we pick first. I tend to think about <span class="math">\(E[Y_n]\)</span> as expectation of the conditional expectation.</p>
</blockquote>
<script type="text/javascript">if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width < 768) ? "left" : align;
        indent = (screen.width < 768) ? "0em" : indent;
        linebreak = (screen.width < 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' && location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' }, Macros: {} }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
</script>
        </div><!-- /.entry-content -->
        <div class="comments">
        <h2>Comments !</h2>
            <div id="disqus_thread"></div>
            <script type="text/javascript">
               var disqus_identifier = "posts/2017/Jan/26/maw-chapter-4-tree-proof-questions/";
               (function() {
               var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
               dsq.src = 'https://zhu45-org.disqus.com/embed.js';
               (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
              })();
            </script>
        </div>

</article>
</section>

        <aside id="sidebar">
          <!-- <div class="widget" id="book" role="book">
<h2><i class="fa fa-book fa-lg"></i> MySQL 5.1 Plugins Development</h2>
<a href="https://www.packtpub.com/mysql-5-1-plugins-development/book"><img border="0" style="float:left" src="../../../../../theme/images/0608OS_MockupCover_sm.png" />
MySQL 5.1 Plugins Development by Andrew Hutchings and Sergei Golubchik is now available from Packt Publishing.</a>
<br style="clear:left;" />
</div> -->
<!--          <h2><i class="fa fa-twitter fa-lg"></i> Twitter Feed</h2>
<a class="twitter-timeline" data-width="280" data-height="300" href="https://twitter.com/zeyuanhu">Tweets by zeyuanhu</a> <script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>-->
                <div class="widget">
                        <h2><i class="fa fa-home fa-lg"></i> Categories</h2>
                        <ul>
                           <li class="active"><a href="../../../../../category/data-struct-and-algo-analysis-in-c.html"><i class="fa fa-folder-open fa-lg"></i> Data Struct and Algo Analysis in C (12)</a></li>
                           <li ><a href="../../../../../category/misc.html"><i class="fa fa-folder-open fa-lg"></i> misc (3)</a></li>
                           <li ><a href="../../../../../category/programming-languages.html"><i class="fa fa-folder-open fa-lg"></i> programming languages (5)</a></li>
                           <li ><a href="../../../../../category/tools.html"><i class="fa fa-folder-open fa-lg"></i> tools (5)</a></li>
                        </ul>
                </div>
                <div class="widget social">
                        <h2><i class="fa fa-comments fa-lg"></i> Social</h2>
                        <ul>
                            <!-- <li><a href="../../../../../None" rel="alternate"><i class="fa fa-rss-square fa-lg"></i> RSS feed</a></li> -->
                            <!--  -->

                            <li><a href="http://github.com/xxks-kkk"><i class="fa fa-github fa-lg"></i> GitHub</a></li>
                            <li><a href="http://stackoverflow.com/users/1460102/jerry"><i class="fa fa-stack-overflow fa-lg"></i> Stack Overflow</a></li>
                            <li><a href="http://zeyuanhu.wordpress.com/"><i class="fa fa-wordpress fa-lg"></i> WordPress</a></li>
                            <li><a href="https://cn.linkedin.com/in/zhu45"><i class="fa fa-linkedin fa-lg"></i> LinkedIn</a></li>
                        </ul>
                </div><!-- /.social -->
            <div class="widget tags">
            <h2><i class="fa fa-tags fa-lg"></i>Tags</h2>
                <ul class="list-group list-inline tagcloud" id="tags">
                    <li class="list-group-item tag-4">
                        <a href="../../../../../tag/aix.html">
                            AIX
                        </a>
                    </li>
                    <li class="list-group-item tag-1">
                        <a href="../../../../../tag/c.html">
                            c
                        </a>
                    </li>
                    <li class="list-group-item tag-4">
                        <a href="../../../../../tag/call-stack.html">
                            call-stack
                        </a>
                    </li>
                    <li class="list-group-item tag-4">
                        <a href="../../../../../tag/circular-double-linked-list.html">
                            circular-double-linked-list
                        </a>
                    </li>
                    <li class="list-group-item tag-4">
                        <a href="../../../../../tag/double-linked-list.html">
                            double-linked-list
                        </a>
                    </li>
                    <li class="list-group-item tag-4">
                        <a href="../../../../../tag/dynamic-programming.html">
                            dynamic-programming
                        </a>
                    </li>
                    <li class="list-group-item tag-4">
                        <a href="../../../../../tag/emacs.html">
                            emacs
                        </a>
                    </li>
                    <li class="list-group-item tag-4">
                        <a href="../../../../../tag/github.html">
                            github
                        </a>
                    </li>
                    <li class="list-group-item tag-4">
                        <a href="../../../../../tag/jinja.html">
                            Jinja
                        </a>
                    </li>
                    <li class="list-group-item tag-3">
                        <a href="../../../../../tag/math.html">
                            math
                        </a>
                    </li>
                    <li class="list-group-item tag-3">
                        <a href="../../../../../tag/meta.html">
                            meta
                        </a>
                    </li>
                    <li class="list-group-item tag-4">
                        <a href="../../../../../tag/pelican.html">
                            pelican
                        </a>
                    </li>
                    <li class="list-group-item tag-4">
                        <a href="../../../../../tag/pointer.html">
                            pointer
                        </a>
                    </li>
                    <li class="list-group-item tag-4">
                        <a href="../../../../../tag/proof.html">
                            proof
                        </a>
                    </li>
                    <li class="list-group-item tag-2">
                        <a href="../../../../../tag/recursion.html">
                            recursion
                        </a>
                    </li>
                    <li class="list-group-item tag-4">
                        <a href="../../../../../tag/sed.html">
                            sed
                        </a>
                    </li>
                    <li class="list-group-item tag-2">
                        <a href="../../../../../tag/shell.html">
                            shell
                        </a>
                    </li>
                    <li class="list-group-item tag-1">
                        <a href="../../../../../tag/singly-linked-list.html">
                            singly-linked-list
                        </a>
                    </li>
                    <li class="list-group-item tag-2">
                        <a href="../../../../../tag/software-engineering.html">
                            software-engineering
                        </a>
                    </li>
                    <li class="list-group-item tag-4">
                        <a href="../../../../../tag/travis-ci.html">
                            travis-ci
                        </a>
                    </li>
                    <li class="list-group-item tag-2">
                        <a href="../../../../../tag/trees.html">
                            trees
                        </a>
                    </li>
                </ul>
            </div>
        </aside><!-- /#sidebar -->

        <!-- <footer id="footer" class="body"> -->
        <!--         <address id="about" class="vcard body"> -->
        <!--         Proudly powered by <a href="http://alexis.notmyidea.org/pelican/">pelican</a>, which takes great advantages of <a href="http://python.org">python</a>. -->
        <!--         </address><\!-- /#about -\-> -->
        <!--         <p>The LinuxJedi logo and the content of this blog is licensed under a <a href="http://creativecommons.org/licenses/by-sa/3.0/deed.en_GB">Creative Commons Attribution-ShareAlike 3.0 Unported License</a>.</p> -->
        <!-- </footer><\!-- /#footer -\-> -->

    <script type="text/javascript">
    var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
    document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
    </script>
    <script type="text/javascript">
    try {
        var pageTracker = _gat._getTracker("UA-37565522-2");
    pageTracker._trackPageview();
    } catch(err) {}</script>
</body>
</html>