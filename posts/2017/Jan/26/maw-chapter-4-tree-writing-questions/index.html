<!DOCTYPE html>
<!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js"> <!--<![endif]-->
    <head>
        <meta charset="utf-8">
        <title>    MAW Chapter 4: Tree writing questions
</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta content="This is the homepage of Zeyuan (Zack) Hu" name="description">
        <meta content="Zeyuan Hu, Zeyuan, Zack Hu, zack, zeyuan hu, zeyuan ibm, IBM, Zeyuan IBM, UW Madison, University of Wisconsin Madison, zeyuan wisc, zeyuan IBM, zeyuan federation" name="keywords">
        <meta content="Zeyuan Hu" name="author">
        <link href='https://fonts.googleapis.com/css?family=Gentium+Book+Basic|Merriweather:400,300' rel='stylesheet' type='text/css'>
        <link rel="stylesheet" href="../../../../../theme/css/cid.css">
        <!-- add font-awesome -->
        <script defer src="../../../../../theme/fa-5/svg-with-js/js/fontawesome-all.js"></script>
        <link rel="stylesheet" href="../../../../../theme/academicons/css/academicons.css"/>
        <link href="https://zhu45.org/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="Fluffy Stuff Atom Feed" />
        <link href="https://zhu45.org/feeds/all.rss.xml" type="application/rss+xml" rel="alternate" title="Fluffy Stuff RSS Feed" />
        <link href="../../../../../theme/images/favicon.ico" rel="icon">
    </head>
    <body>
        <!--[if lt IE 7]>
            <p class="chromeframe">You are using an <strong>outdated</strong> browser. Please <a href="http://browsehappy.com/">upgrade your browser</a> or <a href="http://www.google.com/chromeframe/?redirect=true">activate Google Chrome Frame</a> to improve your experience.</p>
        <![endif]-->
            <div class="container">
<header class="blog-header">
    <h1 id="site-title"><a href="../../../../..">Fluffy Stuff</a></h1>
    <p> A tmp place to rest </p>
    <nav>
        <!--<a href="../../../../../zeyuan-hus-resume.html" style="padding: 10px">RESUME</a>-->
        <!-- <a href="../../../../../archives" style="padding: 10px">ARCHIVES</a> -->
            <a href="../../../../../courses.html" style="padding: 10px">COURSES</a>
            <a href="../../../../../blog2" style="padding: 10px">BLOG</a>
            <a href="../../../../../projects.html" style="padding: 10px">PROJECTS</a>
            <a href="../../../../../links.html" style="padding: 10px">LINKS</a>
    </nav>
</header>
    <div class="post">
        <header>
            <h1 class="post-title">MAW Chapter 4: Tree writing questions</h1>
            <div class="panel">
                <div class="panel-body">
<footer class="post-info">
    <span class="label label-default">Date</span>
    <span class="published">
        <i class="fa fa-calendar"></i><time datetime="2017-01-26T17:41:00+08:00"> Jan 26, 2017</time>
    </span>





<span class="label label-default">Tags</span>
	<a href="../../../../../tag/trees.html">trees</a>
        /
	<a href="../../../../../tag/proof.html">proof</a>
        /
	<a href="../../../../../tag/math.html">math</a>
        /
	<a href="../../../../../tag/maw.html">maw</a>
    
</footer><!-- /.post-info -->                </div>
            </div>
        </header>
        
        <article>
            <html><body><p>There are a lot of writing questions in Chapter 4. Some questions offer
great insights on the general techniques in solving algorithmatic proving questions.
So, I decide to record them in this single post. Of course, this post will be continually
updated as I work through the chapter.</p>
<h2 id="insights">Insights</h2>
<ul>
<li>Recursive tree definition is a natural fit with induction (i.e., MAW 4.5, 4.6, 4.7).</li>
<li>Usually there are two ways to prove a problem in tree, one direction is from induction
  and the other one is from basic tree property (i.e., MAW 4.4, 4.6).</li>
<li>Combinatorics (relating to binomials) and Probability theory (discrete part) are important to look at (i.e., MAW 4.14)</li>
<li>We can usually study some specific examples, and try to generalize them to form induction proof. 
  In addition, always remember we want to convert the problem for <span class="math">\(n+1\)</span> into the same problem but 
  with the inductive step on <span class="math">\(n\)</span>. (MAW 4.17)</li>
</ul>
<h2 id="solutions">Solutions</h2>
<p>including: MAW 4.4, 4.5, 4.6, 4.7, 4.14, 4.15, 4.16, 4.17, 4.23, 4.24, 4.25, 4.26.a, 4.43</p>
<h3 id="maw-44">MAW 4.4</h3>
<blockquote>
<p>Show that in a binary tree of <span class="math">\(N\)</span> nodes, there are <span class="math">\(N + 1\)</span> <code>NULL</code> pointers
representing children.</p>
</blockquote>
<p><strong>Proof:</strong>
For a binary tree with <span class="math">\(N\)</span> nodes, there are two types of edges (pointers): </p>
<ol>
<li>edges that are doesn't exist (<code>NULL</code> pointers).</li>
<li>edges that exist to connect nodes (not <code>NULL</code> pointers).</li>
</ol>
<p>Let's first calculate the number of pointers in total, regardless whether the pointer
is <code>NULL</code> or not. Since each node has <span class="math">\(2\)</span> outgoing pointers, 
there are <span class="math">\(2N\)</span> pointers in total. Next, we need to calculate the number of edges that actuall
exist. Since each edge connects some node to its parent, and every node except 
the root has one parent. In other words, each node, except the root node, has one incoming
pointer from its parent. So, we have <span class="math">\(N-1\)</span> edges existing. Thus the remaining
<span class="math">\(2N - (N-1) = N+1\)</span> edges are actually non-existing. Thus, we have <span class="math">\(N+1\)</span> <code>NULL</code> pointers.</p>
<h3 id="maw-45">MAW 4.5</h3>
<blockquote>
<p>Show that the maximum number of nodes in a binary tree of height <span class="math">\(H\)</span> is <span class="math">\(2^{H+1}-1\)</span>.</p>
</blockquote>
<p><strong>Proof:</strong> 
Let's prove this by induction.</p>
<p><em>Base case:</em> <span class="math">\(H = 0\)</span>. A binary tree of height <span class="math">\(0\)</span> has only one node, root. <span class="math">\(2^{H+1}-1\)</span> equals
one for <span class="math">\(H = 0\)</span>. Therefore ture for <span class="math">\(H = 0\)</span>.</p>
<p><em>Inductive Hypothesis:</em> Assume that the maximum number of nodes in a binary tree of height <span class="math">\(H\)</span> is
<span class="math">\(2^{H+1}-1\)</span> for <span class="math">\(H = 1, 2, ..., k\)</span>. Consider a tree <span class="math">\(T\)</span> of height <span class="math">\(k+1\)</span>. The root of <span class="math">\(T\)</span> has 
a left subtree and a right subtree each of which has height at most <span class="math">\(k\)</span>. These can have
at most <span class="math">\(2^{k+1}-1\)</span> nodes each by the inductive hypothesis. Adding the root node gives the 
maximum number of nodes in a binary tree of height <span class="math">\(k+1\)</span>, </p>
<div class="math">$$
\begin{equation} 
2(2^{k+1} - 1) + 1 = 2^{(k+1)+1} - 1 
\end{equation}
$$</div>
<p>Remarks:</p>
<p>The maximum condition achieves when we have <em>perfect binary tree</em>.</p>
<div class="math">$$
\begin{equation}
n = \sum_{i=0}^{h} 2^i = 2^{h+1} - 1 \text{where n is the number of nodes} 
\end{equation}
$$</div>
<h3 id="maw-46">MAW 4.6</h3>
<blockquote>
<p>A <em>full node</em> is a node with two children. Prove that the number of full nodes
plus one is equal to the number of leaves in a nonempty binary tree.</p>
</blockquote>
<p>Let's use two methods to prove this question.</p>
<p><em>Method 1:</em></p>
<p><strong>Proof:</strong>
Let's use the following notation for our proof:</p>
<div class="math">$$
\begin{eqnarray*}
N &amp; = &amp; \text{number of nodes in a nonempty binary tree} \\
F &amp; = &amp; \text{number of full nodes} \\
H &amp; = &amp; \text{number of nodes with one child} \\
L &amp; = &amp; \text{number of leaves}
\end{eqnarray*}
$$</div>
<p>Then, we have <span class="math">\(N = F + H + L \label{eq:1}\)</span>. We can get another equation based on the number of 
edges: <span class="math">\(N - 1 = 2F + H \label{eq:2}\)</span>. <span class="math">\(N-1\)</span> is the number of edges for a <span class="math">\(N\)</span> node binary tree 
and <span class="math">\(2F + H\)</span> is another way to calculate the number of edges. Now based on these 
two euqations we have:</p>
<div class="math">$$
\begin{eqnarray*}
2F + H + 1 &amp; = &amp; F + H + L \\
F + 1 &amp; = &amp; L
\end{eqnarray*}
$$</div>
<p><em>Method 2:</em></p>
<p><strong>Proof:</strong>
Let's prove by induction. If there are <span class="math">\(N\)</span> full nodes in a non-empty binary tree
then there are <span class="math">\(N+1\)</span> leaves.</p>
<p><em>Base case:</em> <span class="math">\(N = 0\)</span> This is ture because the tree has one node and the root is 
a leaf.</p>
<p><em>Inductive hypothesis:</em> Suppose the theorem holds for <span class="math">\(N = 1, 2, ..., k\)</span>. Then we 
want to show that if there are <span class="math">\(k+1\)</span> full nodes in a non-empty binary tree then there 
are <span class="math">\(k+2\)</span> leaves. Pick a leaf node and keep removing its parent recursively 
(i.e., remove its parent and then parent's parent and so on) until a full node
is reached. That is, you are traversing from a leaf along the path towards the root,
while removing the nodes along the path before a full node is reached. This full node
becomes a non-full node because one of its child node is removed. At this point the
tree will have one less leaf and one less full node.</p>
<p><img alt="" class="img-responsive" src="../../../../../images/maw-4-6.PNG"/></p>
<p>Therefore, the tree has <span class="math">\(k\)</span> full nodes after the nodes are removed. By the inductive
hypothesis there are <span class="math">\(k+1\)</span> leaves. Add all the nodes that were removed back into the 
tree the same way to create the original tree. We are adding one full node and 
one leaf node. Therefore, we have <span class="math">\(k+1\)</span> full nodes with <span class="math">\(k+2\)</span> leaves.</p>
<h3 id="maw-47">MAW 4.7</h3>
<blockquote>
<p>Suppose a binary tree has leaves <span class="math">\(l_{1}, l_{2}, ..., l_{M}\)</span> at depths
<span class="math">\(d_{1}, d_{2}, ...,d_{M}\)</span>, repectively. Prove that <span class="math">\(\sum_{i=1}^M 2^{-d_{i}} \leq 1\)</span>
and determine when the quality is true.</p>
</blockquote>
<p><strong>Proof:</strong>
Let's prove this by induction. </p>
<p><em>Base case:</em> when <span class="math">\(M = 1\)</span>, there is one node: the root is a leaf wit depth zero. Then
the sum is one, and claim holds.</p>
<p><em>Inductive hypothesis:</em> Suppose the theorem is true for all trees with at most <span class="math">\(k\)</span> nodes.
Consider any tree with <span class="math">\(k+1\)</span> nodes. Such a tree consists of an <span class="math">\(i\)</span> node left subtree and 
a <span class="math">\(k-i\)</span> node right subtree. By the inductive hypothesis, the sum for the left subtree
leaves is at most one with respect to the left tree root. Because all leaves are one deeper
with respect to the original tree than with respect to the subtree, the sum is at
most <span class="math">\(1/2\)</span> with respect to the root. Similar logic implies that the sum for leaves 
in the right subtree is at most <span class="math">\(1/2\)</span> proving the theorem.</p>
<p>The equality is true if and only if every internal node is a full node. In other words,
no nodes have one child. Suppose there is a node with one child, and the equality still
holds. Each time we remove two nodes to create a new tree that has a node with no child.
This new tree has the same property has the previous one, and by the statement we proved
above, we should have the same sum as the old, which is one. Eventually, we are left
with two node, one of them is root. Now, we calculate the sum, which gives <span class="math">\(1/2\)</span>. This 
is contradiction to the equality.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This problem is called 
<a href="https://en.wikipedia.org/wiki/Kraft%E2%80%93McMillan_inequality">Kraft–McMillan inequality</a>,
which is one of fundamental theorem in Information theory. I find 
<a href="https://www.youtube.com/playlist?list=PLE125425EC837021F">this youtube playlist about information theory</a>
is really good as an intro to the field because it doesn't make the material look 
very daunting and super technical,
which some 
<a href="http://circuit.ucsd.edu/~yhk/ece154c-spr16/pdfs/LectureNotes01.pdf">lecture note</a>
 manages to achieve.</p>
</div>
<h3 id="maw-414">MAW 4.14</h3>
<blockquote>
<p>Prove that the depth of a random binary search tree (depth of the deepest node) is <span class="math">\(O(\log N)\)</span>, on average.</p>
</blockquote>
<p>This question can be restated like the following: suppose that we insert <span class="math">\(n\)</span> distinct elements into an 
initially empty tree. Assuming that the <span class="math">\(n!\)</span> permutations are equally likely to occur, then show that
the average height of the tree is <span class="math">\(O(\log N)\)</span>.</p>
<p>Before we dive into the proof, let's think about how we can construct a random binary search tree.
We construct a tree <span class="math">\(T\)</span> by inserting in order randomly selected <span class="math">\(n\)</span> distinct elements into an 
initially empty tree. Here the actual values of the elements do not matter. What matters is the position
of the inserted element in the <span class="math">\(n\)</span> elements. Thus, we construct a random binary search tree as the following:</p>
<p>An element <span class="math">\(i\)</span> from the <span class="math">\(n\)</span> elements is selected uniformly ar random and is inserted to the empty tree. Then all 
the other elements are inserted. Here all the elements greater than <span class="math">\(i\)</span> go into the right subtree of <span class="math">\(i\)</span>
and all the elements smaller than <span class="math">\(i\)</span> go into the left subtree. Thus, the height of the tree constructed
is one plus the larger of the height of the left subtree and the height of the right subtree.</p>
<p><strong>Proof:</strong>
Following our construction process above, if we randomly choose the <span class="math">\(i^{th}\)</span> key, the left
subtree has <span class="math">\(i-1\)</span> elements and the right subtree has <span class="math">\(n-i\)</span> elements. Let <span class="math">\(h_{n}\)</span> be the
height of a randomly built binary search tree on <span class="math">\(n\)</span> keys. Then we have</p>
<div class="math">$$
\begin{equation} 
h_{n} = 1 + max(h_{i-1}, h_{n-i}) \label{eqn:1}
\end{equation}
$$</div>
<p>Now, let's define <span class="math">\(Y_{n} = 2^{h_n}\)</span>. If we can show 
that <span class="math">\(E[Y_n]\)</span> is polynomial in <span class="math">\(n\)</span>, we then have <span class="math">\(E[h_n] = O(\log n)\)</span>. Again, <span class="math">\(Y_n\)</span> 
depends on <span class="math">\(i\)</span> not <span class="math">\(n\)</span>. Let's represent \ref{eqn:1} in terms of <span class="math">\(Y_n\)</span>:</p>
<div class="math">$$
\begin{eqnarray*}
h_{n} &amp;=&amp; 1 + max(h_{i-1}, h_{n-i}) \\
2^{h_n} &amp;=&amp; 2^{1 + max(h_{i-1}, h_{n-i})} \\
        &amp;=&amp; 2 \cdot 2^{max(h_{i-1}, h_{n-i})} \\
        &amp;=&amp; 2 \cdot max(2^{h_{i-1}}, 2^{h_{n-i}}) \\
Y_n     &amp;=&amp; 2 \cdot max(Y_{i-1}, Y_{n-i}) 
\end{eqnarray*}
$$</div>
<p>Now, let's calculate <span class="math">\(E[Y_n]\)</span>. Here, <span class="math">\(I=i\)</span> means we pick <span class="math">\(i_{th}\)</span> element as our 
first element inserting into the empty tree.Since, we pick the first insertion element equally
likely, then <span class="math">\(P(I=i) = \frac{1}{n}\)</span>.</p>
<div class="math">$$
\begin{eqnarray*}
E[Y_n] &amp;=&amp; \sum_{i=1}^n E[Y_n|I=i]P(I=i) \\
       &amp;=&amp; \sum_{i=1}^n E[Y_n|I=i]\frac{1}{n} \\
       &amp;=&amp; \frac{2}{n}\sum_{i=1}^n E[max(Y_{i-1},Y_{n-i})] \\
       &amp;\le&amp; \frac{2}{n}\sum_{i=1}^n (E[Y_{i-1}] + E[Y_{n-i}])
\end{eqnarray*}
$$</div>
<p>Now we expand the last summation as</p>
<div class="math">$$
\begin{equation*}
(E[Y_0] + E[Y_{n-1}]) + \dots + (E[Y_{n-1}] + E[Y_0]) = 2\sum_{i=0}^{n-1}E[Y_i]
\end{equation*}
$$</div>
<p>Thus, we have</p>
<div class="math">$$
\begin{equation*}
E[Y_n] \le \frac{4}{n}\sum_{i=0}^{n-1}E[Y_i]
\end{equation*}
$$</div>
<p>Then, we will show that for all integers <span class="math">\(n&gt;0\)</span>, </p>
<div class="math">$$
\begin{eqnarray*}
E[Y_n] &amp;\le&amp; \frac{1}{4}\dbinom{n+3}{3} \\
       &amp;=&amp; \frac{1}{4}\cdot\frac{(n+3)(n+2)(n+1)}{6} \\ 
       &amp;=&amp; O(n^3)
\end{eqnarray*}
$$</div>
<p>Then, we use <em>Jensen's inequality</em>, which states that <span class="math">\(f(E[X]) \le E[f(X)]\)</span> provided
the expectations exist and are finite, and f(x) is convex. Let this <span class="math">\(X\)</span> be <span class="math">\(h_n\)</span> and
<span class="math">\(f(x) = 2^x\)</span>, then <span class="math">\(E[f(X)] = E[Y_n]\)</span>. So, we have</p>
<div class="math">$$
\begin{equation*}
2^{E[h_n]} \le \frac{1}{4}\dbinom{n+3}{3} = O(n^3)
\end{equation*}
$$</div>
<p>By taking the log of both sides, we have <span class="math">\(E[h_n] = O(\log n)\)</span></p>
<p><strong>Remarks:</strong></p>
<ul>
<li>Let's first prove <span class="math">\(\sum_{i=0}^{n-1}\dbinom{i+3}{3} = \dbinom{n+3}{4}\)</span></li>
</ul>
<p><strong>Proof:</strong> Use <em>Pascal's identity:</em> <span class="math">\(\dbinom{n}{k} = \dbinom{n-1}{k-1} + \dbinom{n-1}{k}\)</span>
Also using the simple identity <span class="math">\(\dbinom{4}{4} = 1 = \dbinom{3}{3}\)</span>. We have:</p>
<div class="math">$$
\begin{eqnarray*}
\dbinom{n+3}{4} &amp;=&amp; \dbinom{n+2}{3} + \dbinom{n+2}{4} \\
                &amp;=&amp; \dbinom{n+2}{3} + \dbinom{n+1}{3} + \dbinom{n+1}{4} \\
                &amp;=&amp; \dbinom{n+2}{3} + \dbinom{n+!}{3} + \dbinom{n}{3} + \dbinom{n}{4} \\
                &amp;\vdots&amp; \\
                &amp;=&amp; \dbinom{n+2}{3} + \dbinom{n+!}{3} + \dbinom{n}{3} + \dots + \dbinom{4}{3} + \dbinom{4}{4} \\
                &amp;=&amp; \sum_{i=0}^{n-1}\dbinom{i+3}{3}
\end{eqnarray*}
$$</div>
<ul>
<li>Let's prove <span class="math">\(E[Y_n] \le \frac{1}{4}\dbinom{n+3}{3}\)</span> by induction.</li>
</ul>
<p><strong>Proof:</strong> <em>Base case:</em> <span class="math">\(n=1\)</span>. </p>
<div class="math">$$
\begin{equation*}
1 = Y_1 = E[Y_1] \le \frac{1}{4}\dbinom{1+3}{3} = 1.
\end{equation*}
$$</div>
<p><em>Inductive hypothesis:</em> Assume that <span class="math">\(E[Y_i]\le\frac{1}{4}\dbinom{i+3}{3}\)</span> for all <span class="math">\(i&lt;n\)</span>. Then,</p>
<div class="math">$$
\begin{eqnarray*}
E[Y_n] &amp;\le&amp; \frac{4}{n}\sum_{i=0}^{n-1}E[Y_i] \\
       &amp;\le&amp; \frac{1}{4}\dbinom{i+3}{3} \\
       &amp;=&amp;   \frac{1}{n}\sum_{i=0}^{n-1}\dbinom{i+3}{3} \\
       &amp;=&amp;   \frac{1}{n}\dbinom{n+3}{4} \\
       &amp;=&amp;   \frac{1}{n}\frac{(n+3)!}{4!(n-1)!} \\
       &amp;=&amp;   \frac{1}{4}\frac{(n+3)!}{3!n!} \\
       &amp;=&amp;   \frac{1}{4}\dbinom{n+3}{3}
\end{eqnarray*}
$$</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>I 
<a href="https://www.cs.bgu.ac.il/~fds112/wiki.files/P05.pdf">reference this lecture note</a>
 when I try to develop the proof. 
Overall, I share the similar proof with this one. However, we have slightly 
difference in terms of how we 
define <span class="math">\(E[Y_n]\)</span>. The note defines an indicator random variables 
<span class="math">\(Z_{n,i} = I\{I=i\}\)</span>, where <span class="math">\(I=i\)</span> means we pick <span class="math">\(i_{th}\)</span> element as our 
first element inserting into the empty tree. Since, we pick the first insertion 
element equally likely, then <span class="math">\(P(I=i) = \frac{1}{n}\)</span>, and thus, <span class="math">\(E[Z_{n,i}] = \frac{1}{n}\)</span> by <span class="math">\(E[I_A] = P(A)\)</span>. Then, he defines <span class="math">\(Y_n = \sum_{i=1}^nZ_{n,i} \cdot (2 \cdot max(Y_{i-1}, Y_{n-i}))\)</span> because only one <span class="math">\(Z_{n,i}\)</span> can be <span class="math">\(1\)</span> and all others are <span class="math">\(0\)</span>. It seems right but when he calculates the <span class="math">\(E[Y_n]\)</span>, he states that
<span class="math">\(Z_{n,i}\)</span> is independent of <span class="math">\(Y_{i-1}\)</span> and <span class="math">\(Y_{n-i}\)</span>. However, I don't think so as 
the height of the tree <span class="math">\(h_n\)</span>, which <span class="math">\(Y_n\)</span> is constructed from 
depends on which element we pick first. I tend to think about <span class="math">\(E[Y_n]\)</span> as 
expectation of the conditional expectation.</p>
</div>
<h3 id="maw-415">MAW 4.15</h3>
<blockquote>
<p>a. Give a precise expression for the minimum number of nodes in an AVL tree of height <span class="math">\(H\)</span>.
b. What is the minimum number of nodes in an AVL tree of height 15? </p>
</blockquote>
<p>The minimum number of nodes in an AVL tree of height <span class="math">\(H\)</span>, <span class="math">\(S(H) = S(H-1) + S(H-2) + 1 \quad (H \ge 2)\)</span> with <span class="math">\(S(0) = 1\)</span> and <span class="math">\(S(1) = 2\)</span>.
It's a linear nonhomogeneous recurrence relation with constant coefficients. Let's first find 
out the general solution for corresponding homogeneous recurrence relation <span class="math">\(S(H) = S(H-1) + S(H-2)\)</span> first.
The characteristic equation is <span class="math">\(x^2 - x - 1 = 0\)</span> and the roots are <span class="math">\(\frac{1+\sqrt 5}{2}\)</span> and <span class="math">\(\frac{1-\sqrt 5}{2}\)</span>.
So, we have <span class="math">\(S(H) = c_1\Big(\frac{1+\sqrt 5}{2}\Big)^H + c_2\Big(\frac{1-\sqrt 5}{2}\Big)^H\)</span>.</p>
<p>Now, for a particular solution to the recurrence relation, let's guess <span class="math">\(S(H) = r \quad \text{for some constant } r\)</span>.
This solution has to satisfy the recurrence relation as well. Thus, </p>
<div class="math">$$
\begin{equation*}
r = r + r + 1
\end{equation*}
$$</div>
<p>So, we have <span class="math">\(r = -1\)</span>. Thus, <span class="math">\(S(H) = c_1\Big(\frac{1+\sqrt 5}{2}\Big)^H + c_2\Big(\frac{1-\sqrt 5}{2}\Big)^H - 1\)</span>. We plugin
the initial condition to our general solution to solve for <span class="math">\(c_1\)</span> and <span class="math">\(c_2\)</span>. We get <span class="math">\(c_1 = 1 + \frac{2}{\sqrt 5}\)</span>
and <span class="math">\(c_2 = 1 - \frac{2}{\sqrt 5}\)</span>. Thus, we have </p>
<div class="math">$$
\begin{equation}
S(H) = \Big(1 + \frac{2}{\sqrt 5}\Big)\Big(\frac{1+\sqrt 5}{2}\Big)^H + \Big(1 - \frac{2}{\sqrt 5}\Big)\Big(\frac{1-\sqrt 5}{2}\Big)^H - 1 \label{eqn:2}
\end{equation}
$$</div>
<p>Now, let <span class="math">\(H = 15\)</span> and we have <span class="math">\(S(15) = 2583\)</span>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Initial condition is for the general solution for the recurrence relation, not 
the homogeneous part. Thus, we cannot use the initial condition immediately when 
we have our homogeneous part done.We need to wait until the whole solution 
(homogeneous part + particular part).</p>
</div>
<p><strong>Remarks:</strong></p>
<p>With \ref{eqn:2}, we can actually get the bound of the height of an AVL tree. </p>
<p>By \ref{eqn:2}, we see that <span class="math">\(S(H) \ge \Big(\frac{1+\sqrt 5}{2}\Big)^H\)</span>. Suppose we have <span class="math">\(N\)</span> nodes in an AVL 
tree of height <span class="math">\(H\)</span>. Then <span class="math">\(N \ge S(H) \ge \Big(\frac{1+\sqrt 5}{2}\Big)^H\)</span>. Let <span class="math">\(\phi = \frac{1+\sqrt 5}{2}\)</span>, then
we have <span class="math">\(\log _\phi N \ge H\)</span>, which is <span class="math">\(H \le 1.44\log _2 N = O(\log N)\)</span>.</p>
<h3 id="maw-416">MAW 4.16</h3>
<blockquote>
<p>Show the result of inserting 2,1,4,5,9,3,6,7 into an initially empty AVL tree.</p>
</blockquote>
<p><a href="https://github.com/xxks-kkk/Code-for-blog/blob/master/2017/graphviz-drawings/maw-4-16.gv">
<img alt="maw-4-16" class="img-responsive" src="/images/maw-4-16.png" style="width: 700px;"/>
</a></p>
<!--[![maw-4-16](/images/maw-4-16.png)](https://github.com/xxks-kkk/Code-for-blog/blob/master/2017/graphviz-drawings/maw-4-16.gv)-->
<h3 id="maw-417">MAW 4.17</h3>
<blockquote>
<p>Keys <span class="math">\(1, 2, \dots, 2^k-1\)</span> are inserted in order into an initially empty AVL tree. Prove that the resulting tree
is perfectly balanced <sup id="fnref:1"><a class="footnote-ref" href="#fn:1" rel="footnote">1</a></sup>.</p>
</blockquote>
<p><strong>Proof:</strong>
Let's use induction on <span class="math">\(k\)</span> to prove the following statement:</p>
<p>The result of inserting any increasing sequence of <span class="math">\(2^k - 1\)</span> numbers into an 
  initially empty AVL tree results in a perfectly balanced tree of height 
  <span class="math">\(k-1\)</span>.</p>
<p><em>Base case:</em> <span class="math">\(k = 1\)</span>. Tree has only one node. This is clearly perfectly balanced.
<em>Inductive hypothesis:</em> Assume hypothesis is true for <span class="math">\(k = 1, 2, \dots, h\)</span>. We want to prove that it is true for <span class="math">\(k = h + 1\)</span>, i.e., 
for sequence <span class="math">\(1, 2, \dots, 2^{h+1}-1\)</span>.</p>
<p>After the first <span class="math">\(2^h - 1\)</span> insertions, by the induction hypothesis, the tree is perfectly balanced, with height <span class="math">\(h-1\)</span>. <span class="math">\(2^{h-1}\)</span> is at the root
(can be observed for <span class="math">\(1 \ge k \le 3\)</span> situation, where the roots are <span class="math">\(1\)</span>, <span class="math">\(2\)</span>, <span class="math">\(4\)</span> respectively). The left subtree is a perfectly balanced
tree of height <span class="math">\(h-2\)</span>, and the right subtree is a perfectly balanced tree containing the numbers <span class="math">\(2^{h-1}+1\)</span> through <span class="math">\(2^h-1\)</span>, also of height <span class="math">\(h-2\)</span>.
See the following picture:</p>
<p><img alt="maw-4-17-1" class="img-responsive" src="/images/maw-4-17-1.PNG" style="height: 400px;"/></p>
<p>Each of the next <span class="math">\(2^{h-1}\)</span> insertions (<span class="math">\(2^h\)</span> through <span class="math">\(2^h + 2^{h-1} - 1\)</span>) are inserted into the 
right subtree, and the entire sequence of numbers in the right subtree (now <span class="math">\(2^{h-1}+1\)</span> through <span class="math">\(2^h + 2^{h-1}-1\)</span>)
were inserted in order and are a sequence of <span class="math">\(2^h - 1\)</span> nodes (i.e. <span class="math">\(2^h + 2^{h-1}-1 - (2^{h-1}+1) + 1 = 2^h -1\)</span>).
By induction hypothesis, they form a perfectly balanced tree of height <span class="math">\(h-1\)</span>. See the following picture:</p>
<p><img alt="maw-4-17-2" class="img-responsive" src="/images/maw-4-17-2.PNG" style="height: 400px;"/></p>
<p>The next insertion, of the number <span class="math">\(2^h + 2^{h-1}\)</span>, imbalances the tree at the root because now the height of the right subtree
is <span class="math">\(h\)</span> and the height of the left subtree is <span class="math">\(h-2\)</span>. Now, we do a single rotation and form a tree with root <span class="math">\(2^h\)</span>, and 
a perfectly balanced left subtree of height <span class="math">\(h-1\)</span>. The right subtree consists of a perfectly balanced tree 
(of height <span class="math">\(h-2\)</span>), with the new node: <span class="math">\(2^h + 2^{h-1}\)</span>. See the following picture:</p>
<p><img alt="maw-4-17-3" class="img-responsive" src="/images/maw-4-17-3.PNG" style="height: 400px;"/></p>
<p>Thus, the right subtree is as if the numbers <span class="math">\(2^h+1, \dots, 2^h + 2^{h-1}\)</span> had been 
inserted in order. We subsequently insert the numbers <span class="math">\(2^h + 2^{h-1} + 1\)</span> through
<span class="math">\(2^{h+1} - 1\)</span> nodes. In other words, we form the right subtree by inserting the 
numbers <span class="math">\(2^{h} + 1, \dots, 2^{h+1} - 1\)</span>, which have <span class="math">\(2^{h} - 1\)</span> numbers. Then, by
the inductive hypothesis, these <span class="math">\(2^{h} - 1\)</span> insertions form a perfectly balanced
subtree of height <span class="math">\(h-1\)</span>. See the following picture:</p>
<p><img alt="maw-4-17-4" class="img-responsive" src="/images/maw-4-17-4.PNG" style="height: 400px;"/></p>
<p>Since the left and right subtrees are perfectly balanced (height <span class="math">\(h-1\)</span>), the whole
tree is perfectly balanced.</p>
<h3 id="maw-423">MAW 4.23</h3>
<p><img alt="maw-4-23" class="img-responsive" src="/images/maw-4-23.JPG" style="width: 700px;"/></p>
<h3 id="maw-424">MAW 4.24</h3>
<p><img alt="maw-4-24" class="img-responsive" src="/images/maw-4-24.PNG" style="width: 700px;"/></p>
<h3 id="maw-425">MAW 4.25</h3>
<p>This problem is solved through brute-force calculation. You can reference the example
from figure 4.46 to figure 4.55. I calculate for internal path length of the 
tree and <code>find(1)</code>, <code>find(2)</code>. The answer is slightly off than the solution manual.
May need to double check.</p>
<p><img alt="maw-4-26" class="img-responsive" src="/images/maw-4-26.JPG" style="width: 700px; height: 400px;"/></p>
<h3 id="maw-426">MAW 4.26</h3>
<blockquote>
<p>a. Show that if all nodes in a splay tree are accessed in sequential order, 
the resulting tree consists of a chain of left children.</p>
</blockquote>
<p><strong>Proof:</strong>
Let's prove by induction. Let <span class="math">\(N\)</span> denote the number of nodes in a splay tree.</p>
<p><em>Base case:</em> When <span class="math">\(N = 1\)</span>, the claim holds.</p>
<p><em>Inductive hypothesis:</em> all nodes <span class="math">\(1, \dots, N\)</span> in a splay tree are accessed in sequential
order, the resulting tree consists of a chain of left children. We want to show that 
this holds for <span class="math">\(N+1\)</span>. Once we access first <span class="math">\(N\)</span> nodes, there are only one
position for <span class="math">\(N+1\)</span> node: the right child of the root. The rest of positions are impossible because if the 
<span class="math">\(N+1\)</span> node is the right child of any node between the left most node and the root of the resulting tree,
then by BST, <span class="math">\(N+1\)</span> node's value is smaller than root's value and bigger than left most node's value.
This violates the induction hypothesis because we are no longer access a splay tree in sequential order.
Now we simply swap the right child of the root with root and we get a chain of left children. </p>
<h3 id="maw-443">MAW 4.43</h3>
<blockquote>
<p>a. Show that via AVL single rotations, any binary search tree <span class="math">\(T_1\)</span> can be transformed into another
search tree <span class="math">\(T_2\)</span> (with the same keys).
b. Give an algorithm to perform this transformation using <span class="math">\(O(N\log N)\)</span> rotations on average.
c. Show that this transformation can be done with <span class="math">\(O(N)\)</span> rotations, worst-case.</p>
</blockquote>
<p>Let's first work through an example shown in the picture below. We transform the tree in the top-left 
of the picture to the tree in the top-right of the picture through several steps linked by single arrows.</p>
<p><img alt="maw-4-43" class="img-responsive" src="/images/maw-4-43.jpg" style="width: 700px;"/></p>
<p>As you can see, the strategy here is that we do preorder processing. We compare the root <span class="math">\(T_1\)</span> with the root
<span class="math">\(T_2\)</span>. If they are equal, then we move on to the left and right subtrees of <span class="math">\(T_1\)</span> and do the processing 
recursively. However, if they are not equal, we find the <span class="math">\(T_2\)</span>'s root value <span class="math">\(x\)</span> in <span class="math">\(T_1\)</span> and rotate it to the
root of <span class="math">\(T_1\)</span>. Then, we do the recursive processing for the left and right subtrees of <span class="math">\(T_1\)</span>. This algorithm
takes <span class="math">\(O(N\log N)\)</span> on average because find <span class="math">\(x\)</span> takes <span class="math">\(O(\log N)\)</span> time and AVL rotations also take <span class="math">\(O(\log N)\)</span> time. 
Since we could do <span class="math">\(N\)</span> rotations, then the result follows. However, a BST can be degenerated and in that case, we have 
<span class="math">\(O(N)\)</span> worst-case. </p>
<div class="footnote">
<hr/>
<ol>
<li id="fn:1">
<p>The solution and corresponding figures are majorly taken from 
<a href="https://cseweb.ucsd.edu/classes/su05/cse100/cse100hw1.pdf">this link</a>
with minor wording tweak to allow easy understanding for myself. <a class="footnote-backref" href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text">↩</a></p>
</li>
</ol>
</div>
<script type="text/javascript">if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width < 768) ? "left" : align;
        indent = (screen.width < 768) ? "0em" : indent;
        linebreak = (screen.width < 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
</script></body></html>
        </article>

<!--        <footer>
            <p>This entry is posted in <a href="../../../../../category/data-struct-algo.html">Data Struct & Algo</a>.</p>
        </footer>-->

<div class="comments">
    <div id="disqus_thread"></div>
    <script type="text/javascript">
        var disqus_shortname = 'zhu45-org';
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>

    </div>


<footer class="blog-footer">
    <p class="disclaimer">
        Zeyuan Hu &copy; 2015-2018.
    </p>
</footer>
            </div>
<script>
    var _gaq=[['_setAccount','UA-37565522-2'],['_trackPageview']];
    (function(d,t){var g=d.createElement(t),s=d.getElementsByTagName(t)[0];
    g.src=('https:'==location.protocol?'//ssl':'//www')+'.google-analytics.com/ga.js';
    s.parentNode.insertBefore(g,s)}(document,'script'));
</script>
    </body>
</html>