<!DOCTYPE html>
<!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js"> <!--<![endif]-->
    <head>
        <meta charset="utf-8">
        <title>    Understanding how function call works
</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta content="This is the homepage of Zeyuan (Zack) Hu" name="description">
        <meta content="Zeyuan Hu, Zeyuan, Zack Hu, zack, zeyuan hu, zeyuan ibm, IBM, Zeyuan IBM, UW Madison, University of Wisconsin Madison, zeyuan wisc, zeyuan IBM, zeyuan federation" name="keywords">
        <meta content="Zeyuan Hu" name="author">
        <link href='https://fonts.googleapis.com/css?family=Gentium+Book+Basic|Merriweather:400,300' rel='stylesheet' type='text/css'>
        <link rel="stylesheet" href="../../../../../theme/css/cid.css">
        <!-- add font-awesome -->
        <link rel="stylesheet" href="../../../../../theme/fa/css/font-awesome.min.css">
        <link href="http://zhu45.org/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="Fluffy Stuff Atom Feed" />
        <link href="http://zhu45.org/feeds/all.rss.xml" type="application/rss+xml" rel="alternate" title="Fluffy Stuff RSS Feed" />
        <link href="../../../../../theme/images/favicon.ico" rel="icon">
    </head>
    <body>
        <!--[if lt IE 7]>
            <p class="chromeframe">You are using an <strong>outdated</strong> browser. Please <a href="http://browsehappy.com/">upgrade your browser</a> or <a href="http://www.google.com/chromeframe/?redirect=true">activate Google Chrome Frame</a> to improve your experience.</p>
        <![endif]-->
            <div class="container">
<header class="blog-header">
    <h1 id="site-title"><a href="../../../../..">Fluffy Stuff</a></h1>
    <p> A tmp place to rest </p>
    <nav>
        <!--<a href="../../../../../zeyuan-hus-resume.html" style="padding: 10px">RESUME</a>-->
        <!-- <a href="../../../../../archives" style="padding: 10px">ARCHIVES</a> -->
            <a href="../../../../../blog2" style="padding: 10px">BLOG</a>
            <a href="../../../../../projects.html" style="padding: 10px">PROJECTS</a>
            <a href="../../../../../quotes.html" style="padding: 10px">QUOTES</a>
    </nav>
</header>
    <div class="post">
        <header>
            <h1 class="post-title">Understanding how function call works</h1>
            <div class="panel">
                <div class="panel-body">
<footer class="post-info">
    <span class="label label-default">Date</span>
    <span class="published">
        <i class="fa fa-calendar"></i><time datetime="2017-07-30T00:21:00+08:00"> Jul 30, 2017</time>
    </span>





<span class="label label-default">Tags</span>
	<a href="../../../../../tag/assembly-language.html">assembly language</a>
        /
	<a href="../../../../../tag/call-stack.html">call stack</a>
    
</footer><!-- /.post-info -->                </div>
            </div>
        </header>
        
        <article>
            <html><head></head><body><p>Understanding assembly language is crucial for system programming. Some nasty defects of the system
can only be solved by digging into the assembly level of the program. In this post, I'll revisit 
call stack concept as a way to understand how function call works under the cover of high-level language.
In addition, this post belongs to part of future work mentioned in <a href="../../../../../posts/2017/Jan/22/num-of-function-calls-in-recursive-fibonacci-routine/">my post back in January</a>.</p>
<div class="toc">
<ul>
<li><a href="#addressing-mode">Addressing mode</a></li>
<li><a href="#main-course">Main course</a><ul>
<li><a href="#some-terms">Some terms</a></li>
<li><a href="#stack">Stack</a><ul>
<li><a href="#calling-a-function">Calling a function</a></li>
<li><a href="#writing-a-function">Writing a function</a><ul>
<li><a href="#setup">Setup</a></li>
<li><a href="#using-the-stack-frame">Using the stack frame</a></li>
<li><a href="#cleanup">Cleanup</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#two-examples">Two examples</a></li>
</ul>
</li>
<li><a href="#future-works">Future works</a></li>
<li><a href="#links-to-resources">Links to resources</a></li>
</ul>
</div>
<h2 id="addressing-mode">Addressing mode</h2>
<p>Before we jump into the actual material. I want to briefly revisit the various ways for assembly language
accessing the data in memory (i.e., addressing mode). 
The following table is adapted from CSAPP (2nd edition):</p>
<table class=" table-striped table table-hover">
<thead>
<tr>
<th>Type</th>
<th>Form</th>
<th>Operand Value</th>
<th>Name</th>
</tr>
</thead>
<tbody>
<tr>
<td>Immediate</td>
<td><span class="math">\($Imm\)</span></td>
<td><span class="math">\(Imm\)</span></td>
<td>Immediate</td>
</tr>
<tr>
<td>Register</td>
<td><span class="math">\(E_a\)</span></td>
<td><span class="math">\(R[E_a]\)</span></td>
<td>Register addressing</td>
</tr>
<tr>
<td>Memory</td>
<td><span class="math">\(Imm\)</span></td>
<td><span class="math">\(M[Imm]\)</span></td>
<td>Direct addressing</td>
</tr>
<tr>
<td>Memory</td>
<td><span class="math">\((E_a)\)</span></td>
<td><span class="math">\(M[R[E_b]]\)</span></td>
<td>Indirect addressing</td>
</tr>
<tr>
<td>Memory</td>
<td><span class="math">\(Imm(E_b, E_i, s)\)</span></td>
<td><span class="math">\(M[Imm+R[E_b]+(R[E_i]\cdot s)]\)</span></td>
<td>Scaled indexed addressing <sup id="fnref:1"><a class="footnote-ref" href="#fn:1" rel="footnote">1</a></sup></td>
</tr>
</tbody>
</table>
<p>In the above table, </p>
<ul>
<li><span class="math">\(Imm\)</span> refers to a constant value, e.g. <span class="math">\(\mathtt{0x8048d8e}\)</span> or <span class="math">\(\mathtt{48}\)</span></li>
<li><span class="math">\(E_x\)</span> refers to a register, e.g. <span class="math">\(\mathtt{\%eax}\)</span></li>
<li><span class="math">\(R[E_x]\)</span> refers to the value stored in register <span class="math">\(E_x\)</span></li>
<li><span class="math">\(M[x]\)</span> refers to the value stored at memory address <span class="math">\(x\)</span></li>
</ul>
<h2 id="main-course">Main course</h2>
<p>Now, let's bring our main course onto the table: understanding how function works. I'll
first clear up some terms we will use during the explanation. Then, we'll take a look
at the stack and understand how it supports function calls. Lastly, we'll examine
two assembly programs and understand the whole picture of function calls.</p>
<h3 id="some-terms">Some terms</h3>
<p>Let's first consider what the key elements we need in order to form a function:</p>
<ul>
<li>
<p>function name</p>
<p>A function's name is a symbol that represents the address where the function's code starts. </p>
</li>
<li>
<p>function arguments</p>
<p>A function's arguments (aka. parameters) are the data items that are explicitly given to
the function for processing. For example, in mathematics, there is a <span class="math">\(\sin\)</span> function. If
you were to ask a computer to find the <span class="math">\(\sin (2)\)</span>, <span class="math">\(\sin\)</span> would be the function's name, 
and <span class="math">\(2\)</span> would be the argument (or parameter).</p>
</li>
<li>
<p>local variables</p>
<p>Local variables are data storage that a function uses while processing that
is thrown away when it returns. It's knid of like a scratch pad of paper.
Functions get a new piece of paper every time they are activated, and they have to throw
it away when they are finished processing. </p>
</li>
<li>
<p>return address</p>
<p>The return address is an "invisible" parameter in that it isn't directly used
during the function. The return address is a parameter which tells the function
where to resume executing after the function is completed. This is needed because
functions can be called to do processing from many different parts of our program,
and the function needs to be able to get back to wherever it was called from. 
In most programming languages, this parameter is passed automatically when the function
is called. In assembly language, the <code>call</code> instruction handles passing the return 
address for you, and <code>ret</code> handles using that address to return back to where
you called the function from.</p>
</li>
<li>
<p>return value</p>
<p>The return value is the main method of transferring data back to the main program. 
Most programming languages only allow a sinlge return value for function.</p>
</li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The way that the variables are stored and the parameters and return values
are transferred by the computer varies from language to language. This variance
is known as a language's <em>calling convention</em>, because it describes how functions
expect to get and receive data when they are called. In this post, I'll 
follow C programming language calling convention.</p>
</div>
<h3 id="stack">Stack</h3>
<p>Each computer program that runs uses a region of memory called the <strong>stack</strong> to enable functions to work
properly. Machine uses the stack to pass function arguments, to store return information, to save
registers for later restoration, and for local variables.
The portion of the stack allocated for a single function call is called a <strong>stack frame</strong>. In other words,
for each function call, new space (i.e., stack frame) is created on the stack. </p>
<p>The computer's stack lives at the very top addresses of memory. As the name suggests, stack is a stack
data structure with the "top" of the stack growing from the <a href="../../../../../images/heap.png">high value addresses towards low values addresses</a>. 
We use <span class="math">\(\mathtt{push \text{ } S}\)</span> to push the source onto stack, and we use
<span class="math">\(\mathtt{pop \text{ } D}\)</span> to remove the top value from the stack and place it into a destination
(i.e. a register or memory location). We use the stack register, <span class="math">\(\mathtt{\%esp}\)</span> as a pointer
to the top of the stack, which at the same time, is the top of topmost stack frame.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Pointer here means that the stack register contains an address in memory instead of a regular value.
Specifically, the stack register now contains the address, which has the top value of the stack 
in it. With this description, we can see that to access the value on the top of the stack without
removing it, we can do <code>(%esp)</code>, which is indirect addressing mode.</p>
</div>
<p>When we talk about function calls, what we really care about is the topmost stack frame because 
that's the memory region that is associated with our current function calls. CSAPP (2nd edition)
has a nice picture about what the whole stack looks like:</p>
<p><img alt="stack frame structure" class="img-responsive" src="../../../../../images/stack-frame-structure.png"/></p>
<p>If some texts (i.e. "Saved %ebp") or layout (i.e. the order of arguments) don't make sense to you,
don't worry. I'll talk about them immediately.</p>
<h4 id="calling-a-function">Calling a function</h4>
<p>Before executing a function, a program pushes all of the parameters for the function
onto the stack in the reverse order that they are documented. Then the program
issues a <code>call</code> instruction indicating which function it wishes to start. 
The <code>call</code> instruction does two things:</p>
<ol>
<li>First it pushes the address of the next instruction, which is the return address, onto
the stack.</li>
<li>Then, it modifies the instruction pointer <span class="math">\(\mathtt{\%eip}\)</span> to point to the start of the function.</li>
</ol>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When you call a function, you should assume that everything currently
in your registers will be wiped out. The only register that is guaranteed
to be left with the value it started with is <span class="math">\(\mathtt{\%ebp}\)</span> (why? see
"Writing a function" section below). Thus, if there are registers
you want to save before calling a function, you need to save them
by pushing them on the stack before pushing the function's parameters.</p>
</div>
<p>So, at the time the function starts, the stack looks like this:</p>
<div class="highlight"><pre><span></span>Argument N
...
Argument 2
Argument 1
Return address &lt;--- (%esp)
</pre></div>


<p>As noted previously, the stack pointer holds the address, which contains return address as its value.</p>
<h4 id="writing-a-function">Writing a function</h4>
<p>Writing a function in x86 assembly essentially contains of three parts: setup, using the stack frame to perform
task, cleanup. The setup and cleanup steps are the same acrossed all the function calls. All three steps
will be explained in details.</p>
<h5 id="setup">Setup</h5>
<p>During the setup, the following two instructions are carried out immediately:</p>
<div class="highlight"><pre><span></span><span class="nf">pushl</span> <span class="nv">%ebp</span>
<span class="nf">movl</span> <span class="nv">%esp</span> <span class="nv">%ebp</span>
</pre></div>


<p>The first instruction is to save the current base pointer register (aka frame pointer), <span class="math">\(\mathtt{\%ebp}\)</span>. 
The base pointer is a special register used for accessing function parameters and local 
variables.The stack frame is delimited by two pointers: <span class="math">\(\mathtt{\%ebp}\)</span> serves as the pointer pointing
to the bottom of the stack frame and <span class="math">\(\mathtt{\%esp}\)</span> serves as the pointer pointing to the 
top of the stack frame. As pointed out earlier, each function call has its own stack frame.
Once the current function (i.e. callee) is done, we need to resume the execution of the caller function. 
This means that we need to restore the caller's base pointer register <span class="math">\(\mathtt{\%ebp}\)</span> when
we are done with callee function. Thus, we need to save the current base pointer register, 
which is the caller's for the future caller stack frame restoration.</p>
<p>Once we are done with saving the caller's <span class="math">\(\mathtt{\%ebp}\)</span>, we can now setup current stack frame's
<span class="math">\(\mathtt{\%ebp}\)</span> by doing <code>movl %esp %ebp</code>. The reason for this is that we can now be 
able to access the function parameters that are pushed earlier onto the stack by caller function
as fixed indexes from the base pointer. We cannot use stack pointer directly for accessing
parameters because the stack pointer can move while the function is executing. </p>
<p>At this point, the stack looks like this:</p>
<div class="highlight"><pre><span></span>Argument N     &lt;--- N*4+4(%ebp)
... 
Argument 2     &lt;--- 16 (%ebp)
Argument 1     &lt;--- 12(%ebp)
Return address &lt;--- 4(%ebp)
Old %ebp       &lt;--- (%esp) and (%ebp)
</pre></div>


<h5 id="using-the-stack-frame">Using the stack frame</h5>
<p>Once we have performed the fix setup, we can now use the stack frame to:</p>
<ul>
<li>save registers</li>
</ul>
<p>We need to push all the callee-save registers by convention onto the stack. By convention,
registers <span class="math">\(\mathtt{\%eax}\)</span>, <span class="math">\(\mathtt{\%edx}\)</span>, <span class="math">\(\mathtt{\%ecx}\)</span> are classified as caller-save 
registers, and <span class="math">\(\mathtt{\%ebx}\)</span>, <span class="math">\(\mathtt{\%esi}\)</span>, and <span class="math">\(\mathtt{\%edi}\)</span> are classified as callee-save
registers. The caller-save registers mean that the caller function is responsible saving these
register values because the callee is free to override these register values. On the other hand,
the callee-save registers mean that the callee function must save those registers values by pushing
them onto the stack before overwritting them, and restore them before the returning because the
caller may need these values for its future computations. </p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Save registers step is not mandatory. If your caller function (or higher-level functions)
don't use all these callee-save registers, you are free to skip this step.</p>
</div>
<ul>
<li>local variables</li>
</ul>
<p>The function reserves space on the stack for any local variables it needs. Space for data with
no specified initial value can be allocated on the stack by simply decrementing the stack pointer
by an appropriate amount. Similarly, space can be deallocated by incrementing pointer. Suppose
we are going to need two words of memory to run a function. We can simply move the stack pointer
down two words to serve the space:</p>
<div class="highlight"><pre><span></span><span class="nf">subl</span> <span class="no">$8</span><span class="p">,</span> <span class="nv">%esp</span>  <span class="c"># Allocate 8 bytes of space on the stack</span>
</pre></div>


<p>While it is possible to make space on the stack as needed in a function body, it is generally
more efficient to allocate this space all at once at the beginning of the function. This way,
we are free of worring about clobbering them with pushes that we may make for next function calls
(i.e. push arguments and return address for the function calls contained inside the current
function, which all happens in "Argument build area" in the above picture).</p>
<p>Suppose we save <span class="math">\(\mathtt{\%ebx}\)</span> (i.e. callee-save register),
and with our two words for local storage, our stack now looks like this:</p>
<div class="highlight"><pre><span></span><span class="n">Argument</span> <span class="n">N</span>      <span class="o">&lt;---</span> <span class="n">N</span><span class="o">*</span><span class="mi">4</span><span class="o">+</span><span class="mi">4</span><span class="p">(</span><span class="nf">%ebp</span><span class="p">)</span>
<span class="p">...</span> 
<span class="n">Argument</span> <span class="mi">2</span>      <span class="o">&lt;---</span> <span class="mi">12</span> <span class="p">(</span><span class="nf">%ebp</span><span class="p">)</span>
<span class="n">Argument</span> <span class="mi">1</span>      <span class="o">&lt;---</span> <span class="mi">8</span><span class="p">(</span><span class="nf">%ebp</span><span class="p">)</span>
<span class="n">Return</span> <span class="n">address</span>  <span class="o">&lt;---</span> <span class="mi">4</span><span class="p">(</span><span class="nf">%ebp</span><span class="p">)</span>
<span class="n">Old</span> <span class="nf">%ebp</span>        <span class="o">&lt;---</span> <span class="p">(</span><span class="nf">%esp</span><span class="p">)</span> <span class="n">and</span> <span class="p">(</span><span class="nf">%ebp</span><span class="p">)</span>
<span class="nf">%ebx</span>            <span class="o">&lt;---</span> <span class="o">-</span><span class="mi">4</span><span class="p">(</span><span class="nf">%ebp</span><span class="p">)</span>
<span class="n">Local</span> <span class="n">variable1</span> <span class="o">&lt;---</span> <span class="o">-</span><span class="mi">8</span><span class="p">(</span><span class="nf">%ebp</span><span class="p">)</span>
<span class="n">Local</span> <span class="n">variable2</span> <span class="o">&lt;---</span> <span class="o">-</span><span class="mi">12</span><span class="p">(</span><span class="nf">%ebp</span><span class="p">)</span> <span class="n">and</span> <span class="p">(</span><span class="nf">%esp</span><span class="p">)</span>
</pre></div>


<p>As you can see, we can now access all of the data we need for this function by
using base pointer addressing using different offsets from <span class="math">\(\mathtt{\%ebp}\)</span>.
<span class="math">\(\mathtt{\%ebp}\)</span> was made specifically for this purpose, which is why it is
called the base pointer. </p>
<h5 id="cleanup">Cleanup</h5>
<p>When a function is done executing, it does the following three things:</p>
<ol>
<li>It stores its return value in <span class="math">\(\mathtt{\%eax}\)</span></li>
<li>It frees the stack space it allocated by adding the same amount to the stack pointer <code>addl $8 %esp</code></li>
<li>It pops off the registers it saved earlier <code>popl %ebx</code></li>
<li>It resets the stack to what it was when it was called (it gets rid of the current stack frame
and puts the stack frame of the caller back into effect)</li>
<li>It returns control back to wherever it was called from. This is done using the <code>ret</code> instruction,
which pops whatever value is at the top of the stack, and sets the instruction pointer %\mathtt{\%eip}$
to that value.</li>
</ol>
<p>The reason we have to restore the caller's base pointer register before calling <code>ret</code> is due to the
structure of our current stack frame: in our current stack frame, the return address is not
at the top of the stack. Therefore, before we return, we have to rest the stack pointer <span class="math">\(\mathtt{\%esp}\)</span>
and frame pointer <span class="math">\(\mathtt{\%ebp}\)</span> to what they were when the function began. </p>
<p>Thus, to return from the function you have to do the following:</p>
<div class="highlight"><pre><span></span><span class="nf">movl</span> <span class="nv">%ebp</span><span class="p">,</span> <span class="nv">%esp</span> <span class="c"># Set stack pointer back to the beginning of the frame</span>
<span class="nf">popl</span> <span class="nv">%ebp</span>       <span class="c"># Restore the caller's base pointer and now stack pointer pointing to Return address</span>
<span class="nf">ret</span>             <span class="c"># Since stack pointer pointing to return address, we can now call ret</span>
</pre></div>


<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The step 2 and 3 are unecessary if we don't save any registers at all. The reason we do step 2
is that we need to move the stack pointer pointing to the saved registers. If there are
no saved registers, the step 4 can achieve the same effect as step 3 because
after you move the stack pointer back, future stack pushes will likely overwrite everything you
put there. </p>
</div>
<h3 id="two-examples">Two examples</h3>
<p>Now, we can take a look at two examples: the first one is to calculate the power given two numbers: one
as the base and the other one as the power. The second example calculate the factorial of
a given number, which demonstrates how the recursive function.
is done.</p>
<div class="highlight"><pre><span></span>        <span class="c"># PURPOSE: Program to illustrate how functions work</span>
        <span class="c">#          This program will compute the value of  2^3 + 5^2</span>
        <span class="c">#</span>

        <span class="c"># Everything in the main program is stored in registers,</span>
        <span class="c"># so the data section doesn't have anything.</span>
        <span class="na">.section</span> <span class="no">.data</span>

        <span class="na">.section</span> <span class="no">.text</span>

        <span class="na">.globl</span> <span class="no">_start</span>

<span class="nl">_start:</span>
        <span class="nf">pushl</span> <span class="no">$3</span>                  <span class="c"># push second argument</span>
        <span class="nf">pushl</span> <span class="no">$2</span>                  <span class="c"># push first argument</span>
        <span class="nf">call</span> <span class="no">power</span>                <span class="c"># call the function</span>
        <span class="nf">addl</span> <span class="no">$8</span><span class="p">,</span> <span class="nv">%esp</span>             <span class="c"># move the stack pointer back</span>
        <span class="nf">pushl</span> <span class="nv">%eax</span>                <span class="c"># save the first answer before calling the next function</span>

        <span class="nf">pushl</span> <span class="no">$2</span>                  <span class="c"># push second argument</span>
        <span class="nf">pushl</span> <span class="no">$5</span>                  <span class="c"># push first argument</span>
        <span class="nf">call</span> <span class="no">power</span>                <span class="c"># call the function</span>
        <span class="nf">addl</span> <span class="no">$8</span><span class="p">,</span> <span class="nv">%esp</span>             <span class="c"># move the stack pointer back</span>

        <span class="nf">popl</span> <span class="nv">%ebx</span>                 <span class="c"># The second answer is already in %eax. We saved the</span>
                                  <span class="c"># first answer onto the stack, so now we can just pop</span>
                                  <span class="c"># it out into %ebx</span>
        <span class="nf">addl</span> <span class="nv">%eax</span><span class="p">,</span> <span class="nv">%ebx</span>           <span class="c"># add them together, the result is in %ebx</span>
        <span class="nf">movl</span> <span class="no">$1</span><span class="p">,</span> <span class="nv">%eax</span>             <span class="c"># exit (%ebx is returned)</span>
        <span class="nf">int</span> <span class="no">$0x80</span>

        <span class="c"># PURPOSE: This function is used to compute the value of a number raised to a power</span>
        <span class="c">#</span>
        <span class="c"># INPUT: First argument - the base number</span>
        <span class="c">#        Second argumnet - the power to raise it to</span>
        <span class="c">#</span>
        <span class="c"># OUTPUT: Will give the result as a return value</span>
        <span class="c">#</span>
        <span class="c"># NOTES: The power must be 1 or greater</span>
        <span class="c">#</span>
        <span class="c"># VARIABLES:</span>
        <span class="c">#        %ebx - holds the base number</span>
        <span class="c">#        %ecx - holds the power</span>
        <span class="c">#        -4(%ebp) - holds the current result</span>
        <span class="c">#</span>
        <span class="c">#        %eax is used for temporary storage</span>
        <span class="na">.type</span> <span class="no">power</span><span class="p">,</span> <span class="na">@function</span>
<span class="nl">power:</span>
        <span class="nf">pushl</span> <span class="nv">%ebp</span>                <span class="c"># save old base pointer</span>
        <span class="nf">movl</span> <span class="nv">%esp</span><span class="p">,</span> <span class="nv">%ebp</span>           <span class="c"># make stack pointer the base pointer</span>
        <span class="nf">subl</span> <span class="no">$4</span><span class="p">,</span> <span class="nv">%esp</span>             <span class="c"># get room for our local storage</span>

        <span class="nf">movl</span> <span class="mi">8</span><span class="p">(</span><span class="nv">%ebp</span><span class="p">),</span> <span class="nv">%ebx</span>        <span class="c"># put first argument in %eax</span>
        <span class="nf">movl</span> <span class="mi">12</span><span class="p">(</span><span class="nv">%ebp</span><span class="p">),</span> <span class="nv">%ecx</span>       <span class="c"># put second argument in %ecx</span>

        <span class="nf">movl</span> <span class="nv">%ebx</span><span class="p">,</span> <span class="p">-</span><span class="mi">4</span><span class="p">(</span><span class="nv">%ebp</span><span class="p">)</span>       <span class="c"># store current result</span>

<span class="nl">power_loop_start:</span>
        <span class="nf">cmpl</span> <span class="no">$1</span><span class="p">,</span> <span class="nv">%ecx</span>             <span class="c"># if the power is 1, we are done</span>
        <span class="nf">je</span> <span class="no">end_power</span>
        <span class="nf">movl</span> <span class="p">-</span><span class="mi">4</span><span class="p">(</span><span class="nv">%ebp</span><span class="p">),</span> <span class="nv">%eax</span>       <span class="c"># move the current result into %eax</span>
        <span class="nf">imull</span> <span class="nv">%ebx</span><span class="p">,</span> <span class="nv">%eax</span>          <span class="c"># multiply the current result by the base number</span>
        <span class="nf">movl</span> <span class="nv">%eax</span><span class="p">,</span> <span class="p">-</span><span class="mi">4</span><span class="p">(</span><span class="nv">%ebp</span><span class="p">)</span>       <span class="c"># store the current result</span>

        <span class="nf">decl</span> <span class="nv">%ecx</span>                 <span class="c"># decrease the power</span>
        <span class="nf">jmp</span> <span class="no">power_loop_start</span>      <span class="c"># run for the next power</span>

<span class="nl">end_power:</span>
        <span class="nf">movl</span> <span class="p">-</span><span class="mi">4</span><span class="p">(</span><span class="nv">%ebp</span><span class="p">),</span> <span class="nv">%eax</span>       <span class="c"># return value goes in %eax</span>
        <span class="nf">movl</span> <span class="nv">%ebp</span><span class="p">,</span> <span class="nv">%esp</span>           <span class="c"># restore the stack pointer</span>
        <span class="nf">pop</span> <span class="nv">%ebp</span>                  <span class="c"># restore the base pointer</span>
        <span class="nf">ret</span>
</pre></div>


<p>The key to understand the function call is to trace through the status of stack frame. One thing to 
highlight as a side note is:</p>
<div class="highlight"><pre><span></span><span class="na">.type</span> <span class="no">power</span><span class="p">,</span><span class="na">@function</span>
</pre></div>


<p>This tells the linker that the symbol power should be treated as a function. 
Since this program is only in one file, it would work just the same with this left out. However, it is good practice.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>To run the program on 64-bit platform, we need to simulate 32-bit environment by assembling and linking our program
like this:</p>
<p><code>as --32 power.s -o power.o; 
ld -m elf_i386 -s power.o -o power</code></p>
</div>
<div class="highlight"><pre><span></span>        <span class="c"># PURPOSE: - Given a number, this program computes the factorial. For example,</span>
        <span class="c">#            the factorial of 3 is 3 * 2 * 1, or 6. The factorial of</span>
        <span class="c">#            4 is 4 * 3 * 2 * 1, or 24, and so on.</span>
        <span class="c">#</span>
        <span class="c"># This program shows how to call a function recursively.</span>

        <span class="na">.section</span> <span class="no">.data</span>

        <span class="c"># This program has no global data</span>

        <span class="na">.section</span> <span class="no">.text</span>

        <span class="na">.global</span> <span class="no">_start</span>
        <span class="na">.global</span> <span class="no">factorial</span> <span class="c"># this is unneeded unless we want to share</span>
                          <span class="c"># this function among other programs</span>

<span class="nl">_start:</span>
        <span class="nf">pushl</span> <span class="no">$4</span>          <span class="c"># The factorial takes one argument - the number we want</span>
                          <span class="c"># a factorial of. So, it gets pushed.</span>
        <span class="nf">call</span> <span class="no">factorial</span>    <span class="c"># run the factorial function</span>
        <span class="nf">addl</span> <span class="no">$4</span><span class="p">,</span> <span class="nv">%esp</span>     <span class="c"># scrubs the parameter that was pushed on the stack</span>
        <span class="nf">movl</span> <span class="nv">%eax</span><span class="p">,</span> <span class="nv">%ebx</span>   <span class="c"># factorial returns the answer in %eax, but we want it</span>
                          <span class="c"># in %ebx to send it as our exit status</span>
        <span class="nf">movl</span> <span class="no">$1</span><span class="p">,</span> <span class="nv">%eax</span>     <span class="c"># call the kernel's exit function</span>
        <span class="nf">int</span> <span class="no">$0x80</span>

        <span class="c"># This is the actual function definition</span>
        <span class="na">.type</span> <span class="no">factorial</span><span class="p">,</span> <span class="na">@function</span>
<span class="nl">factorial:</span>
        <span class="nf">pushl</span> <span class="nv">%ebp</span>         <span class="c"># standard function stuff - we have to restore %ebp</span>
                           <span class="c"># to its prior state before returning, so we have to push it</span>
        <span class="nf">movl</span>  <span class="nv">%esp</span><span class="p">,</span> <span class="nv">%ebp</span>   <span class="c"># This is because we don't want to modify the stack pointer</span>
                           <span class="c"># so we use %ebp</span>
        <span class="nf">movl</span> <span class="mi">8</span><span class="p">(</span><span class="nv">%ebp</span><span class="p">),</span> <span class="nv">%eax</span> <span class="c"># This moves the first argument to %eax</span>
                           <span class="c"># 4(%ebp) holds the return address, and 8(%ebp) holds the first parameter</span>
        <span class="nf">cmpl</span> <span class="no">$1</span><span class="p">,</span> <span class="nv">%eax</span>      <span class="c"># if the number is 1, this is our base case, and we simply</span>
                           <span class="c"># return (1 is already in %eax as the return value)</span>
        <span class="nf">je</span> <span class="no">end_factorial</span>
        <span class="nf">decl</span> <span class="nv">%eax</span>          <span class="c"># otherwise, decrease the value</span>
        <span class="nf">pushl</span> <span class="nv">%eax</span>         <span class="c"># push it for our call to factorial</span>
        <span class="nf">call</span> <span class="no">factorial</span>     <span class="c"># call factorial</span>
        <span class="nf">movl</span> <span class="mi">8</span><span class="p">(</span><span class="nv">%ebp</span><span class="p">),</span> <span class="nv">%ebx</span> <span class="c"># %eax has the return value, so we reload our parameter</span>
                           <span class="c"># into %ebx</span>
        <span class="nf">imull</span> <span class="nv">%ebx</span><span class="p">,</span> <span class="nv">%eax</span>   <span class="c"># multiply that by the result of the last call to factorial</span>
                           <span class="c"># (in %eax) the answer is stored in %eax, which is good since</span>
                           <span class="c"># that's where return values go.</span>
<span class="nl">end_factorial:</span>
        <span class="nf">movl</span> <span class="nv">%ebp</span><span class="p">,</span> <span class="nv">%esp</span>    <span class="c"># standard function return stuff - we have to restore</span>
        <span class="nf">popl</span> <span class="nv">%ebp</span>          <span class="c"># %ebp and %esp to where they were before the function started</span>
        <span class="nf">ret</span>                <span class="c"># return to the function (this pops the return value, too)</span>
</pre></div>


<p>One good practice we should note is that we should always clean up our stack parameter after a function 
call returns. In this program, we do <code>addl $4, %esp</code> immediately after we <code>call factorial</code> in our <code>_start</code>.</p>
<h2 id="future-works">Future works</h2>
<ul>
<li>For this post, I assume we work with x86 32-bit processor. It's interesting to further
investigate how the things changed for the 64-bit world.</li>
</ul>
<h2 id="links-to-resources">Links to resources</h2>
<p>Here are some of the resources I found helpful while preparing this article:</p>
<ol>
<li><a href="http://dbp-consulting.com/tutorials/debugging/basicAsmDebuggingGDB.html">Basic Assembler Debugging with GDB by Patrick Horgan</a></li>
<li><a href="https://www.csee.umbc.edu/~cpatel2/links/310/nasm/gdb_help.shtml">Using gdb for Assembly Language Debugging</a></li>
<li><a href="https://cs.brown.edu/courses/cs033/docs/guides/x64_cheatsheet.pdf">x64 Cheat Sheet - Brown CS 33</a></li>
<li><a href="http://savannah.spinellicreations.com/pgubook/ProgrammingGroundUp-1-0-booksize.pdf">Programming from the Ground Up</a> Chapter 3,4</li>
<li><a href="https://www.amazon.com/Computer-Systems-Programmers-Perspective-2nd/dp/0136108040">Computer Systems: A Programmer's Perspective (CSAPP) (2nd Edition)</a> Section 3.7</li>
</ol>
<div class="footnote">
<hr/>
<ol>
<li id="fn:1">
<p>For scaled indexed addressing, it actually includes both base pointer addressing mode 
(i.e. <code>movl 4(%eax), %ebx</code>) and indexed addressing mode 
(i.e., <code>movl string_start(, %ecx, 1), %eax</code>). <a class="footnote-backref" href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text">↩</a></p>
</li>
</ol>
</div>
<script type="text/javascript">if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width < 768) ? "left" : align;
        indent = (screen.width < 768) ? "0em" : indent;
        linebreak = (screen.width < 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' && location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['CommonHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' }, Macros: {} }," +
        "    jax: ['input/TeX','input/MathML','output/CommonHTML']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
</script></body></html>
        </article>

<!--        <footer>
            <p>This entry is posted in <a href="../../../../../category/programming-languages.html">programming languages</a>.</p>
        </footer>-->

<div class="comments">
    <div id="disqus_thread"></div>
    <script type="text/javascript">
        var disqus_shortname = 'zhu45-org';
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>

    </div>


<footer class="blog-footer">
    <p class="disclaimer">
        Zeyuan Hu &copy; 2015-2017.
    </p>
</footer>
            </div>
<script>
    var _gaq=[['_setAccount','UA-37565522-2'],['_trackPageview']];
    (function(d,t){var g=d.createElement(t),s=d.getElementsByTagName(t)[0];
    g.src=('https:'==location.protocol?'//ssl':'//www')+'.google-analytics.com/ga.js';
    s.parentNode.insertBefore(g,s)}(document,'script'));
</script>
    </body>
</html>