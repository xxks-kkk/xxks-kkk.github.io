<!DOCTYPE html>
<!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js"> <!--<![endif]-->
    <head>
        <meta charset="utf-8">
        <title>    MAW Chapter 6: Priority Queues (Heaps) writing questions
</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta content="This is the homepage of Zeyuan Hu" name="description">
        <meta content="Zeyuan Hu, Zeyuan, zeyuan hu, zeyuan ibm, IBM, Zeyuan IBM, UW Madison, University of Wisconsin Madison, zeyuan wisc, zeyuan IBM, zeyuan federation" name="keywords">
        <meta content="Zeyuan Hu" name="author">
        <link href='https://fonts.googleapis.com/css?family=Gentium+Book+Basic|Merriweather:400,300' rel='stylesheet' type='text/css'>
        <link rel="stylesheet" href="../../../../../theme/css/cid.css">
        <!-- add font-awesome -->
        <script defer src="../../../../../theme/fa-5/js/all.js"></script>
        <link rel="stylesheet" href="../../../../../theme/academicons/css/academicons.css"/>
        <link href="https://zhu45.org/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="Zeyuan Hu's page Atom Feed" />
        <link href="https://zhu45.org/feeds/all.rss.xml" type="application/rss+xml" rel="alternate" title="Zeyuan Hu's page RSS Feed" />
        <link href="../../../../../theme/images/favicon.ico" rel="icon">
    </head>
    <body>
        <!--[if lt IE 7]>
            <p class="chromeframe">You are using an <strong>outdated</strong> browser. Please <a href="http://browsehappy.com/">upgrade your browser</a> or <a href="http://www.google.com/chromeframe/?redirect=true">activate Google Chrome Frame</a> to improve your experience.</p>
        <![endif]-->
            <div class="container">
<header class="blog-header">
        <h1 id="site-title"><a href="../../../../.." style="color: black; text-decoration: none">Zeyuan Hu's page</a></h1>
    <p></p>
    <nav>
        <!--<a href="../../../../../zeyuan-hus-resume.html" style="padding: 10px">RESUME</a>-->
        <!-- <a href="../../../../../archives" style="padding: 10px">ARCHIVES</a> -->
            <a href="../../../../../index.html" style="padding: 10px">BLOG</a>
            <a href="../../../../../projects.html" style="padding: 10px">PROJECTS</a>
    </nav>
</header>
    <div class="post">
        <header>
          <div class="post-title">MAW Chapter 6: Priority Queues (Heaps) writing questions</h1></div>
          <div class="post-date"><time datetime="2017-03-26T12:01:00+08:00">Mar 26, 2017</time></div>
        </header>
        
        <article>
            <h2 id="solutions">Solutions</h2>
<p>including: MAW 6.6, 6.7, 6.9, 6.13, 6.14, 6.16, 6.17, 6.27, 6.28,</p>
<h3 id="maw-66">MAW 6.6</h3>
<blockquote>
<p>How many nodes are in the large heap in Figure 6.13?</p>
</blockquote>
<p>This question is interesting in the sense that the algorithm of counting reflecting
the underneath implemenation structure. Since the binary heap is actually implemented 
in terms of array, we start with <span class="math">\(i = 1\)</span> and position at the root. We follow the path
toward the last node, doubling <span class="math">\(i\)</span> when taking a left child, and doubling <span class="math">\(i\)</span> and adding
one when taking a right child. Then, we have the following calculation:
<span class="math">\(2(2(2(2(2(2(2i+1)+1)))))+1 = 225\)</span>. The picture below shows the path from the root 
to the node in the last position:</p>
<p><img alt="MAW 6.6" class="img-responsive" src="/images/maw-6-6.PNG"/></p>
<h3 id="maw-67">MAW 6.7</h3>
<blockquote>
<p>b. show that a heap of eight elements can be constructed in eight comparisons between 
   heap elements.</p>
</blockquote>
<p>Thie question is interesting because it offers another method we can use when build a binary
heap with even number of elements. That is, we build binomial queue first. since the binary 
form of <span class="math">\(8\)</span> is <span class="math">\(1000_2\)</span>, this means we will have only one binomial tree <span class="math">\(B_3\)</span> inside the binomial queue.
Once we construct this binomial tree, we need one last step to tweek the binomial tree to
follow binary heap property, namely each node has to have either zero or two children.</p>
<p>For this question, it takes seven comparisons to construct the binomial queue (with a solo binomial tree)
and we get the following:</p>
<p><img alt="MAW 6.7.b" class="img-responsive" src="/images/maw-6-7-b.PNG"/></p>
<p>Then we need to restore the binary heap property because "a" node has three children.
This can be done by the eighth compariosn between "b" and "c". If "c" is less than "b",
then "b" is made a child of "c". Otherwise, both "c" and "d" are made children of "b".</p>
<h3 id="maw-69">MAW 6.9</h3>
<blockquote>
<p>a. Give an algorithm to find all nodes less than some value, X, in a binary heap.
   Your algorithm should run in <span class="math">\(O(K)\)</span>, where <span class="math">\(K\)</span> is the number of nodes output.</p>
</blockquote>
<p>The big idea is that we perform a preorder traversal of the heap. In detail, we start
from the root of the heap. If value of the root is smaller than <span class="math">\(X\)</span>, then we output
this value and call procedure recursively once for its left child and once for its right 
child. If the value of a node is bigger or equal than <span class="math">\(X\)</span>, then the procedure halts
without printing the value. We don't need to check the children by heap definition.</p>
<p>The complexity of this algorithm is <span class="math">\(O(N)\)</span> in worst case, where <span class="math">\(N\)</span> is the total number
of nodes in the heap. This happens when every node in the heap is smaller than <span class="math">\(X\)</span>, and 
the procedure has to call each node of the heap.</p>
<blockquote>
<p>b. Does your algorithm extend to any of the other heap structures dicussed in 
   this chapter?</p>
</blockquote>
<p>Yes. It works for leftist heap, skew heap, and d-heaps.</p>
<h3 id="maw-613">MAW 6.13</h3>
<blockquote>
<p>If a d-heap is stored as an array, for an entry located in position <span class="math">\(i\)</span>,
where are the parents and children?</p>
</blockquote>
<p>Let's begin with children. Assume that position <span class="math">\(i\)</span> corresponds to the <span class="math">\(X\)</span>th node
of level <span class="math">\(l\)</span>. Therefore</p>
<div class="math">$$
i = \sum_{j=0}^{l-1}d^j+X
$$</div>
<p><span class="math">\(\sum_{j=0}^{l-1}d^j\)</span> is a geometric series whose first term equals <span class="math">\(1\)</span>, whose
common ratio is <span class="math">\(d\)</span>, and that contains <span class="math">\(l\)</span> terms in total. Thus, the result is
<span class="math">\(\frac{d^l-1}{d-1}\)</span> and thus, we have </p>
<div class="math">$$
i = \frac{d^l-1}{d-1} + X
$$</div>
<p>We now calculate the position of <span class="math">\(i\)</span>'s second last child in terms of <span class="math">\(d\)</span>, <span class="math">\(l\)</span>, and
<span class="math">\(X\)</span>. This equals <span class="math">\(i\)</span>, plus the number of nodes after <span class="math">\(i\)</span> on level <span class="math">\(l\)</span>, plus <span class="math">\(d\)</span>
times the number of nodes before <span class="math">\(i\)</span> on level <span class="math">\(l\)</span>, plus <span class="math">\(d-1\)</span>.</p>
<div class="math">$$
\begin{eqnarray*}
&amp;=&amp; \frac{d^l-1}{d-1} + X + d^l - X + (X-1)d + d - 1 \\
&amp;=&amp; \frac{d^l-1}{d-1} + d^l-1 + dX \\
&amp;=&amp; \frac{d(d^l-1)}{d-1} + dX \\
&amp;=&amp; d(\frac{d^l-1}{d-1} + X) \\
&amp;=&amp; di
\end{eqnarray*}
$$</div>
<p>Therefore the second last child of <span class="math">\(i\)</span> is in position <span class="math">\(id\)</span>. It follows that the children
of <span class="math">\(i\)</span> are in positions <span class="math">\(id-(d-2), \dots, id+1\)</span>.</p>
<p>A node is a child of <span class="math">\(i\)</span> if and only if it is in one of the positions <span class="math">\(id-(d-2), \dots, id+1\)</span>.
So what you want here is a function that will map each of these to <span class="math">\(i\)</span>, but will not
map any other value to <span class="math">\(i\)</span>. Let <span class="math">\(j\)</span> be any of these values. Clearly,</p>
<div class="math">$$
\lfloor{\frac{j + (d-2)}{d}}\rfloor = i
$$</div>
<p>But if <span class="math">\(j\)</span> is greater than <span class="math">\(id+1\)</span> or less than <span class="math">\(id - (d-2)\)</span> then</p>
<div class="math">$$
\lfloor{\frac{j + (d-2)}{d}}\rfloor \ne i
$$</div>
<p>Thus we have our function which can now be used to work out the position of the
parent of <span class="math">\(i\)</span>.</p>
<div class="math">$$
\lfloor{\frac{i + (d-2)}{d}}\rfloor
$$</div>
<h2 id="maw-614">MAW 6.14</h2>
<blockquote>
<p>Suppose we need to perform <span class="math">\(M\)</span> <code>PercolateUp</code> and <span class="math">\(N\)</span> <code>DeleteMiin</code> on a d-heap
that initially has <span class="math">\(N\)</span> elements.</p>
<p>a. What is the total running time of all operations in terms of <span class="math">\(M\)</span>, <span class="math">\(N\)</span>, and <span class="math">\(d\)</span>?</p>
</blockquote>
<p>A <code>percolateUp</code> operation on a d-heap with <span class="math">\(N\)</span> elements takes <span class="math">\(O(\log_d N)\)</span> steps.
The key is that each time we bubble the hole up, we only do comparison once: 
compare the insertion value with the parent of the hole (Figure 6.6, 6.7 helps understanding).</p>
<p>A <code>deleteMin</code> operation on a d-heap with <span class="math">\(N\)</span> elements takes <span class="math">\(O(d \log_d N)\)</span> steps.
Here, we need to feel the empty hole with the minimum value of its children. This can
take <span class="math">\(d\)</span> comparison to find the minimum (see p.184). </p>
<p>Thus in total this will take <span class="math">\(O(M\log_d N + Nd\log_d N)\)</span> steps.</p>
<blockquote>
<p>b. If <span class="math">\(d = 2\)</span>, what is the running time of all heap operations?</p>
</blockquote>
<p>Substitute 2 into the formula calculated in part a) gives <span class="math">\(O((M+N)\log_2 N)\)</span>.</p>
<blockquote>
<p>c. If <span class="math">\(d = \theta (N)\)</span>, what is the total running time?</p>
</blockquote>
<p>If <span class="math">\(d = \theta (N)\)</span> then <span class="math">\(d = cN\)</span>, where <span class="math">\(c\)</span> is a constant value independent of <span class="math">\(N\)</span>.
Substituting <span class="math">\(cN\)</span> into the formula calculated in part a) gives:</p>
<div class="math">$$ 
M\log_{cN} N + NcN \log_{cN}N = O(M + N^2)
$$</div>
<blockquote>
<p>d. What choice of <span class="math">\(d\)</span> minimizes the total running time?</p>
</blockquote>
<p><span class="math">\(d = max(2, M/N)\)</span> (See the related discussion at the end of Section 11.4)</p>
<!--http://mail.csis.ul.ie/~cs4115/resources/sol10.pdf-->
<h2 id="maw-616">MAW 6.16</h2>
<blockquote>
<p>Merge the two leftist heaps in Figure 6.58</p>
</blockquote>
<p><img alt="MAW 6.16" class="img-responsive" src="/images/maw-6-16-problem.PNG"/></p>
<p>The book doesn't do a well job on displaying the detailed steps in merging the 
leftist heap. So, I decide to use this problem as an illustration. By algorithm
description on p. 194 and the actual algorithm implementation on p.189., there are
two key points in the algorithm:</p>
<ol>
<li>
<p>recursively merge the heap with the larger root with the right subheap of
the heap with the smaller root.</p>
</li>
<li>
<p>We do the swap at the root.</p>
</li>
</ol>
<p>The following shows the steps to get the final answer for this problem:</p>
<p><img alt="MAW 6.16 solution" class="img-responsive" src="/images/maw-6-16-solution.jpg" style="width:700px;height:400px"/></p>
<h2 id="maw-617">MAW 6.17</h2>
<blockquote>
<p>Show the result of inserting keys 1 to 15 in order into an initially empty leftist heap.</p>
</blockquote>
<p>Use <a href="https://www.cs.usfca.edu/~galles/visualization/LeftistHeap.html">this wonderful site</a>
to see the whole process of insertion.</p>
<h2 id="maw-627">MAW 6.27</h2>
<blockquote>
<p>Prove that a binomial tree <span class="math">\(B_k\)</span> has binomial trees <span class="math">\(B_0, B_1, \dots, B_{k-1}\)</span>
as children of the root.</p>
</blockquote>
<p>I'll try to use two ways to prove this. Both ways are by induction but one of them
is more mathematical formula involved.</p>
<p><em>Method 1</em></p>
<p>Clearly the claim is true for <span class="math">\(k = 1\)</span>. Suppose it is true for all values <span class="math">\(i = 1, 2, \dots, k-1\)</span>.
Since for <span class="math">\(B_k\)</span>, we have <span class="math">\(2^k\)</span> nodes. Then, by the induction hypothesis, we have
<span class="math">\(2^{k-1} = 1 + 2^0 + \dots + 2^{k-2}\)</span>. Now, multiplying both sides of the equation
by 2, we have <span class="math">\(2^k = 2 + 2 + \dots + 2^{k-1}\)</span>, which is the same as
<span class="math">\(2^k = 1 + 2^0 + \dots + 2^{k-1}\)</span>. This completes the proof.</p>
<p><em>Method 2</em></p>
<p>Again the claim is true for <span class="math">\(k = 1\)</span>. Suppose it is true for all values <span class="math">\(i = 1, 2, \dots, k-1\)</span>.
A <span class="math">\(B_k\)</span> tree is fromed by attaching a <span class="math">\(B_{k-1}\)</span> tree to the root of a <span class="math">\(B_{k-1}\)</span> tree.
Thus, by induction, it contains a <span class="math">\(B_0\)</span> through <span class="math">\(B_{k-2}\)</span> tree, as well as the
newly attached <span class="math">\(B_{k-1}\)</span> tree, proving the claim.</p>
<h2 id="maw-628">MAW 6.28</h2>
<blockquote>
<p>Prove that a binomial tree of height <span class="math">\(k\)</span> has <span class="math">\({k \choose d}\)</span> nodes at depth <span class="math">\(d\)</span>.</p>
</blockquote>
<p>Proof is by induction. Clearly the claim is true for <span class="math">\(k=1\)</span>. Assume true for 
all values <span class="math">\(i=1,2,\dots,k\)</span>. A <span class="math">\(B_{k+1}\)</span> tree is formed by attaching a <span class="math">\(B_k\)</span> tree
to the original <span class="math">\(B_k\)</span> tree. The original tree has <span class="math">\({k \choose d}\)</span> nodes at depth
<span class="math">\(d\)</span> by induction hypothesis. The attached tree had <span class="math">\(\binom{k}{d-1}\)</span> nodes at depth
<span class="math">\(d-1\)</span>, which are now at depth <span class="math">\(d\)</span>. Adding these two terms we have</p>
<div class="math">$$
\binom{k+1}{d} = \binom{k}{d} + \binom{k}{d-1}
$$</div>
<script type="text/javascript">if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width < 768) ? "left" : align;
        indent = (screen.width < 768) ? "0em" : indent;
        linebreak = (screen.width < 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
</script>
        </article>

<!--        <footer>
            <p>This entry is posted in <a href="../../../../../category/data-struct-algo.html">Data Struct & Algo</a>.</p>
        </footer>-->

<div class="comments">
    <div id="disqus_thread"></div>
    <script type="text/javascript">
        var disqus_shortname = 'zhu45-org';
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>

    </div>


<footer class="blog-footer">
    <div id="copyright">
      Copyright (c) 2015-2019 <a href="../../../../../about-me.html">Zeyuan Hu</a>
    </div>
    <div id="archive">
      <a href="../../../../../archives/">Archive</a>
    </div>
</footer>
            </div>
<script>
    var _gaq=[['_setAccount','UA-37565522-2'],['_trackPageview']];
    (function(d,t){var g=d.createElement(t),s=d.getElementsByTagName(t)[0];
    g.src=('https:'==location.protocol?'//ssl':'//www')+'.google-analytics.com/ga.js';
    s.parentNode.insertBefore(g,s)}(document,'script'));
</script>
    </body>
</html>