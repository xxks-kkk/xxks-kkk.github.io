<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"><channel><title>Fluffy Stuff</title><link>http://zhu45.org/</link><description>A tmp place to rest</description><lastBuildDate>Mon, 12 Jun 2017 17:20:00 +0800</lastBuildDate><item><title>Solving recurrence relations (part 2)</title><link>http://zhu45.org/posts/2017/Jun/12/solving-recurrence-relations-part-2/</link><description>&lt;p&gt;&lt;a href="http://zhu45.org/posts/2017/Feb/02/solving-recurrence-relations-in-a-nutshell/"&gt;Several months ago&lt;/a&gt;, 
I breifly summarize the ways to solve recurrence relations. At the end of that post,
I indicate that different types of recurrence relation may require different kinds 
of treatments to solve them. Thus, this post will be the first "Downloadable Content (DLC)"
with the aim to solve the recurrence relation: &lt;span class="math"&gt;\(T(N) = 2T(N/2) + N\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;This recurrence relation comes from merge sort and the algorithm itself represents
a classic divide-and-conquer strategy: in order to sort &lt;span class="math"&gt;\(N\)&lt;/span&gt; elements, we can
sort &lt;span class="math"&gt;\(N/2\)&lt;/span&gt; elements first 
(i.e., &lt;em&gt;divide&lt;/em&gt; the problem into smaller problems and solve recursively),
and then we merge two sorted &lt;span class="math"&gt;\(N/2\)&lt;/span&gt; elements back into one &lt;span class="math"&gt;\(N\)&lt;/span&gt; sorted array
(i.e., we patch toghter the answer in &lt;em&gt;conquer&lt;/em&gt; phase.)&lt;/p&gt;
&lt;p&gt;The exactly recurrence relation we try to solve is the following with assumption
that &lt;span class="math"&gt;\(N\)&lt;/span&gt; is a power of 2:&lt;/p&gt;
&lt;div class="math"&gt;$$
\begin{eqnarray*} 
T(1) &amp;amp;=&amp;amp; 1 \\
T(N) &amp;amp;=&amp;amp; 2T(N/2) + N 
\end{eqnarray*}
$$&lt;/div&gt;
&lt;p&gt;There are two ways to solve this recurrence relation:&lt;/p&gt;
&lt;h2 id="method-1-construct-a-telescoping-sum"&gt;Method 1: Construct a telescoping sum&lt;/h2&gt;
&lt;p&gt;The goal of this method is to construct a telescoping sum (i.e see
&lt;a href="https://en.wikipedia.org/wiki/Telescoping_series"&gt;telescope series&lt;/a&gt; to get a sense
of &lt;em&gt;telescoping&lt;/em&gt;) with the aim
to find a relation between &lt;span class="math"&gt;\(T(N)\)&lt;/span&gt; and &lt;span class="math"&gt;\(T(1)\)&lt;/span&gt; (or the base cases, in general). &lt;/p&gt;
&lt;p&gt;Let's work through our example above to demonstrate this method. We divide the
recurrence relation through by &lt;span class="math"&gt;\(N\)&lt;/span&gt; and repeatively doing so for every possible &lt;span class="math"&gt;\(N\)&lt;/span&gt;
(i.e. &lt;span class="math"&gt;\(N, N/2, N/4, \dots, 2, 1\)&lt;/span&gt;) and see what we can get:&lt;/p&gt;
&lt;div class="math"&gt;$$
\begin{eqnarray*} 
\frac{T(N)}{N} &amp;amp;=&amp;amp; \frac{T(N/2)}{N/2} + 1 \\
\frac{T(N/2)}{N/2} &amp;amp;=&amp;amp; \frac{T(N/4)}{N/4} + 1 \\
\frac{T(N/4)}{N/4} &amp;amp;=&amp;amp; \frac{T(N/8)}{N/8} + 1 \\
\vdots \\
\frac{T(2)}{2} &amp;amp;=&amp;amp; \frac{T(1)}{1} + 1 \\
\end{eqnarray*}
$$&lt;/div&gt;
&lt;p&gt;We add up all the equations: we add all of the terms on the left-hand side and set
the result equal to the sum of all of the terms on the right-hand side. This leads
to a &lt;em&gt;telescoping&lt;/em&gt; sum: all the terms that appear on both sides get cancelled. 
For example, the term &lt;span class="math"&gt;\(T(N/2)/(N/2)\)&lt;/span&gt; appears on both sides and thus cancels.
After everything is added, the final result is:&lt;/p&gt;
&lt;div class="math"&gt;$$
\frac{T(N)}{N} = \frac{T(1)}{1} + \log N \cdot 1
$$&lt;/div&gt;
&lt;p&gt;because all of the other terms cancel and there are &lt;span class="math"&gt;\(\log N\)&lt;/span&gt; equations, and so all
the &lt;span class="math"&gt;\(1\)&lt;/span&gt;s at the end of these equations add up to &lt;span class="math"&gt;\(\log N\)&lt;/span&gt;.&lt;/p&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;for this recurrence relation, it is necessary to divide through &lt;span class="math"&gt;\(N\)&lt;/span&gt; in order
to get telescoping sum. However, how to construct telescoping sum is case by case.
For instance, for a recurrence relation &lt;span class="math"&gt;\(NT(N) = (N+1)T(N-1) + 2cN\)&lt;/span&gt;, we need to 
divide &lt;span class="math"&gt;\(N(N+1)\)&lt;/span&gt;. For a recurrence relation &lt;span class="math"&gt;\(T(N) = T(N-1) + cN\)&lt;/span&gt; &lt;sup id="fnref:1"&gt;&lt;a class="footnote-ref" href="#fn:1" rel="footnote"&gt;1&lt;/a&gt;&lt;/sup&gt;, we don't need to 
do any division. We just need to use the recurrence relation repeatively for different
&lt;span class="math"&gt;\(N\)&lt;/span&gt; to construct the telescoping sum (i.e. &lt;span class="math"&gt;\(T(N-1) = T(N-2) + c(N-1)\)&lt;/span&gt;, 
&lt;span class="math"&gt;\(T(N-2) = T(N-3) + c(N-2)\)&lt;/span&gt;, and so on.)&lt;/p&gt;
&lt;/div&gt;
&lt;h2 id="method-2-iteratively-substitute"&gt;Method 2: Iteratively substitute&lt;/h2&gt;
&lt;p&gt;For this method, we continuely substitute the recurrence relation on the right-hand
side with the hope to find a pattern of the general solution to the recurrence relation.&lt;/p&gt;
&lt;p&gt;We have&lt;/p&gt;
&lt;div class="math"&gt;$$
\begin{eqnarray*} 
T(N) &amp;amp;=&amp;amp; 2T(N/2) + N \\
T(N/2) &amp;amp;=&amp;amp; 2T(N/4) + N/2 
\end{eqnarray*}
$$&lt;/div&gt;
&lt;p&gt;Then, we substitute the second equation back into the first equation's right-hand side and 
we get:&lt;/p&gt;
&lt;div class="math"&gt;$$
\begin{eqnarray}
T(N) &amp;amp;=&amp;amp; 2(2T(N/4)+N/2) + N \nonumber \\
     &amp;amp;=&amp;amp; 4T(N/4) + 2N \label{eqn:1}
\end{eqnarray}
$$&lt;/div&gt;
&lt;p&gt;Now, we can substitute &lt;span class="math"&gt;\(N/4\)&lt;/span&gt; into the main equation, we see that&lt;/p&gt;
&lt;div class="math"&gt;$$
\begin{eqnarray}
T(N) &amp;amp;=&amp;amp; 4(2T(N/8)+N/4) + 2N \nonumber \\
     &amp;amp;=&amp;amp; 8T(N/8) + 3N \label{eqn:2}
\end{eqnarray}
$$&lt;/div&gt;
&lt;p&gt;We can continuing this substitution, and if we observe the \ref{eqn:1} and \ref{eqn:2}
we can obtain the following pattern:&lt;/p&gt;
&lt;div class="math"&gt;$$
T(N) = 2^kT(N/2^k) + k \cdot N
$$&lt;/div&gt;
&lt;p&gt;using &lt;span class="math"&gt;\(k = \log N\)&lt;/span&gt;, we obtain&lt;/p&gt;
&lt;div class="math"&gt;$$
T(N) = NT(1) + N \log N = N\log N + N
$$&lt;/div&gt;
&lt;div class="footnote"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;This recurrence relation is acutally a linear nonhomogeneous recurrence 
relation with constant coefficients. However, it cannot be solved by the method
I write up in the last post. I have no clue why. This recurrence relation is taken 
from MAW p243.&amp;#160;&lt;a class="footnote-backref" href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['CommonHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' }, Macros: {} }," +
        "    jax: ['input/TeX','input/MathML','output/CommonHTML']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Zeyuan Hu</dc:creator><pubDate>Mon, 12 Jun 2017 17:20:00 +0800</pubDate><guid isPermaLink="false">tag:zhu45.org,2017-06-12:posts/2017/Jun/12/solving-recurrence-relations-part-2/</guid><category>recursion</category><category>math</category></item><item><title>Draw a Neural Network through Graphviz</title><link>http://zhu45.org/posts/2017/May/25/draw-a-neural-network-through-graphviz/</link><description>&lt;h2 id="preface"&gt;Preface&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://graphviz.org/"&gt;Graphviz&lt;/a&gt; is a language (called DOT) and
a set of tools to automatically generate graphs. It is widely used
by researchers to do visualizations in papers. Essentially, you just
need to provide a textual descritption of the graph regarding its topological
structure (i.e. what nodes are, how they are connected, etc) and Graphviz will
figure out the layout of the image by itself. Usually, the generated layout works
out well but quite often, like this &lt;a href="https://hbfs.wordpress.com/2014/09/30/a-quick-primer-on-graphviz/"&gt;post&lt;/a&gt;
mentioned, can be a "finicky beast". So, I decide to share some tips I learned about
Graphviz.&lt;/p&gt;
&lt;p&gt;Specifically, in this post, I'll demonstrate how we can draw the Neural Network shown in the 
&lt;a href="http://zhu45.org/posts/2017/May/23/andrew-ngs-ml-week-04-05/"&gt;last post&lt;/a&gt; and use this as an example
to show some tricks in Graphviz to tweak the layout &lt;sup id="fnref:1"&gt;&lt;a class="footnote-ref" href="#fn:1" rel="footnote"&gt;1&lt;/a&gt;&lt;/sup&gt;. Let's get started!&lt;/p&gt;
&lt;h2 id="draw-a-neural-network"&gt;Draw a neural network&lt;/h2&gt;
&lt;p&gt;If you do a quick search regarding "graphviz neural network example", you'll highly
likely see the below picture:&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://zhu45.org/images/multiclass_neural_network_example.png" /&gt; &lt;/p&gt;
&lt;p&gt;This is probably the most simplest Graphviz demonstration on Neural Network. The
code for this picture can be obtained &lt;a href="https://gist.github.com/thigm85/5760134"&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;However, when I'm preparing my last post, I'm not quite satisified with the example above.
I want to clearly label all the nodes in all layers and make distinction among feature
input, bias term, hidden units, and output units. So, I decide to draw one on my own.&lt;/p&gt;
&lt;p&gt;Here is the &lt;a href="https://github.com/xxks-kkk/Code-for-blog/blob/master/2017/graphviz-drawings/nn3.dot"&gt;code&lt;/a&gt;
that generates the picture below &lt;sup id="fnref:2"&gt;&lt;a class="footnote-ref" href="#fn:2" rel="footnote"&gt;2&lt;/a&gt;&lt;/sup&gt;. Let me briefly
highlights some key points in the code:&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://zhu45.org/images/nn2.png" /&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;rankdir&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;LR&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;splines&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nb"&gt;false&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;edge&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;style&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;invis&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ol&gt;
&lt;li&gt;&lt;code&gt;rankdir=LR&lt;/code&gt; makes the directed graphs drawn from left to right.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;splines=false&lt;/code&gt; controls how the edges are represented and in this case, edges 
are drawn as line segments.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;edge[style=invis]&lt;/code&gt; forces edges to become invisible. This is a common trick to tweak
graphviz layout. &lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;node&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;shape&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;circle&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;color&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;yellow&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;style&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;filled&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;fillcolor&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;yellow&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
  &lt;span class="n"&gt;x0&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;label&lt;/span&gt;&lt;span class="o"&gt;=&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;sub&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="n"&gt;sub&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt; 
  &lt;span class="n"&gt;a02&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;label&lt;/span&gt;&lt;span class="o"&gt;=&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;sub&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="n"&gt;sub&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;sup&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="n"&gt;sup&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt; 
  &lt;span class="n"&gt;a03&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;label&lt;/span&gt;&lt;span class="o"&gt;=&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;sub&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="n"&gt;sub&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;sup&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="n"&gt;sup&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ol&gt;
&lt;li&gt;&lt;code&gt;node[...]&lt;/code&gt; sets the default node property: specify the node shape, node color. This
node property will apply to three nodes: &lt;code&gt;x0&lt;/code&gt;, &lt;code&gt;a02&lt;/code&gt;, &lt;code&gt;a03&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;x0 [label=&amp;lt;x&amp;lt;sub&amp;gt;0&amp;lt;/sub&amp;gt;&amp;gt;]&lt;/code&gt; specify the text label for node &lt;code&gt;x0&lt;/code&gt;. The text for label
is specified in &lt;a href="http://www.graphviz.org/doc/info/shapes.html#html"&gt;HTML-like&lt;/a&gt; and this is 
how we write subscript and superscript in Graphviz.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{...}&lt;/code&gt; specifies the scope of the node property. This code chunk as a whole shows
how we can specify several nodes at the once with the same node property &lt;sup id="fnref:3"&gt;&lt;a class="footnote-ref" href="#fn:3" rel="footnote"&gt;3&lt;/a&gt;&lt;/sup&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;rank&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;same&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;x0&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;x1&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;x2&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;x3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ol&gt;
&lt;li&gt;&lt;code&gt;rank=same&lt;/code&gt; is another trick I'll talk about later. This specifies what "layer"
(or "rank" by official term) a set of nodes belongs. You can read &lt;a href="http://www.graphviz.org/doc/info/attrs.html#d:rank"&gt;the official doc&lt;/a&gt; for the details.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;x0-&amp;gt;...-&amp;gt;x3&lt;/code&gt; specifies the relative position of the four nodes. Since the graph is
arranged from left to right (indicate by &lt;code&gt;rankdir = LR&lt;/code&gt;), then the "layer" is vertical.
Then by &lt;code&gt;x0-&amp;gt;...-&amp;gt;x3&lt;/code&gt;, the first node will be &lt;code&gt;x0&lt;/code&gt;, followed by &lt;code&gt;x1&lt;/code&gt;, and so on. Also,
we have &lt;code&gt;edge[style=invis]&lt;/code&gt; and this will hide the edges among these four nodes. This 
is how we draw the NN layers.&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;a02&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;a03&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ol&gt;
&lt;li&gt;This line is used to prevent tilting of the graph. As you can see, we specify
how the nodes should be arranged in a layer but we don't much constraint on how
the layers should be positioned except &lt;code&gt;rankdir=LR&lt;/code&gt;, which says layers should be 
ordered from left to right. &lt;code&gt;a02-&amp;gt;a03&lt;/code&gt; says layer with &lt;code&gt;a02&lt;/code&gt; should be lined up with 
layer with &lt;code&gt;a03&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;l0&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;shape&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;plaintext&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;label&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;layer 1 (input layer)&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="n"&gt;l0&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;x0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;rank&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;same&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;l0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="n"&gt;x0&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ol&gt;
&lt;li&gt;This code chunk is how we add label text to each layer. As you can see we use
another node &lt;code&gt;l0&lt;/code&gt; with shape &lt;code&gt;plaintext&lt;/code&gt;, which says &lt;code&gt;l0&lt;/code&gt; is just a text message.
Then we connect it with the first node of layer 1 &lt;code&gt;x0&lt;/code&gt;, which serves as attaching
the text to the layer 1.&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;edge&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;style&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;solid&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;tailport&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;headport&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;w&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ol&gt;
&lt;li&gt;We specify the edge style again. This will only affect the edges after this setup
not before. One small trick here is &lt;code&gt;tailport=e, headport=w&lt;/code&gt;. This will let all the edges
point to the same position.&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;x0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;x1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;x2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;x3&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;a12&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="n"&gt;a22&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="n"&gt;a32&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="n"&gt;a42&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="n"&gt;a52&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;a02&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="n"&gt;a12&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="n"&gt;a22&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="n"&gt;a32&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="n"&gt;a42&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="n"&gt;a52&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;a13&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="n"&gt;a23&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="n"&gt;a33&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="n"&gt;a43&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="n"&gt;a53&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;a03&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="n"&gt;a13&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="n"&gt;a23&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="n"&gt;a33&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="n"&gt;a43&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="n"&gt;a53&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;O1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;O2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;O3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;O4&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ol&gt;
&lt;li&gt;This code chunk is how we actually draw the edges. In the simple example above,
it explicitly draws the edges between two nodes. It is quite pain to do. Above code
chunk provides a simpler way to achieve the same purpose.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="graphviz-tricks"&gt;Graphviz tricks&lt;/h2&gt;
&lt;p&gt;From our NN drawing example, there are two recurring tricks when we tweak Graphviz 
picture layout:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Invisible nodes/edges&lt;/li&gt;
&lt;li&gt;Rank constraints&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="invisible-nodesedges"&gt;Invisible nodes/edges&lt;/h3&gt;
&lt;p&gt;In the above example, we use invisible edges to specify the ordering of nodes within
each NN layer. In addition, we use node with &lt;code&gt;plaintext&lt;/code&gt; shape to specify the text label
in the layer.&lt;/p&gt;
&lt;p&gt;Usually, we use invisible edges to specify what nodes should line up and sometimes
we use invisible nodes to take up space to keep the graph in a specific structure.
&lt;a href="https://stackoverflow.com/questions/7374108/graphviz-node-placement-and-rankdir"&gt;This SO post&lt;/a&gt;
demonstrates how we can use invisible nodes and edges in combination to create 
a fancy picture. 
&lt;a href="https://stackoverflow.com/questions/27091591/graphviz-dot-vertical-alignment-of-nodes"&gt;This SO post&lt;/a&gt;
is another example to show how to use "invisible edges" (it uses another trick called
&lt;code&gt;group&lt;/code&gt; attribute).&lt;/p&gt;
&lt;h3 id="rank-constraints"&gt;Rank constraints&lt;/h3&gt;
&lt;p&gt;If you check &lt;a href="http://www.graphviz.org/doc/info/attrs.html#d:rank"&gt;official doc&lt;/a&gt;,
here is what rank does:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Rank constraints on the nodes in a subgraph. If rank="same", 
all nodes are placed on the same rank. If rank="min", all nodes are placed on the minimum rank. 
If rank="source", all nodes are placed on the minimum rank, and the only nodes on the minimum 
rank belong to some subgraph whose rank attribute is "source" or "min". Analogous criteria hold 
for rank="max" and rank="sink". (Note: the minimum rank is topmost or leftmost, and the maximum 
rank is bottommost or rightmost.)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Let's demonstrate this description with a simple example &lt;sup id="fnref:4"&gt;&lt;a class="footnote-ref" href="#fn:4" rel="footnote"&gt;4&lt;/a&gt;&lt;/sup&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;digraph&lt;/span&gt; &lt;span class="n"&gt;G&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;rank&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;source&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;}&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;rank&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;same&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This example gives a graph with two rows. &lt;code&gt;a-&amp;gt;b&lt;/code&gt; is above &lt;code&gt;c-&amp;gt;d&lt;/code&gt;.
However, if I change &lt;code&gt;{rank=source; a-&amp;gt;b;}&lt;/code&gt; to &lt;code&gt;{rank=min; a-&amp;gt;b;}&lt;/code&gt;, we'll
end up with one row: &lt;code&gt;a-&amp;gt;b&lt;/code&gt; will be to the left of &lt;code&gt;c-&amp;gt;d&lt;/code&gt;. This is due to
the difference between &lt;code&gt;min&lt;/code&gt; and &lt;code&gt;source&lt;/code&gt;: &lt;code&gt;min&lt;/code&gt; allows other subgraphs in the
minimum rank. However, &lt;code&gt;source&lt;/code&gt; only allows other subgraphs of &lt;code&gt;min&lt;/code&gt; or &lt;code&gt;source&lt;/code&gt;
to be on the minimum rank (we have &lt;code&gt;same&lt;/code&gt; in this case).&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sink&lt;/code&gt; and &lt;code&gt;max&lt;/code&gt; works similarly. For instance, the below example gives a picture
with &lt;code&gt;c-&amp;gt;d&lt;/code&gt; at the top and &lt;code&gt;a-&amp;gt;b&lt;/code&gt; at the bottom:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;digraph&lt;/span&gt; &lt;span class="n"&gt;G&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;rank&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;sink&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;}&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;rank&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;same&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="footnote"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;Of course, Graphviz is not the only tool that can produce beautiful pictures. 
&lt;a href="http://www.texample.net/"&gt;TikZ&lt;/a&gt; is another popular tool. You can check out 
&lt;a href="http://www.texample.net/tikz/examples/neural-network/"&gt;its NN example&lt;/a&gt; for comparison.&amp;#160;&lt;a class="footnote-backref" href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:2"&gt;
&lt;p&gt;Technically, the code used to generate the blog NN picture is 
&lt;a href="https://github.com/xxks-kkk/Code-for-blog/blob/master/2017/graphviz-drawings/nn2.dot"&gt;this one&lt;/a&gt;
but the code I explained above is much more concise.&amp;#160;&lt;a class="footnote-backref" href="#fnref:2" rev="footnote" title="Jump back to footnote 2 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:3"&gt;
&lt;p&gt;Check out 
&lt;a href="https://stackoverflow.com/questions/28853898/groups-of-nodes-with-the-same-attributes-in-graphviz-file"&gt;this SO post&lt;/a&gt;
for more examples on grouping nodes with the same attributes.&amp;#160;&lt;a class="footnote-backref" href="#fnref:3" rev="footnote" title="Jump back to footnote 3 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:4"&gt;
&lt;p&gt;The example is adapted from &lt;a href="https://stackoverflow.com/questions/6149834/rank-attribute-is-confusing-to-me"&gt;this SO post&lt;/a&gt;.&amp;#160;&lt;a class="footnote-backref" href="#fnref:4" rev="footnote" title="Jump back to footnote 4 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Zeyuan Hu</dc:creator><pubDate>Thu, 25 May 2017 22:20:00 +0800</pubDate><guid isPermaLink="false">tag:zhu45.org,2017-05-25:posts/2017/May/25/draw-a-neural-network-through-graphviz/</guid><category>ml</category><category>graphviz</category></item><item><title>Andrew Ng's ML Week 04 - 05</title><link>http://zhu45.org/posts/2017/May/23/andrew-ngs-ml-week-04-05/</link><description>&lt;p&gt;Week 4 and 5 mainly talks about one important learning technique called "Neural Networks".
It is especially heplful when there are many features and hence, many combinations
for the &lt;a href="http://zhu45.org/posts/2017/May/05/andrew-ngs-ml-week-01-03/"&gt;linear or logistic regressions&lt;/a&gt;. 
Interestingly, I studied neural networks
&lt;a href="https://www.dropbox.com/s/hkym4s135amgmxv/HU.pdf?dl=0"&gt;previously&lt;/a&gt; 
when I was a student at college. It may feel different when we revisit old friend.&lt;/p&gt;
&lt;div class="toc"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#model"&gt;Model&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#representations"&gt;Representations&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#train-a-neural-network"&gt;Train a neural network&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#1-pick-a-network-architecture"&gt;1. Pick a network architecture&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#2-randomly-initialize-weights"&gt;2. Randomly initialize weights&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#3-forward-propagation"&gt;3. Forward propagation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#4-cost-function-jtheta"&gt;4. Cost function \(J(\theta)\)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#5-backpropagation"&gt;5. Backpropagation&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#implementation-details"&gt;Implementation details&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h2 id="model"&gt;Model&lt;/h2&gt;
&lt;h3 id="representations"&gt;Representations&lt;/h3&gt;
&lt;p&gt;Below picture shows a typical neural network (I'll use NN as a shorthand). &lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://zhu45.org/images/nn2.png" /&gt; &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;span class="math"&gt;\(L =\)&lt;/span&gt; total number of layers in network (i.e. &lt;span class="math"&gt;\(L = 4\)&lt;/span&gt; for the above NN)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span class="math"&gt;\(S_l =\)&lt;/span&gt; number of units (not counting bias unit) in layer &lt;span class="math"&gt;\(l\)&lt;/span&gt; 
(i.e., &lt;span class="math"&gt;\(S_1 = 3\)&lt;/span&gt;, &lt;span class="math"&gt;\(S_2 = S_3 = 5\)&lt;/span&gt;, &lt;span class="math"&gt;\(S_4 = S_L = 4\)&lt;/span&gt;)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span class="math"&gt;\(a_i^l =\)&lt;/span&gt; "activation" of unit &lt;span class="math"&gt;\(i\)&lt;/span&gt; in layer &lt;span class="math"&gt;\(l\)&lt;/span&gt;. In fact, input features
&lt;span class="math"&gt;\(x_0, x_1, x_2, x_3\)&lt;/span&gt; can also be represented as &lt;span class="math"&gt;\(a_0^{(1)}, a_1^{(1)}, a_1^{(2)}, a_1^{(3)}\)&lt;/span&gt;
respectively.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span class="math"&gt;\(\Theta^{(l)} =\)&lt;/span&gt; matrix of weights controlling function mapping from layer &lt;span class="math"&gt;\(l\)&lt;/span&gt; to layer &lt;span class="math"&gt;\(l+1\)&lt;/span&gt;.
For example,&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="math"&gt;$$
\Theta^{(1)} = \begin{bmatrix} 
\theta_{10}^{(1)} &amp;amp;&amp;amp; \theta_{11}^{(1)} &amp;amp;&amp;amp; \theta_{12}^{(1)} &amp;amp;&amp;amp; \theta_{13}^{(1)} \\
\theta_{20}^{(1)} &amp;amp;&amp;amp; \theta_{21}^{(1)} &amp;amp;&amp;amp; \theta_{22}^{(1)} &amp;amp;&amp;amp; \theta_{23}^{(1)} \\
\dots \\
\theta_{50}^{(1)} &amp;amp;&amp;amp; \theta_{51}^{(1)} &amp;amp;&amp;amp; \theta_{52}^{(1)} &amp;amp;&amp;amp; \theta_{53}^{(1)} \\
\end{bmatrix}
$$&lt;/div&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;Notation here may look confusing. One example to help understand is
&lt;span class="math"&gt;\(\theta_{10}^{1}\)&lt;/span&gt; means weight from &lt;span class="math"&gt;\(x_0\)&lt;/span&gt; in layer &lt;span class="math"&gt;\(1\)&lt;/span&gt; to &lt;span class="math"&gt;\(a_1\)&lt;/span&gt; in layer &lt;span class="math"&gt;\(2\)&lt;/span&gt;. In other words,
&lt;span class="math"&gt;\(\theta_{ji}^{l}\)&lt;/span&gt; means weight from &lt;span class="math"&gt;\(a_i^{l}\)&lt;/span&gt; to &lt;span class="math"&gt;\(a_j^{l+1}\)&lt;/span&gt;. Then the rows in the
matrix can be thought of as the weights from neurons in layer &lt;span class="math"&gt;\(l\)&lt;/span&gt; to corresponding &lt;span class="math"&gt;\(a_j\)&lt;/span&gt; in layer &lt;span class="math"&gt;\(l+1\)&lt;/span&gt; 
(i.e., 1st row in the above example means weights from layer &lt;span class="math"&gt;\(1\)&lt;/span&gt; to &lt;span class="math"&gt;\(a_1\)&lt;/span&gt; in layer &lt;span class="math"&gt;\(2\)&lt;/span&gt;). 
Explicitly, the number of columns in our current theta matrix is equal to the number of 
nodes in our current layer (including the bias unit). The number of rows is equal to the number
of nodes in the next layer (excluding the bias unit).&lt;/p&gt;
&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class="math"&gt;\(K =\)&lt;/span&gt; number of neurons in the output layer (i.e. &lt;span class="math"&gt;\(S_L = K\)&lt;/span&gt;). In other words, &lt;span class="math"&gt;\(K\)&lt;/span&gt; represents the number of classes
in multi-class classification. This indicates that &lt;span class="math"&gt;\(h_\theta(x) = \mathbb{R}^K\)&lt;/span&gt;. &lt;/li&gt;
&lt;/ul&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;Usually, in our training sets {&lt;span class="math"&gt;\((x^{(1)}, y^{(1)}), \dots, (x^{(m)}, y^{(m)})\)&lt;/span&gt;}, we are given actual label (i.e. 
&lt;span class="math"&gt;\(y^{(9)} = 10\)&lt;/span&gt; for handwritten digit recognition). However, we need to transform those labels into &lt;span class="math"&gt;\(\mathbb{R}^k\)&lt;/span&gt; by doing,for 
instance, create &lt;span class="math"&gt;\(\mathbb{R}^{10}\)&lt;/span&gt; vector with last position being &lt;span class="math"&gt;\(1\)&lt;/span&gt; and rest being &lt;span class="math"&gt;\(0\)&lt;/span&gt;
as the representation for &lt;span class="math"&gt;\(y^{(9)} = 10\)&lt;/span&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;With the above notations, we have the following property:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;If NN has &lt;span class="math"&gt;\(S_l\)&lt;/span&gt; units in layer &lt;span class="math"&gt;\(l\)&lt;/span&gt;, &lt;span class="math"&gt;\(S_{l+1}\)&lt;/span&gt; units in layer &lt;span class="math"&gt;\(l+1\)&lt;/span&gt;, then &lt;span class="math"&gt;\(\Theta^{(l)}\)&lt;/span&gt; will be dimension 
&lt;span class="math"&gt;\(S_{l+1} \times (S_l + 1)\)&lt;/span&gt;. &lt;span class="math"&gt;\(+1\)&lt;/span&gt; comes from the bias unit (shown in yellow in above NN picture). &lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="train-a-neural-network"&gt;Train a neural network&lt;/h3&gt;
&lt;h4 id="1-pick-a-network-architecture"&gt;1. Pick a network architecture&lt;/h4&gt;
&lt;p&gt;The first step is to pick a network architecture. Specifically, the connectivity patterns between neurons. Prof. Ng 
says a reasonable default is to either have &lt;span class="math"&gt;\(1\)&lt;/span&gt; hidden layer, or if &lt;span class="math"&gt;\(&amp;gt;1\)&lt;/span&gt; hidden layer, have the same number of 
hidden units in every layer. Usually, the more hidden units the better. &lt;/p&gt;
&lt;h4 id="2-randomly-initialize-weights"&gt;2. Randomly initialize weights&lt;/h4&gt;
&lt;p&gt;Zero initialization is considered bad for NN (i.e. &lt;span class="math"&gt;\(\theta_{ij}^{l} = 0\)&lt;/span&gt; for all &lt;span class="math"&gt;\(i,j,l\)&lt;/span&gt;) because our activation output and
gradient will all be identical and essentially we comput one feature in this network. That's why we need to randomly 
initialize the weights for symmetry breaking. &lt;/p&gt;
&lt;p&gt;One effective strategy is to randomly select values for &lt;span class="math"&gt;\(\theta_{ij}^{l}\)&lt;/span&gt; uniformly in the range 
[&lt;span class="math"&gt;\(-\epsilon_\text{init}\)&lt;/span&gt;,&lt;span class="math"&gt;\(\epsilon_\text{init}\)&lt;/span&gt;]. We can choose &lt;span class="math"&gt;\(\epsilon_\text{init}\)&lt;/span&gt; based upon
the number of units in the network. A good choice of &lt;span class="math"&gt;\(\epsilon_\text{init}\)&lt;/span&gt; is 
&lt;span class="math"&gt;\(\epsilon_\text{init} = \frac{\sqrt{6}}{\sqrt{L_\text{in} + L_\text{out}}}\)&lt;/span&gt;, where
&lt;span class="math"&gt;\(L_\text{in} = S_l\)&lt;/span&gt; and &lt;span class="math"&gt;\(L_\text{out} = S_{l+1}\)&lt;/span&gt;, which are the the number of units
in the layers adjacent to &lt;span class="math"&gt;\(\Theta^{(l)}\)&lt;/span&gt;. Take above NN as an example, our 
&lt;span class="math"&gt;\(\epsilon_\text{init}\)&lt;/span&gt; will be &lt;span class="math"&gt;\(0.87\)&lt;/span&gt;, which is calculated from &lt;span class="math"&gt;\(\frac{\sqrt{6}}{\sqrt{3+5}}\)&lt;/span&gt;. &lt;sup id="fnref:3"&gt;&lt;a class="footnote-ref" href="#fn:3" rel="footnote"&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;h4 id="3-forward-propagation"&gt;3. Forward propagation&lt;/h4&gt;
&lt;p&gt;The next step we need to do is to use forward propagation to get &lt;span class="math"&gt;\(h_\theta(x^{(i)})\)&lt;/span&gt; for any &lt;span class="math"&gt;\(x^{(i)}\)&lt;/span&gt;.
Let's use above NN as an example to demonstrate how forward propagation is done. There are
&lt;span class="math"&gt;\(4\)&lt;/span&gt; output units in the output layer and thus, our &lt;span class="math"&gt;\(h_\theta(x^{(i)})\)&lt;/span&gt; looks like&lt;/p&gt;
&lt;div class="math"&gt;$$
h_\theta(x^{(i)}) = \begin{bmatrix}
a_1^{(4)} \\
a_2^{(4)} \\
a_3^{(4)} \\
a_4^{(4)} \\
\end{bmatrix}
$$&lt;/div&gt;
&lt;p&gt;The general idea for the forward propagation is that we take in the input from previous 
layer, and multiply with our weights, and then apply our sigmoid function to get the
activation value for the current layer. We start with the input layer and do this 
iteratively until we get to output layer, which its activation value will be our 
&lt;span class="math"&gt;\(h_\theta(x^{(i)})\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;Concretely, let's first represent our input layer (with bias term) as  &lt;span class="math"&gt;\(x\)&lt;/span&gt; and 
define a new variable &lt;span class="math"&gt;\(z^{(j)}\)&lt;/span&gt; as following:&lt;/p&gt;
&lt;div class="math"&gt;$$
\begin{align*}
&amp;amp; x = \begin{bmatrix} x_0 \\ x_1 \\ \dots \\ x_n \end{bmatrix}
&amp;amp;&amp;amp;
z^{(j)} = \begin{bmatrix} z_1^{(j)} \\ z_2^{(j)} \\ \dots \\ z_n^{(j)} \end{bmatrix}
\end{align*}
$$&lt;/div&gt;
&lt;p&gt;Then, we can calculate the activation value &lt;span class="math"&gt;\(a^{(j)}\)&lt;/span&gt; for the layer j as follows
(treating &lt;span class="math"&gt;\(x = a^{(1)}\)&lt;/span&gt;):&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Add bias term &lt;span class="math"&gt;\(a_0^{(j-1)} = 1\)&lt;/span&gt; to &lt;span class="math"&gt;\(a^{(j-1)}\)&lt;/span&gt; and our new &lt;span class="math"&gt;\(a^{(j-1)}\)&lt;/span&gt; looks like &lt;/p&gt;
&lt;p&gt;
&lt;div class="math"&gt;$$
a^{(j-1)} = \begin{bmatrix} a_0^{(j-1)} \\ a_1^{(j-1)} \\ \dots \\ a_n^{(j-1)} \end{bmatrix}
$$&lt;/div&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Calculate &lt;span class="math"&gt;\(z^{(j)}\)&lt;/span&gt; as follows:&lt;/p&gt;
&lt;p&gt;
&lt;div class="math"&gt;$$
z^{(j)} = \Theta^{(j-1)}a^{(j-1)}
$$&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;Here, &lt;span class="math"&gt;\(\Theta^{(j-1)}\)&lt;/span&gt; has dimension &lt;span class="math"&gt;\(S_j \times (S_{j-1} + 1)\)&lt;/span&gt; and &lt;span class="math"&gt;\(a^{(j-1)}\)&lt;/span&gt; has 
dimension &lt;span class="math"&gt;\((S_{j-1} + 1) \times 1\)&lt;/span&gt;. Then, our vector &lt;span class="math"&gt;\(z^{(j)}\)&lt;/span&gt; has height &lt;span class="math"&gt;\(S_j\)&lt;/span&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;We get a vector of our activation nodes for layer &lt;span class="math"&gt;\(j\)&lt;/span&gt; as follows:&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="math"&gt;$$
a^{(j)} = g(z^{(j)})
$$&lt;/div&gt;
&lt;p&gt;We repeat these three steps and get &lt;span class="math"&gt;\(h_\theta(x^{(i)})\)&lt;/span&gt;, which in our NN is the activation
value &lt;span class="math"&gt;\(a^{(4)}\)&lt;/span&gt; for &lt;span class="math"&gt;\(i\)&lt;/span&gt;-th training example. &lt;/p&gt;
&lt;p&gt;One key intuition for forward propagation is that the whole process is just like logistic
regression except that rather than using original feature &lt;span class="math"&gt;\(x_1, x_2, \dots, x_n\)&lt;/span&gt;, it uses
new features &lt;span class="math"&gt;\(a^{(L-1)}\)&lt;/span&gt;, which are learned by the NN itself.&lt;/p&gt;
&lt;h4 id="4-cost-function-jtheta"&gt;4. Cost function &lt;span class="math"&gt;\(J(\theta)\)&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;Now we need to compute the cost function &lt;span class="math"&gt;\(J(\theta)\)&lt;/span&gt; of the NN in order to minimize
the classification error with the given data. Since NN shares a lot similarity with
the logistic regression, it's no hard to imagine that the NN's cost function &lt;span class="math"&gt;\(J(\theta)\)&lt;/span&gt;
shares the similar form with the logistic regression's cost function:&lt;/p&gt;
&lt;div class="math"&gt;$$
J(\theta) = - \frac{1}{m} [ \sum_{i=1}^m \sum_{k=1}^K y_k^{(i)} \log h_\theta(x^{(i)})_k + 
(1 - y_k^{(i)}) \log(1-h_\theta(x^{(i)})_k)] + \frac{\lambda}{2m} 
\sum_{l=1}^{L-1}\sum_{i=1}^{S_l}\sum_{j=1}^{S_l+1}(\theta_{ji}^{(l)})^2
$$&lt;/div&gt;
&lt;p&gt;Here, &lt;span class="math"&gt;\(h_\theta(x^{(i)})_k\)&lt;/span&gt; means the &lt;span class="math"&gt;\(k\)&lt;/span&gt;th output in the output layer. The second part of 
the equation summs over all the weights &lt;span class="math"&gt;\(\theta_{ji}^{(l)}\)&lt;/span&gt; except the bias term (i.e. &lt;span class="math"&gt;\(i=0\)&lt;/span&gt;).&lt;/p&gt;
&lt;h4 id="5-backpropagation"&gt;5. Backpropagation&lt;/h4&gt;
&lt;p&gt;Once we have the cost function, our next step is to find the derivative terms 
&lt;span class="math"&gt;\(\frac{\partial J(\theta)}{\partial \theta_{ij}^{(l)}}\)&lt;/span&gt; for every &lt;span class="math"&gt;\(i,k,l\)&lt;/span&gt; in order to use various octave 
built-in method (i.e. &lt;code&gt;fminunc&lt;/code&gt;) to minimize &lt;span class="math"&gt;\(J(\theta)\)&lt;/span&gt; as a function of &lt;span class="math"&gt;\(\theta\)&lt;/span&gt;. We use backpropagation to do this.&lt;/p&gt;
&lt;p&gt;The intuition for the backpropagation is the following: given a training example &lt;span class="math"&gt;\((x^{(i)}, y^{(i)})\)&lt;/span&gt;, we will
first run forward propagation to compute all the activiations throughout the network, including the output units.
Then, for each node &lt;span class="math"&gt;\(j\)&lt;/span&gt; in layer &lt;span class="math"&gt;\(l\)&lt;/span&gt;, we would like to compute an "error term" &lt;span class="math"&gt;\(\delta_j^{(l)}\)&lt;/span&gt; that measures how
much that node was "responsible" for any errors in our output. For an output node, we can directly measure the
difference between the network's activation and the true target value, and use that to define &lt;span class="math"&gt;\(\delta_j^{(L)}\)&lt;/span&gt;.
For the hidden units, we can compute &lt;span class="math"&gt;\(\delta_j^{l}\)&lt;/span&gt; based on a weighted average of the error terms of the nodes in layer
&lt;span class="math"&gt;\((l+1)\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;Here is the algorithm in details:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Given training set {&lt;span class="math"&gt;\((x^{(1)}, y^{(1)}), \dots, (x^{(m)}, y^{(m)})\)&lt;/span&gt;}&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Set &lt;span class="math"&gt;\(\Delta_{ij}^{(l)} = 0\)&lt;/span&gt; (for all &lt;span class="math"&gt;\(i,l,j\)&lt;/span&gt;)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;For i=1:m,&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;perform &lt;a href="#3-forward-propagation"&gt;forward propagation&lt;/a&gt; to compute &lt;span class="math"&gt;\(a^{(l)}\)&lt;/span&gt; for &lt;span class="math"&gt;\(l = 2, 3, \dots, L\)&lt;/span&gt; &lt;/li&gt;
&lt;li&gt;using &lt;span class="math"&gt;\(y^{(i)}\)&lt;/span&gt;, compute &lt;span class="math"&gt;\(\delta^{(L)} = a^{(L)} - y^{(i)}\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;compute &lt;span class="math"&gt;\(\delta^{(L-1)}, \delta^{(L-2)}, \dots, \delta^{(2)}\)&lt;/span&gt; using 
&lt;span class="math"&gt;\(\delta^{(l)} = ((\Theta^{(l)})^T \delta^{(l+1)}).\ast a^{(l)}.\ast (1-a^{(l)})\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(\Delta_{ij}^{(l)} := \Delta_{ij}^{(l)} + a_j^{(l)}\delta_i^{(l+1)}\)&lt;/span&gt;
   (Vectorized form is &lt;span class="math"&gt;\(\Delta^{(l)} := \Delta^{(l)} + \delta^{(l+1)}(a^{(l)})^T\)&lt;/span&gt;)&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span class="math"&gt;\(D_{ij}^{(l)} := \frac{1}{m}\Delta_{ij}^{(m)} + \frac{\lambda}{m}\theta_{ij}^{(l)} \text{ if } j \ne 0\)&lt;/span&gt; and
&lt;span class="math"&gt;\(D_{ij}^{(l)} := \frac{1}{m}\Delta_{ij}^{(m)} \text{ if } j = 0\)&lt;/span&gt;. &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span class="math"&gt;\(\frac{\partial J(\theta)}{\partial \theta_{ij}^{(l)}} = D_{ij}^{(l)}\)&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Intuitvely, backpropagation algorithm is alot like forward propagation running backward. We can then use gradient
descent or advanced optimization method to try to minimize &lt;span class="math"&gt;\(J(\theta)\)&lt;/span&gt; as a function of parameters &lt;span class="math"&gt;\(\theta\)&lt;/span&gt; &lt;sup id="fnref:5"&gt;&lt;a class="footnote-ref" href="#fn:5" rel="footnote"&gt;2&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;Notice that we don't compute &lt;span class="math"&gt;\(\delta_{(1)}\)&lt;/span&gt; because &lt;span class="math"&gt;\(\delta_{(1)}\)&lt;/span&gt; is associated with the input layer, which are
features we observed from the training examples. So, there are no "error" involved. In addition, &lt;span class="math"&gt;\(.\ast\)&lt;/span&gt; means we 
do element-wise multiplication in octave.&lt;/p&gt;
&lt;/div&gt;
&lt;h2 id="implementation-details"&gt;Implementation details&lt;/h2&gt;
&lt;p&gt;Week 5's programming assignment on NN learning is the most challenging one I have met so far in this course. Initially, 
I plan to go through lots of details in terms of implementation in this section. However, after I finish the model
section above and take a look at the assignment code again, I realize that the algorithms described above reflect
fair accurately on how the code should be written. &lt;/p&gt;
&lt;p&gt;However, there is one point I want to emphasize &lt;span class="math"&gt;\(a^{(1)}\)&lt;/span&gt; is a vector with dimension &lt;span class="math"&gt;\(n \times 1\)&lt;/span&gt;. This is important
if you want to apply the algorithms exactly. When I first coded the program, my &lt;span class="math"&gt;\(a^{(1)}\)&lt;/span&gt; is a row vector with dimension
&lt;span class="math"&gt;\(1 \times n\)&lt;/span&gt;, which causes me much trouble for the rest of implementations.&lt;/p&gt;
&lt;p&gt;&lt;span class="math"&gt;\(\Delta^{(l)} := \Delta^{(l)} + \delta^{(l+1)}(a^{(l)})^T\)&lt;/span&gt; looks confusing for me as well 
for the first time. My question is how many &lt;span class="math"&gt;\(\Delta^{(l)}\)&lt;/span&gt; are there. My trick is to take 
a look at the last term of the equation. &lt;span class="math"&gt;\(\delta^{(l+1)}(a^{(l)})^T\)&lt;/span&gt; indicates that &lt;span class="math"&gt;\(\Delta^{(l)}\)&lt;/span&gt;
starts with the second last layer and there is one until input layer (including).
So, in our NN above, there are three &lt;span class="math"&gt;\(\Delta^{(l)}\)&lt;/span&gt; we should update. &lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn:3"&gt;
&lt;p&gt;Here, it is unclear for me which two layers we should choose to calculate 
&lt;span class="math"&gt;\(\epsilon_\text{init}\)&lt;/span&gt;. In the &lt;a href="https://github.com/xxks-kkk/Code-for-blog/tree/master/2017/andrew-ng-ml/machine-learning-ex4/ex4"&gt;programming assignment 4&lt;/a&gt;,
the value is calculated from the layer 1 (input layer) and layer 2 (1st hidden layer).&amp;#160;&lt;a class="footnote-backref" href="#fnref:3" rev="footnote" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:5"&gt;
&lt;p&gt;You can use &lt;a href="https://github.com/xxks-kkk/Code-for-blog/blob/master/2017/andrew-ng-ml/machine-learning-ex4/ex4/computeNumericalGradient.m"&gt;gradient checking&lt;/a&gt; 
to verify if the backpropagation is implemented correctly. &amp;#160;&lt;a class="footnote-backref" href="#fnref:5" rev="footnote" title="Jump back to footnote 2 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['CommonHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' }, Macros: {} }," +
        "    jax: ['input/TeX','input/MathML','output/CommonHTML']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Zeyuan Hu</dc:creator><pubDate>Tue, 23 May 2017 22:20:00 +0800</pubDate><guid isPermaLink="false">tag:zhu45.org,2017-05-23:posts/2017/May/23/andrew-ngs-ml-week-04-05/</guid><category>ml</category><category>coursera</category></item><item><title>Andrew Ng's ML Week 01 - 03</title><link>http://zhu45.org/posts/2017/May/05/andrew-ngs-ml-week-01-03/</link><description>&lt;div class="toc"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#ml-overview"&gt;ML overview&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#what-is-ml"&gt;What is ML?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#types-of-ml-problems"&gt;Types of ML problems&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#notation"&gt;Notation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#linear-regression"&gt;Linear regression&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#in-theory"&gt;In theory&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#in-practice"&gt;In practice&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#linear-regression-with-regularization"&gt;Linear regression with regularization&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#in-theory_1"&gt;In theory&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#in-practice_1"&gt;In practice&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#logistic-regression"&gt;Logistic regression&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#in-theory_2"&gt;In theory&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#in-practice_2"&gt;In practice&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#logistic-regression-with-regularization"&gt;Logistic regression with regularization&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#in-theory_3"&gt;In theory&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#in-practice_3"&gt;In practice&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;p&gt;In my &lt;a href="http://zhu45.org/posts/2017/Apr/21/introducing-the-andrew-ngs-ml-course-study-notes/"&gt;introducing post&lt;/a&gt;, I mention that
I decide to write summary post weekly for the course. However, in practice, I find
it is very hard to do. This is mainly because I want to keep the progress in MAW 
reading while meet the coursework deadlines. So, I decide to do the summary post
based upon the module of the material itself.&lt;/p&gt;
&lt;p&gt;In addition, like MAW reading posts, I will focus on the reflection and the post itself
may not be self-contained. However, this may happen rarely.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Coursera has really well-designed programming assignment that really helps to understand
both concepts and its actual implementation. All the code snippets listed in the below
and upcoming posts are availabe &lt;a href="https://github.com/xxks-kkk/Code-for-blog/tree/master/2017/andrew-ng-ml"&gt;in my code-for-blog repo&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="ml-overview"&gt;ML overview&lt;/h2&gt;
&lt;h3 id="what-is-ml"&gt;What is ML?&lt;/h3&gt;
&lt;p&gt;The biggest take-away for me is that ML is to solve the problems that
cannot be easily solved by the programming. As mentioned by Prof. Andrew, we
know how to program the shortest path from A to B but we may have hard time
to program a solution to do image tagging, email spam checking, and so on.
The way we solve those problems is by teaching computers to do things like us
through learning algorithms.&lt;/p&gt;
&lt;p&gt;There are a lot of examples about ML mentioned in the video:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Database mining: large datasets from growth of automation/web (i.e. web click data,
medical records, biology, engineering)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Applications can't program by hand. (i.e. autonomous helicopter, 
handwriting recognition, most of NLP, CV)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Self-customizing programs (i.e. Amazon, Netflix product recommendations)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Understanding human learning (brain, real AI)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;There are two definitions for ML: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Arthur Samuel: the field of study that gives computers the ability to learn
without being explicitly programmed. (older, informal definition)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Tom Mitchell: A computer program is said to learn from experience &lt;span class="math"&gt;\(E\)&lt;/span&gt; with respect
to some class of tasks &lt;span class="math"&gt;\(T\)&lt;/span&gt; and performance measure &lt;span class="math"&gt;\(P\)&lt;/span&gt;, if its performance at tasks in &lt;span class="math"&gt;\(T\)&lt;/span&gt;,
as measured by &lt;span class="math"&gt;\(P\)&lt;/span&gt;, improves with experience &lt;span class="math"&gt;\(E\)&lt;/span&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Take playing checkers as an example. &lt;span class="math"&gt;\(E = \text{the experience of playing many games of checkers}\)&lt;/span&gt;;
&lt;span class="math"&gt;\(T = \text{the task of playing checkers}\)&lt;/span&gt;; &lt;span class="math"&gt;\(P = \text{the probability that the program will win the next game}\)&lt;/span&gt;.&lt;/p&gt;
&lt;h3 id="types-of-ml-problems"&gt;Types of ML problems&lt;/h3&gt;
&lt;p&gt;There are two general types:  Supervised learning and Unsupervised learning.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Supervised learning: 'right' answer given&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Regression: predict continuous valued output&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;EX1: given data about the size of houses on the real estate market, try to predict their price.&lt;/li&gt;
&lt;li&gt;EX2: given a picture of a person, we predict their age on the basis of the given picture.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Classification: predict results in a discrete output (categories)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;EX1: predict whether the house sells for more or less than the asking price.&lt;/li&gt;
&lt;li&gt;EX2: given a patient with a tumor, we predict whether the tumor is malignant or benign.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Unsupervised learning: little or no idea what our resuls should look like. We can
derive structure from data where we don't necessarily know the effect of the variables.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Clustering: take a collection of 1,000,000 different genes, and find a way to automatically group
these genes into groups that are somehow similar or related by different variables (i.e. lifespan, location, roles)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Non-clustering: the "cocktail party algorithm" allows you to find structure in a 
chaotic environment (i.e. identifying individual voices and music from a mesh of sounds at a cocktail party)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Other application fields: organize computing clusters, social network analysis, market segmentation, 
astronomical data analysis&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="notation"&gt;Notation&lt;/h2&gt;
&lt;p&gt;A few notation used throughout the course:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class="math"&gt;\(n = \text{number of features}\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(m = \text{number of training examples}\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(x^{(i)} = \text{input (features) of }i\text{th training example}\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(x_j^{(i)} = \text{value of feature }j \text{ in }i\text{th training example}\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="linear-regression"&gt;Linear regression&lt;/h2&gt;
&lt;h3 id="in-theory"&gt;In theory&lt;/h3&gt;
&lt;p&gt;For linear regression, our hypothesis is &lt;/p&gt;
&lt;div class="math"&gt;$$
h_\theta(x) = \theta_0 x_0 + \theta_1 x_1 + \dots + \theta_n x_n = \theta^T x  
$$&lt;/div&gt;
&lt;p&gt;where &lt;/p&gt;
&lt;div class="math"&gt;$$
\begin{align}
&amp;amp; x = \begin{bmatrix} x_0 \\ x_1 \\ \vdots \\ x_n \end{bmatrix} \in \mathbb{R} ^{n+1}  \label{eq:1} &amp;amp;
&amp;amp; \theta = \begin{bmatrix} \theta_0 \\ \theta_1 \\ \vdots \\ \theta_n \end{bmatrix} \in \mathbb{R} ^{n+1}
\end{align}
$$&lt;/div&gt;
&lt;p&gt;and our cost function is &lt;/p&gt;
&lt;div class="math"&gt;$$
\begin{equation}
J(\theta) = \frac{1}{2m} \sum_{i=1}^m(\theta^T x^{(i)}-y(i))^2 \label{eq:2}
\end{equation}
$$&lt;/div&gt;
&lt;p&gt;In order to find &lt;span class="math"&gt;\(\theta\)&lt;/span&gt; that minimizes our cost function &lt;span class="math"&gt;\(J(\theta)\)&lt;/span&gt;. Two methods are available for us:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Gradient Descent&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="math"&gt;$$
\begin{align} 
\text{Repeat\{ } &amp;amp;&amp;amp;  \nonumber\\
&amp;amp;&amp;amp; \theta_j := \theta_j - \alpha \times \frac{1}{m} \sum_{i=1}^m(h_\theta(x^{(i)})-y^{(i)})x_j^{(i)} &amp;amp;&amp;amp;
\text{(simultaneously update $\theta_j$ for $j = 0, 1, \dots, n$)}  \label{eq:3}\\
\text{\}} \nonumber
\end{align}
$$&lt;/div&gt;
&lt;p&gt;&lt;span class="math"&gt;\(\alpha\)&lt;/span&gt; is called learning rate, which determines "the step we take downhill" and the part afterwards decides
which direction we want to go (derived by taking partial derivatives against &lt;span class="math"&gt;\(\theta_j\)&lt;/span&gt;)&lt;sup id="fnref:1"&gt;&lt;a class="footnote-ref" href="#fn:1" rel="footnote"&gt;1&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Normal Equation&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We just directly calculate the partial derivatives for every &lt;span class="math"&gt;\(\theta_j\)&lt;/span&gt; and set it equals to zero 
(i.e &lt;span class="math"&gt;\(\frac{\partial}{\partial \theta_j}J(\theta) = 0\)&lt;/span&gt; for every &lt;span class="math"&gt;\(j\)&lt;/span&gt;) and we get:&lt;/p&gt;
&lt;div class="math"&gt;$$
\begin{equation}
\theta = (X^TX)^{-1}X^Ty \label{eq:4}
\end{equation}
$$&lt;/div&gt;
&lt;p&gt;where &lt;span class="math"&gt;\(X\)&lt;/span&gt; is called &lt;em&gt;design matrix&lt;/em&gt;, and it has form&lt;/p&gt;
&lt;div class="math"&gt;$$
\begin{align*} 
&amp;amp; X = \left[\begin{array}{ccc} - &amp;amp; (x^{(1)})^T &amp;amp; - \\ - &amp;amp; (x^{(2)})^T &amp;amp; - \\ &amp;amp; \vdots &amp;amp; \\ - &amp;amp; (x^{(m)})^T &amp;amp; -\end{array} \right] &amp;amp;
x^{(i)} = \begin{bmatrix}x_0^{(i)} \\ \vdots \\ x_n^{(i)} \end{bmatrix} \in \mathbb{R} ^{n+1}
\end{align*}
$$&lt;/div&gt;
&lt;h3 id="in-practice"&gt;In practice&lt;/h3&gt;
&lt;p&gt;One tricky thing I find out when I work through quiz and programming problems 
is the gap between the mathematical representation and the actual implementation.&lt;/p&gt;
&lt;p&gt;For the cost function \ref{eq:2}, we implement it in Octave as following:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;J&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;theta&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;theta&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;where &lt;/p&gt;
&lt;div class="math"&gt;$$
X = \begin{bmatrix} 
x_0^{(1)} &amp;amp;&amp;amp; x_1^{(1)} &amp;amp;&amp;amp; \dots &amp;amp;&amp;amp; x_n^{(1)} \\
x_0^{(2)} &amp;amp;&amp;amp; x_1^{(2)} &amp;amp;&amp;amp; \dots &amp;amp;&amp;amp; x_n^{(2)} \\
\vdots \\
x_0^{(m)} &amp;amp;&amp;amp; x_1^{(m)} &amp;amp;&amp;amp; \dots &amp;amp;&amp;amp; x_n^{(m)}
\end{bmatrix}
$$&lt;/div&gt;
&lt;p&gt;Note that &lt;span class="math"&gt;\(X\)&lt;/span&gt; here is different from \ref{eq:1} because &lt;span class="math"&gt;\(X\)&lt;/span&gt; here is to faciltate
the vectorized cost function calculation in program (i.e Octave) and it is natural
fit with how the data actually loaded into the program.&lt;/p&gt;
&lt;p&gt;Also, if you take a look at our octave calculation above, we explictly avoid doing
summation in \ref{eq:2}. We can put both vectorized form used in octave and mathematical
definition side by side to see the pattern:&lt;/p&gt;
&lt;div class="math"&gt;$$
J(\theta) = \frac{1}{2m}(X\theta-y)^T(X\theta-y) = \frac{1}{2m} \sum_{i=1}^m(\theta^T x^{(i)}-y(i))^2
$$&lt;/div&gt;
&lt;p&gt;Matrix transpose times matrix itself is a commonly-seen technique that is used to
avoid explictly summation.&lt;/p&gt;
&lt;p&gt;For gradient descent, we can calculate like the following in octave:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;theta&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;theta&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;alpha&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="o"&gt;&amp;#39;*&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;theta&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Let me use an example to illustrate why we can calculate \ref{eq:3} like above.
Suppose &lt;span class="math"&gt;\(m = 4\)&lt;/span&gt; with &lt;span class="math"&gt;\(h_\theta(x) = \theta_0x_0+\theta_1x_1\)&lt;/span&gt;.
Then, we have&lt;/p&gt;
&lt;div class="math"&gt;$$
\begin{align*} 
X = \begin{bmatrix}
x_0^{(1)} &amp;amp;&amp;amp; x_1^{(1)} \\
x_0^{(2)} &amp;amp;&amp;amp; x_1^{(2)} \\
x_0^{(3)} &amp;amp;&amp;amp; x_1^{(3)} \\
x_0^{(4)} &amp;amp;&amp;amp; x_1^{(4)} \\
\end{bmatrix} &amp;amp;&amp;amp;
\theta = \begin{bmatrix} \theta_0 \\ \theta_1 \end{bmatrix} &amp;amp;&amp;amp;
h_\theta(x^{(i)}) - y^{(i)} = \begin{bmatrix}
\theta_0 + \theta_1x_1^{(1)} - y^{(1)} \\
\vdots \\
\theta_0 + \theta_1x_1^{(4)} - y^{(4)}
\end{bmatrix}
\end{align*}
$$&lt;/div&gt;
&lt;p&gt;so now we can show why:&lt;/p&gt;
&lt;div class="math"&gt;$$
\begin{eqnarray*}
\sum_{i=1}^{m}(h_\theta(x^{(i)})-y^{(i)})x_j^{(i)} \text{ for all $j$ } &amp;amp;=&amp;amp;
(\theta_0 + \theta_1x_1^{(1)} - y^{(1)}) \begin{bmatrix} x_0^{(1)} \\ x_1^{(1)} \end{bmatrix} + 
\dots + (\theta_0 + \theta_1x_1^{(4)} - y^{(4)}) \begin{bmatrix} x_0^{(4)} \\ x_1^{(4)} \end{bmatrix} \\
&amp;amp;=&amp;amp; \begin{bmatrix} x_0^{(1)} &amp;amp;&amp;amp; x_0^{(2)} &amp;amp;&amp;amp; x_0^{(3)} &amp;amp;&amp;amp; x_0^{(4)} \\
x_1^{(1)} &amp;amp;&amp;amp; x_1^{(2)} &amp;amp;&amp;amp; x_1^{(3)} &amp;amp;&amp;amp; x_1^{(4)}
\end{bmatrix} 
\begin{bmatrix}
\theta_0 + \theta_1x_1^{(1)} - y^{(1)} \\
\vdots \\
\theta_0 + \theta_1x_1^{(4)} - y^{(4)}
\end{bmatrix}
\end{eqnarray*}
$$&lt;/div&gt;
&lt;p&gt;For normal equation, we can calculate like the following in octave:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;theta&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;pinv&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="o"&gt;&amp;#39;*&lt;/span&gt;&lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="o"&gt;&amp;#39;*&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This is no different than \ref{eq:4} we mentioned above.&lt;/p&gt;
&lt;h2 id="linear-regression-with-regularization"&gt;Linear regression with regularization&lt;/h2&gt;
&lt;p&gt;Quite often, we may face &lt;em&gt;overfitting&lt;/em&gt; issue, which can be fixed by either reduce number of features or
regularization.&lt;/p&gt;
&lt;p&gt;Regularization is to keep all the features, but reduce magnitude (values) of parameters &lt;span class="math"&gt;\(\theta_j\)&lt;/span&gt;. By
doing so, we can make our hypothesis simpler and less prone to overfitting.&lt;/p&gt;
&lt;h3 id="in-theory_1"&gt;In theory&lt;/h3&gt;
&lt;p&gt;With regularization, our new cost function becomes &lt;/p&gt;
&lt;div class="math"&gt;$$
J(\theta) = \frac{1}{2m}\Big[ \sum_{i=1}^m (h_\theta(x^{(i)}) - y^{(i)})^2 + 
\underbrace{\lambda \sum_{j=1}^n \theta_j^2\Big]}_\textrm{regularization term}
$$&lt;/div&gt;
&lt;p&gt;The regularization parameter &lt;span class="math"&gt;\(\lambda\)&lt;/span&gt; controls the tradeoff between "fit the data well" and
"keep parameters small to avoid overfitting".  If &lt;span class="math"&gt;\(\lambda\)&lt;/span&gt; is set to an extremely large
value, then we may face "underfit" issue (i.e. all &lt;span class="math"&gt;\(\theta_j\)&lt;/span&gt; for &lt;span class="math"&gt;\(j = 1, \dots, n\)&lt;/span&gt; close to 0)&lt;sup id="fnref:2"&gt;&lt;a class="footnote-ref" href="#fn:2" rel="footnote"&gt;2&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;
&lt;p&gt;Since our cost function has changed, both gradient descent and normal equation have to adjust accordingly:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Gradient Descent&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="math"&gt;$$
\begin{align} 
\text{Repeat\{ } &amp;amp;&amp;amp; \nonumber \\
\theta_0 := \theta_0 - \alpha \times \frac{1}{m} \sum_{i=1}^m(h_\theta(x^{(i)})-y^{(i)})x_0^{(i)} &amp;amp;&amp;amp;  \label{eq:5} \\
\theta_j := \theta_j - \alpha \times \lbrack \frac{1}{m} \sum_{i=1}^m(h_\theta(x^{(i)})-y^{(i)})x_j^{(i)} + 
\frac{\lambda}{m}\theta_j\rbrack &amp;amp;&amp;amp; (j = 1,2,3, \dots, n) \label{eq:6} \\
\text{\}} \nonumber
\end{align}
$$&lt;/div&gt;
&lt;p&gt;Here, it might be a good time to write out the gradient explicitly (rather than embedding them in 
the gradient descent algorithm). 
&lt;a href="http://eli.thegreenplace.net/2016/understanding-gradient-descent/"&gt;Gradient descent&lt;/a&gt; 
is only one of many algorithms that optimizes a given function. We will use other algorithms
later in the course and the only thing they require is the gradients.&lt;/p&gt;
&lt;div class="math"&gt;$$
\begin{align*}
\frac{\partial J(\theta)}{\partial \theta_0} &amp;amp;=&amp;amp; \frac{1}{m}\sum_{i=1}^m(h_\theta(x^{(i)})-y^{(i)})x_j^{(i)} &amp;amp;&amp;amp; \text{ for } j = 0 \\
\frac{\partial J(\theta)}{\partial \theta_j} &amp;amp;=&amp;amp; \Big(\frac{1}{m} \sum_{i=1}^m(h_\theta(x^{(i)})-y^{(i)})x_j^{(i)}\Big) + \frac{\lambda}{m}\theta_j &amp;amp;&amp;amp; \text{ for } j \ge 1
\end{align*}
$$&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;Normal Equation&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="math"&gt;$$
\theta = (X^TX + \lambda
\begin{bmatrix} 
0 &amp;amp;&amp;amp;    &amp;amp;&amp;amp;   &amp;amp;&amp;amp;       \\
  &amp;amp;&amp;amp; 1  &amp;amp;&amp;amp;   &amp;amp;&amp;amp;       \\
  &amp;amp;&amp;amp;    &amp;amp;&amp;amp; \ddots &amp;amp;&amp;amp;  \\
  &amp;amp;&amp;amp;    &amp;amp;&amp;amp;   &amp;amp;&amp;amp;  1
\end{bmatrix}
)^{-1}X^Ty
$$&lt;/div&gt;
&lt;p&gt;we want &lt;span class="math"&gt;\(\lambda &amp;gt; 0\)&lt;/span&gt; so that the matrix is invertible.&lt;/p&gt;
&lt;h3 id="in-practice_1"&gt;In practice&lt;/h3&gt;
&lt;p&gt;Linear regression regularization implementation doesn't differ from no-regularization
implementation in terms of matrices implementation technique. The following code chunk
demonstrates a way to calculate the cost function &lt;span class="math"&gt;\(J(\theta)\)&lt;/span&gt; and the gradients (not gradient descent):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;J&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;sum&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;theta&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.^&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;lambda&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;sum&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;theta&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.^&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;         
&lt;span class="n"&gt;G&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;lambda&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;.*&lt;/span&gt; &lt;span class="n"&gt;theta&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;G&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; 
&lt;span class="n"&gt;grad&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="o"&gt;&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;theta&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;G&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;grad&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;grad&lt;/span&gt;&lt;span class="p"&gt;(:);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2 id="logistic-regression"&gt;Logistic regression&lt;/h2&gt;
&lt;p&gt;Logistic regression is used as a classification algorithm. It is better than the linear
regression because 1) linear regression classification result is higly impacted by the
outliers 2) linear regression result &lt;span class="math"&gt;\(h_\theta (x)\)&lt;/span&gt; can output value &lt;span class="math"&gt;\(&amp;gt;1\)&lt;/span&gt; or &lt;span class="math"&gt;\(&amp;lt;0\)&lt;/span&gt;, which
doesn't fit with the nature of classification task.&lt;/p&gt;
&lt;p&gt;In contrast, as we will see, logistic regression output &lt;span class="math"&gt;\(0 \ge h_\theta (x) \le 1\)&lt;/span&gt;, which
can be intrepreted from probabily perspective.&lt;/p&gt;
&lt;h3 id="in-theory_2"&gt;In theory&lt;/h3&gt;
&lt;p&gt;Logistic regression hypothesis is &lt;/p&gt;
&lt;div class="math"&gt;$$
h_\theta(x) = g(\theta^Tx) \text{ where $g(z) = \frac{1}{1+e^{-z}}$}
$$&lt;/div&gt;
&lt;p&gt;This hypothesis can be intrepreted as the probability that &lt;span class="math"&gt;\(y = 1\)&lt;/span&gt; given &lt;span class="math"&gt;\(x\)&lt;/span&gt; and &lt;span class="math"&gt;\(\theta\)&lt;/span&gt;
(i.e. &lt;span class="math"&gt;\(h_\theta(x) = P(y = 0 | x;\theta)\)&lt;/span&gt;)&lt;/p&gt;
&lt;p&gt;Then the cost function &lt;span class="math"&gt;\(J(\theta)\)&lt;/span&gt; is&lt;/p&gt;
&lt;div class="math"&gt;$$
J(\theta) = -\frac{1}{m}\sum_{i=1}^m \lbrack 
(y^{(i)}\log h_\theta(x^{(i)}) + (1-y^{(i)})\log(1-h_\theta(x^{(i)})))\rbrack
$$&lt;/div&gt;
&lt;p&gt;To minimize cost function &lt;span class="math"&gt;\(J(\theta)\)&lt;/span&gt; we can of course use gradient descent. Surprisingly,
the gradient descent for logistic regression is exactly the same as the gradient descent
for linear regression \ref{eq:3}. &lt;/p&gt;
&lt;p&gt;However, in the course, we directly use the &lt;code&gt;fminunc&lt;/code&gt; from Octave to do the optimization.
Internally, the function use advanced optimization technique that can avoid manually picking
&lt;span class="math"&gt;\(\alpha\)&lt;/span&gt; in gradient descent and find the optimal &lt;span class="math"&gt;\(\theta\)&lt;/span&gt; faster than gradient descent.&lt;/p&gt;
&lt;h3 id="in-practice_2"&gt;In practice&lt;/h3&gt;
&lt;p&gt;The implementation for cost function and gradient descent for logistic regression
should be no hard for us now:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c"&gt;% cost function for logistic regression&lt;/span&gt;
&lt;span class="n"&gt;J&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="nb"&gt;sum&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt;
                 &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;&amp;#39;*&lt;/span&gt;&lt;span class="nb"&gt;log&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sigmoid&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;theta&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt;       
                 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;&amp;#39;*&lt;/span&gt;&lt;span class="nb"&gt;log&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;sigmoid&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;theta&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt;    
             &lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="c"&gt;% gradient descent for logist regression&lt;/span&gt;
&lt;span class="n"&gt;grad&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="o"&gt;&amp;#39;*&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sigmoid&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;theta&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2 id="logistic-regression-with-regularization"&gt;Logistic regression with regularization&lt;/h2&gt;
&lt;h3 id="in-theory_3"&gt;In theory&lt;/h3&gt;
&lt;p&gt;The cost function for regualarized logistic regression is following:&lt;/p&gt;
&lt;div class="math"&gt;$$
J(\theta) = -\frac{1}{m}\sum_{i=1}^m \lbrack 
(y^{(i)}\log h_\theta(x^{(i)}) + (1-y^{(i)})\log(1-h_\theta(x^{(i)})))\rbrack
+ \frac{\lambda}{2m}\sum_{j=1}^n\theta_j^2
$$&lt;/div&gt;
&lt;p&gt;and the gradient descent looks exactly the same as the regualarized linear regression \ref{eq:5} and \ref{eq:6}. &lt;/p&gt;
&lt;h3 id="in-practice_3"&gt;In practice&lt;/h3&gt;
&lt;p&gt;The following code chunk shows the cost function and gradient descent for regularized
logistic regression:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;length&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;     &lt;span class="c"&gt;% number of training examples&lt;/span&gt;
&lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;size&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;theta&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;   &lt;span class="c"&gt;% number of theta parameters&lt;/span&gt;

&lt;span class="n"&gt;J&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;grad&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;zeros&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="n"&gt;J&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="nb"&gt;sum&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt;
               &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;&amp;#39;*&lt;/span&gt;&lt;span class="nb"&gt;log&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sigmoid&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;theta&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt;
               &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;&amp;#39;*&lt;/span&gt;&lt;span class="nb"&gt;log&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;sigmoid&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;theta&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt;
             &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt;
          &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;lambda&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;theta&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;&amp;#39;*&lt;/span&gt;&lt;span class="n"&gt;theta&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="n"&gt;grad&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="o"&gt;&amp;#39;*&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sigmoid&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;theta&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;))(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;grad&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt;  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="o"&gt;&amp;#39;*&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sigmoid&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;theta&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;lambda&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;theta&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="footnote"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;We may need to do feature scaling &amp;amp; pick up learning rate &lt;span class="math"&gt;\(\alpha\)&lt;/span&gt; wisely when we work with gradient descent.&amp;#160;&lt;a class="footnote-backref" href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:2"&gt;
&lt;p&gt;We don't penalize &lt;span class="math"&gt;\(\theta_0\)&lt;/span&gt;.&amp;#160;&lt;a class="footnote-backref" href="#fnref:2" rev="footnote" title="Jump back to footnote 2 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['CommonHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' }, Macros: {} }," +
        "    jax: ['input/TeX','input/MathML','output/CommonHTML']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Zeyuan Hu</dc:creator><pubDate>Fri, 05 May 2017 16:18:00 +0800</pubDate><guid isPermaLink="false">tag:zhu45.org,2017-05-05:posts/2017/May/05/andrew-ngs-ml-week-01-03/</guid><category>ml</category><category>coursera</category></item><item><title>Shell sort</title><link>http://zhu45.org/posts/2017/May/01/shell-sort/</link><description>&lt;p&gt;Per the final paragraph of the &lt;a href="http://zhu45.org/posts/2017/Apr/24/simple-sorting-algorithms/"&gt;last post&lt;/a&gt;,
the algorithm needs to avoid doing adjacent swap (in other words, comparing elements that are distant) 
so that we can have the opportunity to remove more than one inversion for each swap, which
can break &lt;span class="math"&gt;\(O(N^2)\)&lt;/span&gt; barrier. This is exactly what shellsort tries to achieve. &lt;/p&gt;
&lt;h2 id="concept"&gt;Concept&lt;/h2&gt;
&lt;p&gt;Shellsort is referred as &lt;em&gt;diminishing increment&lt;/em&gt; sort: it works by swapping
non-adjacent elements; the distance between comparisons decreases as the 
algorithm runs until the last phase, in which adjacent elements are compared.&lt;/p&gt;
&lt;p&gt;Concretely, shellsort uses an increment sequence &lt;span class="math"&gt;\(h_1, h_2, \dots, h_t\)&lt;/span&gt; &lt;sup id="fnref:1"&gt;&lt;a class="footnote-ref" href="#fn:1" rel="footnote"&gt;1&lt;/a&gt;&lt;/sup&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;We start with &lt;span class="math"&gt;\(k=t\)&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Sort all subsequences of elements that are &lt;span class="math"&gt;\(h_k\)&lt;/span&gt; apart so that &lt;span class="math"&gt;\(A[i] \le A[i+h_k]\)&lt;/span&gt; for all i.
In other words, all elements spaced &lt;span class="math"&gt;\(h_k\)&lt;/span&gt; apart are sorted. (&lt;span class="math"&gt;\(h_k\)&lt;/span&gt;-sort)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Go to the next smaller increment &lt;span class="math"&gt;\(h_{k-1}\)&lt;/span&gt; and repeat until &lt;span class="math"&gt;\(k = 1\)&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;A popular but poor choice for incremenet sequence is: &lt;span class="math"&gt;\(h_t = \lfloor{N/2}\rfloor\)&lt;/span&gt; and
&lt;span class="math"&gt;\(h_k = \lfloor{h_{k+1}/2}\rfloor\)&lt;/span&gt; proposed by shell. &lt;/p&gt;
&lt;p&gt;Here is the shellsort using Shell's increments &lt;sup id="fnref:2"&gt;&lt;a class="footnote-ref" href="#fn:2" rel="footnote"&gt;2&lt;/a&gt;&lt;/sup&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;
&lt;span class="nf"&gt;shellSort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;[],&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;increment&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;increment&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;increment&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;increment&lt;/span&gt; &lt;span class="o"&gt;/=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;increment&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="n"&gt;tmp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
      &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="n"&gt;increment&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;-=&lt;/span&gt; &lt;span class="n"&gt;increment&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tmp&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;increment&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
          &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;increment&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt;
          &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
      &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Here is an example of the algorithm in action (using Shell's increment sequence):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;| index        | 0  | 1  | 2  | 3  | 4  | 5  | 6  | 7  | 8  | 9  | 10 | 11 | 12 |
| original     | 81 | 94 | 11 | 96 | 12 | 35 | 17 | 95 | 28 | 58 | 41 | 75 | 15 |
|--------------|----|----|----|----|----|----|----|----|----|----|----|----|----|
| After 6-sort | 15 | 94 | 11 | 58 | 12 | 35 | 17 | 95 | 28 | 96 | 41 | 75 | 81 |
| After 3-sort | 15 | 12 | 11 | 17 | 41 | 28 | 58 | 94 | 35 | 81 | 95 | 75 | 96 |
| After 1-sort | 11 | 12 | 15 | 17 | 28 | 35 | 41 | 58 | 75 | 81 | 94 | 95 | 96 |
&lt;/pre&gt;&lt;/div&gt;


&lt;h2 id="analysis"&gt;Analysis&lt;/h2&gt;
&lt;p&gt;The running time of shellsort depends on how we pick the increment sequence. MAW gives 
running time for two commonly-seen increment sequences:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The worst-case running time of Shellsort, using Shell's increments, is &lt;span class="math"&gt;\(\Theta(N^2)\)&lt;/span&gt;.&lt;/li&gt;
&lt;li&gt;The worst-case running time of Shellsort, using Hibbard's increments (&lt;span class="math"&gt;\(1,3,7, \dots, 2^k-1\)&lt;/span&gt;) &lt;sup id="fnref:3"&gt;&lt;a class="footnote-ref" href="#fn:3" rel="footnote"&gt;3&lt;/a&gt;&lt;/sup&gt;, is &lt;span class="math"&gt;\(\Theta(N^{3/2})\)&lt;/span&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The average case time is &lt;span class="math"&gt;\(O(N^{3/2})\)&lt;/span&gt; by using Hibbard's increments. The worst case time
is the sequence when smallest elements in odd positions, largest in even positions (i.e. 2,11,4,12,6,13,8,14)
when we use shell's sequence. Only last pass (i.e. &lt;span class="math"&gt;\(h_1 = 1\)&lt;/span&gt;) will do the work and it becomes 
an insertion sort with &lt;span class="math"&gt;\(O(N^2)\)&lt;/span&gt;. The best case can happen when we set the increment sequence to be 1
for any pass and we have a sorted array. In this case, we have &lt;span class="math"&gt;\(O(N)\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;Shellsort is good for up to &lt;span class="math"&gt;\(N \approx 10000\)&lt;/span&gt; and its simplcity makes it a favorite.&lt;/p&gt;
&lt;h2 id="properties"&gt;Properties&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;an &lt;span class="math"&gt;\(h_k\)&lt;/span&gt;-sorted array that is then &lt;span class="math"&gt;\(h_{k-1}\)&lt;/span&gt; sorted remains &lt;span class="math"&gt;\(h_k\)&lt;/span&gt; sorted (why algorithm works).&lt;/li&gt;
&lt;li&gt;the action of an &lt;span class="math"&gt;\(h_k\)&lt;/span&gt;-sort is to perform an insertion sort on &lt;span class="math"&gt;\(h_k\)&lt;/span&gt; independent subarrays with size about &lt;span class="math"&gt;\(N/h_k\)&lt;/span&gt; elements
(i.e. &lt;span class="math"&gt;\(h_k = 6\)&lt;/span&gt; then there are 6 subarrays(by index): {0,6,12}, {1,7}, {2,8}, {3,9}, {4,10}, {5,11}).&lt;/li&gt;
&lt;li&gt;a larger increment swaps more distant pairs (natural derivation of the above property).&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="links-to-resources"&gt;Links to resources&lt;/h2&gt;
&lt;p&gt;Here are some of the resources I found helpful while preparing this article:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;MAW Chapter 7&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.cs.duke.edu/courses/fall01/cps100/notes/sorting_cheat.txt"&gt;Sorting cheat sheet from Duke U.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://courses.cs.washington.edu/courses/cse373/01sp/Lect15.pdf"&gt;Lecture 15&lt;/a&gt; and
&lt;a href="https://courses.cs.washington.edu/courses/cse373/01sp/Lect16_2up.pdf"&gt;lecture 16&lt;/a&gt; from U.Washington&lt;/li&gt;
&lt;li&gt;&lt;a href="http://web.mit.edu/1.124/LectureNotes/sorting.html"&gt;Notes from MIT&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.cs.rochester.edu/~brown/172/lectures/12_sort1/12sort1.html"&gt;Lecture from U.Rochester&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="footnote"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;Any increment sequence will do as long as the last increment is 1 (i.e. &lt;span class="math"&gt;\(h_1 = 1\)&lt;/span&gt;).
However, choosing the increment is a practice of art: some choices dominate others.&amp;#160;&lt;a class="footnote-backref" href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:2"&gt;
&lt;p&gt;As suggested by the algorithm above, the general strategy to &lt;span class="math"&gt;\(h_k\)&lt;/span&gt;-sort is
for each position, &lt;span class="math"&gt;\(i\)&lt;/span&gt;, in &lt;span class="math"&gt;\(h_k, h_k+1, \dots, N-1,\)&lt;/span&gt; place the element in 
the correct spot among &lt;span class="math"&gt;\(i, i-h_k, i-2h_k\)&lt;/span&gt;, etc.&amp;#160;&lt;a class="footnote-backref" href="#fnref:2" rev="footnote" title="Jump back to footnote 2 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:3"&gt;
&lt;p&gt;The key difference between Hibbard's increments and Shell's increments is the adjacent
increments have no common factors. The problem with Shell's increments is that
we keep comparing the same elements over and over again. We need to increment
so that different elements are in different passes.&amp;#160;&lt;a class="footnote-backref" href="#fnref:3" rev="footnote" title="Jump back to footnote 3 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['CommonHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' }, Macros: {} }," +
        "    jax: ['input/TeX','input/MathML','output/CommonHTML']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Zeyuan Hu</dc:creator><pubDate>Mon, 01 May 2017 21:33:00 +0800</pubDate><guid isPermaLink="false">tag:zhu45.org,2017-05-01:posts/2017/May/01/shell-sort/</guid><category>sorting</category><category>maw</category></item><item><title>Simple sorting algorithms</title><link>http://zhu45.org/posts/2017/Apr/24/simple-sorting-algorithms/</link><description>&lt;p&gt;This post summarizes three typical simple sorting algorithms: &lt;em&gt;bubble sort&lt;/em&gt;, 
&lt;em&gt;selection sort&lt;/em&gt;, and &lt;em&gt;insertion sort&lt;/em&gt;. In chapter 7, MAW mainly talks about 
&lt;em&gt;insertion sort&lt;/em&gt; but for the sake of completeness, I will include the other two as
well &lt;sup id="fnref:1"&gt;&lt;a class="footnote-ref" href="#fn:1" rel="footnote"&gt;1&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;
&lt;div class="toc"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#bubble-sort"&gt;Bubble sort&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#concept"&gt;Concept&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#analysis"&gt;Analysis&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#selection-sort"&gt;Selection sort&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#concept_1"&gt;Concept&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#analysis_1"&gt;Analysis&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#insertion-sort"&gt;Insertion sort&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#concept_2"&gt;Concept&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#analysis_2"&gt;Analysis&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#a-lower-bound-for-simple-sorting-algorithms"&gt;A Lower Bound for Simple Sorting Algorithms&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#links-to-resources"&gt;Links to resources&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h2 id="bubble-sort"&gt;Bubble sort&lt;/h2&gt;
&lt;h3 id="concept"&gt;Concept&lt;/h3&gt;
&lt;p&gt;The idea for the bubble sort is to "bubble" larger elements to the end of array
by comparing &lt;span class="math"&gt;\(i\)&lt;/span&gt; and &lt;span class="math"&gt;\(i+1\)&lt;/span&gt;, and swapping if &lt;span class="math"&gt;\(A[i] &amp;gt; A[i+1]\)&lt;/span&gt;. We repeat this 
from the first to the end of unsorted part of the array.&lt;/p&gt;
&lt;p&gt;The following code demonstrates the actual algorithm&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#define SWAP(a,b)  {int t; t = a; a = b; b = t;}&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;bubbleSort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;[],&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;// n passes thru the array&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;// from start to the end of unsorted part&lt;/span&gt;
      &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="n"&gt;SWAP&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt; 
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The key for the alogorithm is that we only do the "bubble up" operation for the
unsorted part. The following gives an example of the algorithm in action:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;| index    | 0  | 1  | 2  | 3  | 4  | 5  |
| original | 34 | 8  | 64 | 51 | 32 | 21 |
|----------|----|----|----|----|----|----|
| pass 0   | 8  | 34 | 51 | 32 | 21 | 64 |
| pass 1   | 8  | 34 | 32 | 21 | 51 | 64 |
| pass 2   | 8  | 32 | 21 | 34 | 51 | 64 |
| pass 3   | 8  | 21 | 32 | 34 | 51 | 64 |
| pass 4   | 8  | 21 | 32 | 34 | 51 | 64 |
| pass 5   | 8  | 21 | 32 | 34 | 51 | 64 |
&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id="analysis"&gt;Analysis&lt;/h3&gt;
&lt;p&gt;Bubble sort is stable and in place. The running time is &lt;span class="math"&gt;\(O(N^2)\)&lt;/span&gt;, which is true
for both worst case and average case. &lt;span class="math"&gt;\(O(N)\)&lt;/span&gt; can be achieved in the best case, where
the array is sorted or mostly sorted (possible a few elements a place or two
away from their correct spots).&lt;/p&gt;
&lt;h2 id="selection-sort"&gt;Selection sort&lt;/h2&gt;
&lt;h3 id="concept_1"&gt;Concept&lt;/h3&gt;
&lt;p&gt;The idea for selection sort is to scan array and select small key and swap it with 
the first element of the array (i.e. &lt;span class="math"&gt;\(A[0]\)&lt;/span&gt;); scan remaining keys, select the smallest
and swap with the second element (i.e. &lt;span class="math"&gt;\(A[1]\)&lt;/span&gt;); repeat the whole process until last 
element is reached. In other words, after &lt;span class="math"&gt;\(i\)&lt;/span&gt;th pass, first &lt;span class="math"&gt;\(i\)&lt;/span&gt; elements are sorted and 
in proper position.&lt;/p&gt;
&lt;p&gt;Like the bubble sort, we divide the whole array into sorted part
and unsorted part: we start with unsorted array and keep the sorted array at the beginning.
Each time we scan the unsorted part of the array and decide which element should go next
into the sorted part. However, unlike bubble sort, we build the sorted part from the
beginning of the array (in bubble sort, we start with moving the largest element to 
the end of array).&lt;/p&gt;
&lt;p&gt;The following code demonstrates the actual algorithm&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;
&lt;span class="nf"&gt;selectionSort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;[],&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;min&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;min&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;min&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
        &lt;span class="n"&gt;min&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;swap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;min&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;   
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Here is an example of the algorithm in action:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;| index    | 0  | 1  | 2  | 3  | 4  | 5  |
| original | 34 | 8  | 64 | 51 | 32 | 21 |
|----------|----|----|----|----|----|----|
| pass 0   | 8  | 34 | 64 | 51 | 32 | 21 |
| pass 1   | 8  | 21 | 64 | 51 | 32 | 34 |
| pass 2   | 8  | 21 | 32 | 51 | 64 | 34 |
| pass 3   | 8  | 21 | 32 | 34 | 64 | 51 |
| pass 4   | 8  | 21 | 32 | 34 | 51 | 64 |
&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id="analysis_1"&gt;Analysis&lt;/h3&gt;
&lt;p&gt;The selection sort is NOT STABLE but in place. Selection sort is not sensitive
to the input and thus running time should be the same in best, average, and worst cases:
We go through &lt;span class="math"&gt;\(N-1\)&lt;/span&gt; passes with &lt;span class="math"&gt;\(N-1, \dots, 1\)&lt;/span&gt; comparisons, which is &lt;span class="math"&gt;\(O(N^2)\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;Since selection sort is insensitive to the data, it's good if we want to have our
sort routine always take the same time.&lt;/p&gt;
&lt;h2 id="insertion-sort"&gt;Insertion sort&lt;/h2&gt;
&lt;h3 id="concept_2"&gt;Concept&lt;/h3&gt;
&lt;p&gt;The idea for insertion sort is that we insert an as-yet-unprocessed record
into a sorted list of the records processed so far. In details, insertion sort
consists of &lt;span class="math"&gt;\(N-1\)&lt;/span&gt; passes. For pass &lt;span class="math"&gt;\(P = 1\)&lt;/span&gt; through &lt;span class="math"&gt;\(N-1\)&lt;/span&gt;, insertion sort ensures
that the elements in positions &lt;span class="math"&gt;\(0\)&lt;/span&gt; through &lt;span class="math"&gt;\(p\)&lt;/span&gt; are in sorted order. In pass &lt;span class="math"&gt;\(P\)&lt;/span&gt;,
we move the element in position &lt;span class="math"&gt;\(P\)&lt;/span&gt; left until its correct place is found among
the first &lt;span class="math"&gt;\(P+1\)&lt;/span&gt; elements.&lt;/p&gt;
&lt;p&gt;The following code demonstrates the actual algorithm&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;
&lt;span class="nf"&gt;insertionSort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;[],&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;P&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;P&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;P&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;P&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;tmp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;P&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;P&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;tmp&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Here is an example of the algorithm in action:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;| index    | 0  | 1  | 2  | 3  | 4  | 5  |
| original | 34 | 8  | 64 | 51 | 32 | 21 |
|----------|----|----|----|----|----|----|
| pass 1   | 8  | 34 | 64 | 51 | 32 | 21 |
| pass 2   | 8  | 34 | 64 | 51 | 32 | 21 |
| pass 3   | 8  | 34 | 51 | 64 | 32 | 21 |
| pass 4   | 8  | 32 | 34 | 51 | 64 | 21 |
| pass 5   | 8  | 21 | 32 | 34 | 51 | 64 |
&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id="analysis_2"&gt;Analysis&lt;/h3&gt;
&lt;p&gt;Due to the nested loops, the running time is &lt;span class="math"&gt;\(O(N^2)\)&lt;/span&gt;, which can be achieved
when the input array is in reverse sorted order. In the best case, where 
the input array is already sorted, the running time is &lt;span class="math"&gt;\(O(N)\)&lt;/span&gt;. For the average
case, the running time is &lt;span class="math"&gt;\(O(N^2)\)&lt;/span&gt;. In fact, the bound is tight for both average case
and worst case: &lt;span class="math"&gt;\(\Theta (N^2)\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;In addition, insertion sort is stable and in place. Insertion sort is the most 
effectively used on input array with roughly &lt;span class="math"&gt;\(N &amp;lt; 20\)&lt;/span&gt; and for almost sorted array.&lt;/p&gt;
&lt;h2 id="a-lower-bound-for-simple-sorting-algorithms"&gt;A Lower Bound for Simple Sorting Algorithms&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;An &lt;strong&gt;inversion&lt;/strong&gt; is a pair of elements in wrong order (i.e. &lt;span class="math"&gt;\(i &amp;lt; j\)&lt;/span&gt; but &lt;span class="math"&gt;\(A[i] &amp;gt; A[j]\)&lt;/span&gt;).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Simple sorting algorithms presented in this post swap adjacenet elements
(explicitly or implicitly) removes one inversion per swap. This makes the running
time proportional to number of inversions in array.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The average number of inversions in an array of &lt;span class="math"&gt;\(N\)&lt;/span&gt; distinct numbers is &lt;span class="math"&gt;\(N(N-1)/4\)&lt;/span&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Any algorithm that sorts by exchanging adjacent elements requires &lt;span class="math"&gt;\(\Omega (N^2)\)&lt;/span&gt; time
on average. This is due to the fact that each adjacent swap removes only one inversion.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;As you can tell, to break &lt;span class="math"&gt;\(O(N^2)\)&lt;/span&gt; barrier, we must remove more than one inversion
for each swap. Adjacent elements swap will certainly not help us to achieve this goal.
The idea is that we try to swap the elements that are far apart and hopefully we can 
remove more than one inversion for each swap. Shell sort is the first algorithm
to break &lt;span class="math"&gt;\(O(N^2)\)&lt;/span&gt; running time. I'll talk about it in my next post.&lt;/p&gt;
&lt;h2 id="links-to-resources"&gt;Links to resources&lt;/h2&gt;
&lt;p&gt;Here are some of the resources I found helpful while preparing this article:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;MAW Chapter 7&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.cs.duke.edu/courses/fall01/cps100/notes/sorting_cheat.txt"&gt;Sorting cheat sheet from Duke U.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://courses.cs.washington.edu/courses/cse373/01sp/Lect15.pdf"&gt;Lecture 15&lt;/a&gt; from U.Washington&lt;/li&gt;
&lt;li&gt;&lt;a href="http://web.mit.edu/1.124/LectureNotes/sorting.html"&gt;Notes from MIT&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.cs.rochester.edu/~brown/172/lectures/12_sort1/12sort1.html"&gt;Lecture from U.Rochester&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="footnote"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;&lt;a href="https://youtu.be/8Kp-8OGwphY"&gt;bubble sort video&lt;/a&gt;, &lt;a href="https://youtu.be/f8hXR_Hvybo"&gt;selection sort video&lt;/a&gt;, 
&lt;a href="https://youtu.be/DFG-XuyPYUQ"&gt;insertion sort video&lt;/a&gt; and 
&lt;a href="https://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html"&gt;this animation&lt;/a&gt;
can help you understand the concept.&amp;#160;&lt;a class="footnote-backref" href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['CommonHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' }, Macros: {} }," +
        "    jax: ['input/TeX','input/MathML','output/CommonHTML']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Zeyuan Hu</dc:creator><pubDate>Mon, 24 Apr 2017 21:33:00 +0800</pubDate><guid isPermaLink="false">tag:zhu45.org,2017-04-24:posts/2017/Apr/24/simple-sorting-algorithms/</guid><category>sorting</category><category>maw</category></item><item><title>Introducing the "Andrew Ng's ML course study notes"</title><link>http://zhu45.org/posts/2017/Apr/21/introducing-the-andrew-ngs-ml-course-study-notes/</link><description>&lt;p&gt;I finally enrolled in Andrew Ng's machine learning course on 
&lt;a href="https://www.coursera.org/learn/machine-learning/home/welcome"&gt;Coursera&lt;/a&gt;. Here is 
my expectation for this course:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Get a fun intro to machine learning field. &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I studied mathematics, statistics, and took AI course when I was an undergraduate
but I never had an intro to ML formally. All the work I have done so far has
a very strong relationship with ML but they don't really target on ML specifically.
So, I think Andrew Ng's ML course is probably a great intro to this field.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;In preparation for my graduate studies.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I'm thinking of pursuing a research career in NLP and robotics but I need to some
ground work to see if they are actually fun like I'm picturing in my mind. In addition,
before actually taking graduate level related courses, there might be some gaps I
need to fill out. So I think Andrew Ng's course may be a greate bridge course
to get me warm up for the serious graduate level ML studies.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Take a break from Algo studies and keep myself motivated.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I'm currently working on a reading project to finish MAW by the end of this September.
The progress so far is on track and I'm having a lot of fun with the book. However,
sometimes, I want to experience some different flavor of dishes and take a break. In 
addition, I'm thinking of the next reading project I'm going to do. It's highly likely
going to be a book in linear algebra. I have taken linear algebra before in the college
but I found the subject can become quite boring very soon if you don't have specific
problems or needs want to address. Hopefully, Andrew Ng's course will help me to
find some motivation to study linear algebra well.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Start to make rsum ML-ish&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I'm working in DB field but I always want to do ML by nature judged by my performance
in the ML-related courses. Taking ML course on coursera and having a nice badge on
my LinkedIn may greatly help me to market my ML expertise in the future?&lt;/p&gt;
&lt;p&gt;My current plan is to finish the coursera version first, and then move on to 
&lt;a href="http://cs229.stanford.edu/materials.html"&gt;CS229&lt;/a&gt; version if time permits. 
I want to take an agile approach to this material by doing iteratively build-up.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Zeyuan Hu</dc:creator><pubDate>Fri, 21 Apr 2017 23:48:00 +0800</pubDate><guid isPermaLink="false">tag:zhu45.org,2017-04-21:posts/2017/Apr/21/introducing-the-andrew-ngs-ml-course-study-notes/</guid><category>ml</category><category>coursera</category></item><item><title>Sorting prelim</title><link>http://zhu45.org/posts/2017/Apr/18/sorting-prelim/</link><description>&lt;p&gt;Chapter 7: Sorting will have some rigorous analysis of the sorting algorithms
(no wonder as suggested by the title of the book). Some meta-concepts related with
sorting appeard at the very beginning of the chapter. I usually push them to the
end-chapter summary post but this time I decide to do a writeup beforehand because 
I find it is really hard to talk about various sorting schemes without setting up some
ground concepts first.&lt;/p&gt;
&lt;h2 id="definitions"&gt;Definitions&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Sorting problem: Given an array &lt;span class="math"&gt;\(A\)&lt;/span&gt;, output &lt;span class="math"&gt;\(A\)&lt;/span&gt; such that: 
  For any &lt;span class="math"&gt;\(i\)&lt;/span&gt; and &lt;span class="math"&gt;\(J\)&lt;/span&gt;, if &lt;span class="math"&gt;\(i &amp;lt; j\)&lt;/span&gt;, then &lt;span class="math"&gt;\(A[i] \le A[j]\)&lt;/span&gt;.&lt;sup id="fnref:1"&gt;&lt;a class="footnote-ref" href="#fn:1" rel="footnote"&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Sorting algorithm using comparison operators (i.e &lt;span class="math"&gt;\(&amp;lt;, &amp;gt;, =\)&lt;/span&gt;) is known as
&lt;strong&gt;comparison-based sorting&lt;/strong&gt;. Another major type is called &lt;strong&gt;counting sort&lt;/strong&gt; (i.e. Radix sort).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;If the entire sort can be done in main memory (i.e number of elements is relatively small, usually less than a million), we call it &lt;strong&gt;internal sorting&lt;/strong&gt;. By the contrast,
if the data is on the disk, we call it &lt;strong&gt;external sorting&lt;/strong&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;An algorithm requires &lt;span class="math"&gt;\(O(1)\)&lt;/span&gt; extra space is known as an &lt;strong&gt;in place&lt;/strong&gt; sorting algorithm.&lt;sup id="fnref:2"&gt;&lt;a class="footnote-ref" href="#fn:2" rel="footnote"&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A sorting algorithm is &lt;strong&gt;stable&lt;/strong&gt; &lt;sup id="fnref:3"&gt;&lt;a class="footnote-ref" href="#fn:3" rel="footnote"&gt;3&lt;/a&gt;&lt;/sup&gt; if elements with equal keys are left in the same
order as they occur in the input. In other words, we can ask ourself the question:
Does it rearrange the order of input data records which have the same key value
(duplicates)? If the answer is No, then the sorting algorithm is &lt;em&gt;stable&lt;/em&gt;.
One example is that Phone book is sorted by name. 
Now let's sort the book by country - is the list still sorted by name within each country?
As you can tell, it is an extremely important property for databases.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;There will be three kinds of running time mentioned in the sorting analysis:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;average case time&lt;/em&gt;: given an arbitrary input, what do we expect the running time
to be.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;worst case time&lt;/em&gt;: for a particular degenerate case, how bad will the algorithm
perform.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;best case time&lt;/em&gt;: for a particularly benevolent input case, what is the best case 
performance.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="links-to-resources"&gt;Links to resources&lt;/h2&gt;
&lt;p&gt;Here are some of the resources I found helpful while preparing this article:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;MAW Chapter 7&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.cs.duke.edu/courses/fall01/cps100/notes/sorting_cheat.txt"&gt;Sorting cheat sheet from Duke U.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://courses.cs.washington.edu/courses/cse373/01sp/Lect15.pdf"&gt;Lecture material from U.Washington&lt;/a&gt; and
&lt;a href="http://web.mit.edu/1.124/LectureNotes/sorting.html"&gt;MIT&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="footnote"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;Here, for the input, we are given an array &lt;span class="math"&gt;\(A\)&lt;/span&gt; of data records, each with
a key (which can be an integer, character, string, etc) as long as the following
condition can be met: 1. There is an ordering on the set of possible keys 2. We can compare any two keys using &lt;span class="math"&gt;\(&amp;lt;, &amp;gt;, =\)&lt;/span&gt;&amp;#160;&lt;a class="footnote-backref" href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:2"&gt;
&lt;p&gt;Under the context of the sorting, we may ask: Does the sorting algorithm require extra
memory to sort the collection of items? Do we need to copy and temporarily store some 
subset of the keys/data records?&amp;#160;&lt;a class="footnote-backref" href="#fnref:2" rev="footnote" title="Jump back to footnote 2 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:3"&gt;
&lt;p&gt;When we evaluate the performance of a sorting algorithm, we usually evaluate it
from three perspectives: &lt;em&gt;running time&lt;/em&gt;, &lt;em&gt;memory requirements (aka space)&lt;/em&gt;, and &lt;em&gt;stability&lt;/em&gt;.&amp;#160;&lt;a class="footnote-backref" href="#fnref:3" rev="footnote" title="Jump back to footnote 3 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['CommonHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' }, Macros: {} }," +
        "    jax: ['input/TeX','input/MathML','output/CommonHTML']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Zeyuan Hu</dc:creator><pubDate>Tue, 18 Apr 2017 10:03:00 +0800</pubDate><guid isPermaLink="false">tag:zhu45.org,2017-04-18:posts/2017/Apr/18/sorting-prelim/</guid><category>sorting</category><category>maw</category></item><item><title>MAW Chapter 7: Sorting writing questions</title><link>http://zhu45.org/posts/2017/Apr/15/maw-chapter-7-sorting-writing-questions/</link><description>&lt;h2 id="solutions"&gt;Solutions&lt;/h2&gt;
&lt;p&gt;including: MAW 7.1, 7.2, 7.3, 7.4, 7.5.a, 7.9, 7.10, 7.11, 7.12, &lt;/p&gt;
&lt;h3 id="maw-71"&gt;MAW 7.1&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Sort the sequence 3,1,4,1,5,9,2,6,5 using insertion sort.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;| index    | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 |
| original | 3 | 1 | 4 | 1 | 5 | 9 | 2 | 6 | 5 |
|----------|---|---|---|---|---|---|---|---|---|
| pass 1   | 1 | 3 | 4 | 1 | 5 | 9 | 2 | 6 | 5 |
| pass 2   | 1 | 3 | 4 | 1 | 5 | 9 | 2 | 6 | 5 |
| pass 3   | 1 | 1 | 3 | 4 | 5 | 9 | 2 | 6 | 5 |
| pass 4   | 1 | 1 | 3 | 4 | 5 | 9 | 2 | 6 | 5 |
| pass 5   | 1 | 1 | 3 | 4 | 5 | 9 | 2 | 6 | 5 |
| pass 6   | 1 | 1 | 2 | 3 | 4 | 5 | 9 | 6 | 5 |
| pass 7   | 1 | 1 | 2 | 3 | 4 | 5 | 6 | 9 | 5 |
| pass 8   | 1 | 1 | 2 | 3 | 4 | 5 | 5 | 6 | 9 |
&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id="maw-72"&gt;MAW 7.2&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;What is the running time of insertion sort if all keys are equal?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;If you take a look at the code on p. 220, you can see that inner for loop checks
&lt;code&gt;A[j-1] &amp;gt; tmp&lt;/code&gt; and it will fail immediately. Thus, the running time is &lt;span class="math"&gt;\(O(N)\)&lt;/span&gt;.&lt;/p&gt;
&lt;h3 id="maw-73"&gt;MAW 7.3&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Suppose we exchange elements &lt;span class="math"&gt;\(A[i]\)&lt;/span&gt; and &lt;span class="math"&gt;\(A[i+k]\)&lt;/span&gt;, which were originally
out of order. Prove that at least 1 and at most &lt;span class="math"&gt;\(2k-1\)&lt;/span&gt; inversions are removed.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The inversion that existed between &lt;span class="math"&gt;\(A[i]\)&lt;/span&gt; and &lt;span class="math"&gt;\(A[i+k]\)&lt;/span&gt; is removed. This shows 
at least one inversion is removed. Now let's consider &lt;span class="math"&gt;\(A[i], A[i+1], \dots, A[i+k-1], A[i+k]\)&lt;/span&gt;,
Suppose &lt;span class="math"&gt;\(A[i]\)&lt;/span&gt; is greater than &lt;span class="math"&gt;\(A[i+1], \dots, A[i+k]\)&lt;/span&gt; and &lt;span class="math"&gt;\(A[i+k]\)&lt;/span&gt; is smaller than
&lt;span class="math"&gt;\(A[i], \dots, A[i+k-1]\)&lt;/span&gt;. In this case, by swapping &lt;span class="math"&gt;\(A[i]\)&lt;/span&gt; and &lt;span class="math"&gt;\(A[i+k]\)&lt;/span&gt;, we fix 
&lt;span class="math"&gt;\(2k-1\)&lt;/span&gt; inversions (&lt;span class="math"&gt;\(-1\)&lt;/span&gt; is that &lt;span class="math"&gt;\(A[i]\)&lt;/span&gt; greater than &lt;span class="math"&gt;\(A[i+k]\)&lt;/span&gt; and &lt;span class="math"&gt;\(A[i+k]\)&lt;/span&gt; smaller
than &lt;span class="math"&gt;\(A[i]\)&lt;/span&gt; points to the same inversion).&lt;/p&gt;
&lt;p&gt;Another way to think about &lt;span class="math"&gt;\(2k-1\)&lt;/span&gt; is that for each of the &lt;span class="math"&gt;\(k-1\)&lt;/span&gt; elements 
&lt;span class="math"&gt;\(A[i+1], A[i+2], \dots, A[i+k-1]\)&lt;/span&gt;, at most two inversions can be removed by exchange.
For instance, for &lt;span class="math"&gt;\(A[i+1]\)&lt;/span&gt;, two inversions are &lt;span class="math"&gt;\(A[i]\)&lt;/span&gt; and &lt;span class="math"&gt;\(A[i+1]\)&lt;/span&gt;, and &lt;span class="math"&gt;\(A[i+1]\)&lt;/span&gt; and
&lt;span class="math"&gt;\(A[i+k]\)&lt;/span&gt; (i.e. for sequence 10,4,3, by swapping 10 and 3, we remove inversion {10,4}
and {4,3}). Thus, a maximum of &lt;span class="math"&gt;\(2(k-1)+1 = 2k-1\)&lt;/span&gt;.&lt;/p&gt;
&lt;h3 id="maw-74"&gt;MAW 7.4&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Show the result of running Shellsort on the input 9,8,7,6,5,4,3,2,1 using the
increments {1,3,7}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;| index        | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 |
| original     | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 |
|--------------|---|---|---|---|---|---|---|---|---|
| after 7-sort | 2 | 1 | 7 | 6 | 5 | 4 | 3 | 9 | 8 |
| after 3-sort | 2 | 1 | 4 | 3 | 5 | 7 | 6 | 9 | 8 |
| after 1-sort | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |
&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id="maw-75a"&gt;MAW 7.5.a&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;What is the running time of Shellsort using the two-increment sequence {1,2}?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The answer is &lt;span class="math"&gt;\(\Theta(N^2)\)&lt;/span&gt;. Let's first show the lower bound. By the conclusion
of 7.3, we know that The 2-sort removes at most only three (i.e. &lt;span class="math"&gt;\(k=2\)&lt;/span&gt;) inversions
at a time. In addition, a pass with increment &lt;span class="math"&gt;\(h_k\)&lt;/span&gt; consists of &lt;span class="math"&gt;\(h_k\)&lt;/span&gt; insertion sorts
of about &lt;span class="math"&gt;\(N/h_k\)&lt;/span&gt; elements. Then, by theorem 7.2, we know that the algorithm 
is &lt;span class="math"&gt;\(\Omega(N^2)\)&lt;/span&gt;. By the same argument, the 2-sort is two insertion sorts of size &lt;span class="math"&gt;\(N/2\)&lt;/span&gt;,
so the cost of that pass is &lt;span class="math"&gt;\(O(N^2)\)&lt;/span&gt;. The 1-sort is also &lt;span class="math"&gt;\(O(N^2)\)&lt;/span&gt;, so the upper bound
for the algorithm is &lt;span class="math"&gt;\(O(N^2)\)&lt;/span&gt;. &lt;/p&gt;
&lt;h3 id="maw-79"&gt;MAW 7.9&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Determine the running time (i.e. number of swaps) of Shellsort for &lt;/p&gt;
&lt;p&gt;a. sorted input&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span class="math"&gt;\(O(N \log N)\)&lt;/span&gt;. No exachanges acutally done in each each pass but we will still
need to go through the second for loop, which indicates that each pass takes 
&lt;span class="math"&gt;\(O(N)\)&lt;/span&gt;. There are total &lt;span class="math"&gt;\(O(\log N)\)&lt;/span&gt; passes and the answer follows.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;b. reverse-ordered input&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span class="math"&gt;\(O(N \log N)\)&lt;/span&gt;. It is easy to show that after an &lt;span class="math"&gt;\(h_k\)&lt;/span&gt; sort, no element is farther
than &lt;span class="math"&gt;\(h_k\)&lt;/span&gt; from its rightful position. Thus, if the increments satisfy &lt;span class="math"&gt;\(h_{k+1} \le ch_k\)&lt;/span&gt;
for a constant &lt;span class="math"&gt;\(c\)&lt;/span&gt;, which implies &lt;span class="math"&gt;\(O(\log N)\)&lt;/span&gt; increments, then the bound follows.&lt;/p&gt;
&lt;p&gt;However, one cannot talk about shellsort without specifying the increment sequence.
If we assume the shell sequence (i.e. &lt;span class="math"&gt;\(N/2, N/4, \dots, 2, 1\)&lt;/span&gt;), then the running time
is &lt;span class="math"&gt;\(O(N^2)\)&lt;/span&gt; as suggested by &lt;a href="https://www.cs.rochester.edu/~brown/172/exams/2ndmidterm_ans_13.pdf"&gt;this answer&lt;/a&gt;,
which I'll copy below for future reference.&lt;/p&gt;
&lt;p&gt;Shellsort is just a bunch of insertion sorts. For a given increment &lt;span class="math"&gt;\(I\)&lt;/span&gt;, there will
be &lt;span class="math"&gt;\(I\)&lt;/span&gt; subarrays to sort by insertion, each of length &lt;span class="math"&gt;\(N/I\)&lt;/span&gt;. We know that insertion
sort requires time &lt;span class="math"&gt;\(O(m^2)\)&lt;/span&gt; to sort a reverse-sorted array of length &lt;span class="math"&gt;\(m\)&lt;/span&gt;. Here, &lt;span class="math"&gt;\(m\)&lt;/span&gt;
will be (&lt;span class="math"&gt;\(N/I\)&lt;/span&gt;) for each subarray. Thus one subarray will cost &lt;span class="math"&gt;\((N/I)^2\)&lt;/span&gt; to sort. 
There are &lt;span class="math"&gt;\(I\)&lt;/span&gt; subarrays, so the total cost will be &lt;span class="math"&gt;\(I * (N/I)^2 = N^2/I\)&lt;/span&gt;. But that 
is the cost just for a single increment. The total time for all of the iterations must be
&lt;span class="math"&gt;\(N^2/(N/2) + N^2/(N/4) + N^2/(N/8) + \dots + N^2/2 + N^2/1 = 2N + 4N + \dots + N^2/2 + N^2/1\)&lt;/span&gt; .
If we factor out an &lt;span class="math"&gt;\(N\)&lt;/span&gt;, we get &lt;span class="math"&gt;\(N(2+4+\dots+N/2+N)\)&lt;/span&gt; . In parenthesis is the sum of powers of 
2 from 2 to &lt;span class="math"&gt;\(N\)&lt;/span&gt;, which is approximately equalt to &lt;span class="math"&gt;\(2N\)&lt;/span&gt;. Therefore, the total cost
is &lt;span class="math"&gt;\(N(2N) = 2N^2 = O(N^2)\)&lt;/span&gt;.&lt;/p&gt;
&lt;h3 id="maw-710"&gt;MAW 7.10&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Do either of the following modifications to the Shellsort routine coded in 
Fig. 7.4 affect the worst case running time?&lt;/p&gt;
&lt;p&gt;a. Before line 2, subtract one from &lt;code&gt;Increment&lt;/code&gt; if it is even.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The key improvement in terms of the worst case running time lies in the increment
sequence. As suggested on p.224,225, we improve the worst time running time from
&lt;span class="math"&gt;\(O(N^2)\)&lt;/span&gt; to &lt;span class="math"&gt;\(O(N^{3/2})\)&lt;/span&gt; by changing the increment sequence into the sequence that
consecutive increments have no common factors. &lt;/p&gt;
&lt;p&gt;If we follow the modification indicated by this question, it is still possible
to have a case that we will have consecutive increments to share a common factor.
For instance, if we sort an array with size &lt;span class="math"&gt;\(N = 45\)&lt;/span&gt;, then with the modification,
the increment sequence will be &lt;span class="math"&gt;\(45, 21 (22-1), 9, 3, 1\)&lt;/span&gt;.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;b. Before line 2, add one to &lt;code&gt;Increment&lt;/code&gt; if it is even.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;In this case, conseuctive increments are relatively prime and by the argument in 
the proof of theorem 7.4, we can have the worst case running time &lt;span class="math"&gt;\(O(N^{3/2})\)&lt;/span&gt;.&lt;/p&gt;
&lt;h3 id="maw-711"&gt;MAW 7.11&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Show how heapsort processes the input 142, 543, 123, 65, 453, 879, 572, 434, 111, 242, 
811, 102.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The input is read in as it appears in the question. Then, we first build the heap with 
the result looks like&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;879, 811, 572, 434, 543, 123, 142, 65, 111, 242, 453, 102
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;span class="math"&gt;\(879\)&lt;/span&gt; is removed from the heap and placed at the end. We'll put &lt;em&gt;|&lt;/em&gt; to separate the elements
that are sorted and not part of the heap. &lt;span class="math"&gt;\(102\)&lt;/span&gt; is placed in the hole and bubbled down, obtaining&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;811, 543, 572, 434, 453, 123, 142, 65, 111, 242, 102, | 879
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;continuing the process, we obtain&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;572, 543, 142, 434, 453, 123, 102, 65, 111, 242, | 811, 879
543, 453, 142, 434, 242, 123, 102, 65, 111, | 572, 811, 879
453, 434, 142, 111, 242, 123, 102, 65, | 543, 572, 811, 879
434, 242, 142, 111, 65, 123, 102, | 453, 543, 572, 811, 879
242, 111, 142, 102, 65, 123, | 434, 453, 543, 572, 811, 879
142, 111, 123, 102, 65, | 242, 434, 453, 543, 572, 811, 879
123, 111, 65, 102, | 142, 242, 434, 453, 543, 572, 811, 879
111, 102, 65, | 123, 142, 242, 434, 453, 543, 572, 811, 879
102, 65, | 111, 123, 142, 242, 434, 453, 543, 572, 811, 879
65, | 102, 111, 123, 142, 242, 434, 453, 543, 572, 811, 879
| 65, 102, 111, 123, 142, 242, 434, 453, 543, 572, 811, 879
&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id="maw-712"&gt;MAW 7.12&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;a. What is the running time of heapsort for presorted input?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Still &lt;span class="math"&gt;\(O(N\log N)\)&lt;/span&gt;. Heapsort uses at least (roughly) 
&lt;span class="math"&gt;\(N\log N\)&lt;/span&gt; comparisons on any input, so there are no particularly
good inputs.&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['CommonHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' }, Macros: {} }," +
        "    jax: ['input/TeX','input/MathML','output/CommonHTML']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Zeyuan Hu</dc:creator><pubDate>Sat, 15 Apr 2017 23:54:00 +0800</pubDate><guid isPermaLink="false">tag:zhu45.org,2017-04-15:posts/2017/Apr/15/maw-chapter-7-sorting-writing-questions/</guid><category>sorting</category><category>proof</category><category>math</category><category>maw</category></item><item><title>MAW: Chapter 6 Reflection</title><link>http://zhu45.org/posts/2017/Apr/09/maw-chapter-6-reflection/</link><description>&lt;div class="section" id="reflection"&gt;
&lt;h2&gt;Reflection&lt;/h2&gt;
&lt;p&gt;In chapter 6, we learn about the priority queue ADT. We assume each item has
a &amp;quot;priority&amp;quot; and the ADT allows us to insert the element into the queue and
get the element with &amp;quot;highest&amp;quot; priority from the queue. The model looks like&lt;/p&gt;
&lt;img src="/images/priority-queue-ADT.PNG" alt="priority queue ADT"/&gt;&lt;p&gt;and the big picture we have studied so far becomes:&lt;/p&gt;
&lt;img src="/images/ADT.PNG" alt="ADT overview"/&gt;&lt;p&gt;In order to support two operations required by the model, we propose four new
implmentations. &lt;a class="reference external" href="http://zhu45.org/posts/2017/Apr/02/binary-heap/"&gt;Binary heap&lt;/a&gt; is
the most commonly-seen one. Insert can be done in &lt;span class="math"&gt;\(O(\log N)\)&lt;/span&gt; in the worst
case and constant on average. DeleteMin can be done in &lt;span class="math"&gt;\(O(\log N)\)&lt;/span&gt;. However,
it has natural drawback in supporting merge operation, which is needed when we
want to merge two heaps into one. This leads to the
&lt;a class="reference external" href="http://zhu45.org/posts/2017/Apr/04/leftist-heap/"&gt;leftist heap&lt;/a&gt;. Leftist heap
supports all three operations (insert, DeleteMin, merge) efficiently but we
needs to maintain extra information in the node and we need to do extra test
during merge in order to maintain the leftist heap property.
To better solve these two little disadvantages, we propose
&lt;a class="reference external" href="http://zhu45.org/posts/2017/Apr/05/skew-heap/"&gt;skew heap&lt;/a&gt;, which has
no restriction on the tree structure at all while still enjoying the efficiency of operations
in amortized time. However, there is still room for improvement because
both leftist heap and skew heap cannot support constant on average insertion like
binary heap does. This is why we propose a new structure called
&lt;a class="reference external" href="http://zhu45.org/posts/2017/Apr/08/binomial-queue/"&gt;binomial queue&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;There are many applications of priority queues:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Operating system task scheduler&lt;/li&gt;
&lt;li&gt;Forward network packets in order of urgency&lt;/li&gt;
&lt;li&gt;Select most frequent symbols for data compression&lt;/li&gt;
&lt;li&gt;Sorting&lt;/li&gt;
&lt;li&gt;Implementation for greedy algorithms&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="left-out"&gt;
&lt;h2&gt;Left Out&lt;/h2&gt;
&lt;p&gt;Some material I left out when I work through this chapter:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;6.9.c, 6.10, 6.12, 6.20, 6.21, 6.30, 6.32, 6.33, 6.34, 6.35, 6.36&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="reference"&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;MAW Chapter 6&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://courses.cs.washington.edu/courses/cse332/10sp/lectures/lecture4.pdf"&gt;https://courses.cs.washington.edu/courses/cse332/10sp/lectures/lecture4.pdf&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['CommonHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' }, Macros: {} }," +
        "    jax: ['input/TeX','input/MathML','output/CommonHTML']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Zeyuan Hu</dc:creator><pubDate>Sun, 09 Apr 2017 10:45:00 +0800</pubDate><guid isPermaLink="false">tag:zhu45.org,2017-04-09:posts/2017/Apr/09/maw-chapter-6-reflection/</guid><category>meta</category><category>maw</category><category>heaps</category></item><item><title>Binomial queue</title><link>http://zhu45.org/posts/2017/Apr/08/binomial-queue/</link><description>&lt;p&gt;This is the summary of &lt;em&gt;binomial queue&lt;/em&gt; part in MAW Chapter 6.&lt;/p&gt;
&lt;h2 id="motivation"&gt;Motivation&lt;/h2&gt;
&lt;p&gt;We want to have a data structure that support merging, insertion, and deleteMin
in &lt;span class="math"&gt;\(O(\log N)\)&lt;/span&gt; time per operation, and at the same time, like binary heap, we 
want to have insertion takes constant time on average. The latter part is not possible
with skew heap or leftist heap. &lt;/p&gt;
&lt;p&gt;The data structure we have is called &lt;em&gt;binomial queue&lt;/em&gt;.&lt;/p&gt;
&lt;h2 id="concept"&gt;Concept&lt;/h2&gt;
&lt;p&gt;Binomial queues is a collection of heap-ordered trees. Each of the heap-ordered
trees is called a &lt;em&gt;binomial tree&lt;/em&gt; with the following constraints:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;There is at most one binomial tree of every height.&lt;/li&gt;
&lt;li&gt;A binomial tree of height 0 is a one-node tree; a binomial tree, &lt;span class="math"&gt;\(B_k\)&lt;/span&gt;, of 
height &lt;span class="math"&gt;\(k\)&lt;/span&gt; is formed by attaching a binomial tree, &lt;span class="math"&gt;\(B_{k-1}\)&lt;/span&gt;, to the root of another
binomial tree, &lt;span class="math"&gt;\(B_{k-1}\)&lt;/span&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The picture below shows a binomial queue consisting of six elements
with two binomial trees &lt;span class="math"&gt;\(B_1\)&lt;/span&gt; and &lt;span class="math"&gt;\(B_2\)&lt;/span&gt;:&lt;/p&gt;
&lt;p&gt;&lt;img src="/images/binomial-queue.PNG" alt="binomial queue example"/&gt;&lt;/p&gt;
&lt;h2 id="properties"&gt;Properties&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;A binomial tree &lt;span class="math"&gt;\(B_k\)&lt;/span&gt;, consists of a root with children &lt;span class="math"&gt;\(B_0, B_1, \dots, B_{k-1}\)&lt;/span&gt;.&lt;/li&gt;
&lt;li&gt;Binomial trees of height &lt;span class="math"&gt;\(k\)&lt;/span&gt; have exactly &lt;span class="math"&gt;\(2^k\)&lt;/span&gt; nodes&lt;/li&gt;
&lt;li&gt;The number of nodes at depth &lt;span class="math"&gt;\(d\)&lt;/span&gt; is the binomial coefficient &lt;span class="math"&gt;\({k \choose d}\)&lt;/span&gt;.&lt;/li&gt;
&lt;li&gt;A priority queue of any size can be represented by a collection of binomial trees.
For instances, a priority queue of size 13 could be represented by &lt;span class="math"&gt;\(B_3, B_2, B_0\)&lt;/span&gt; 
( &lt;span class="math"&gt;\(13 = 2^3 + 2^2 + 2^0\)&lt;/span&gt; ). Thus, we can write this representation as &lt;span class="math"&gt;\(1101\)&lt;/span&gt;, which not 
only represents &lt;span class="math"&gt;\(13\)&lt;/span&gt; in binary but also represents the fact that &lt;span class="math"&gt;\(B_3, B_2, B_0\)&lt;/span&gt;
are present and &lt;span class="math"&gt;\(B_1\)&lt;/span&gt; is not.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="operations"&gt;Operations&lt;/h2&gt;
&lt;h3 id="merge"&gt;Merge&lt;/h3&gt;
&lt;p&gt;The merge is performed by essentially adding the two queues together. Let's illustrate
through merging two binomial queues &lt;span class="math"&gt;\(H_1\)&lt;/span&gt; and &lt;span class="math"&gt;\(H_2\)&lt;/span&gt; shown below:&lt;/p&gt;
&lt;p&gt;&lt;img src="/images/binomial-queue-merge-01.PNG" alt="binomial queue merge 01"/&gt;&lt;/p&gt;
&lt;p&gt;If you will, &lt;span class="math"&gt;\(H_1\)&lt;/span&gt; can be represented as &lt;span class="math"&gt;\(0110_{2}\)&lt;/span&gt; and &lt;span class="math"&gt;\(H_2\)&lt;/span&gt; can be represented as
&lt;span class="math"&gt;\(0111_{2}\)&lt;/span&gt;. Thus, merge is just adding two binary number together, and we have
&lt;span class="math"&gt;\(1101_2\)&lt;/span&gt;. This implies that our final result contains &lt;span class="math"&gt;\(B_0, B_2, B_3\)&lt;/span&gt;. The actual
merge step is implied by the binomial tree constraint mentioned above:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A binomial tree of height 0 is a one-node tree; a binomial tree, &lt;span class="math"&gt;\(B_k\)&lt;/span&gt;, of 
height &lt;span class="math"&gt;\(k\)&lt;/span&gt; is formed by attaching a binomial tree, &lt;span class="math"&gt;\(B_{k-1}\)&lt;/span&gt;, to the root of another
binomial tree, &lt;span class="math"&gt;\(B_{k-1}\)&lt;/span&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Thus merge of the two &lt;span class="math"&gt;\(B_1\)&lt;/span&gt; trees in &lt;span class="math"&gt;\(H_1\)&lt;/span&gt; and &lt;span class="math"&gt;\(H_2\)&lt;/span&gt; looks like:&lt;/p&gt;
&lt;p&gt;&lt;img src="/images/binomial-queue-merge-02.PNG" alt="binomial queue merge 02"/&gt;&lt;/p&gt;
&lt;p&gt;and the final result of merging looks like:&lt;/p&gt;
&lt;p&gt;&lt;img src="/images/binomial-queue-merge-03.PNG" alt="binomial queue merge 03"/&gt;&lt;/p&gt;
&lt;h3 id="insertion"&gt;Insertion&lt;/h3&gt;
&lt;p&gt;Insertion is just a special case of merging, since we merely create a one-node tree
and perform a merge.&lt;/p&gt;
&lt;h3 id="deletemin"&gt;DeleteMin&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;find the binomial tree with the smallest root. Let this tree be &lt;span class="math"&gt;\(B_k\)&lt;/span&gt;, and let the original priority queue be &lt;span class="math"&gt;\(H\)&lt;/span&gt;. &lt;/li&gt;
&lt;li&gt;Remove the binomial tree &lt;span class="math"&gt;\(B_k\)&lt;/span&gt; from the forest of trees in &lt;span class="math"&gt;\(H\)&lt;/span&gt;, forming the new binomial queue &lt;span class="math"&gt;\(H'\)&lt;/span&gt;. &lt;/li&gt;
&lt;li&gt;Remove the root of &lt;span class="math"&gt;\(B_k\)&lt;/span&gt;, creating binomial trees &lt;span class="math"&gt;\(B_0, B_1, \dots, B_{k-1}\)&lt;/span&gt;, which collectively form priority queue &lt;span class="math"&gt;\(H''\)&lt;/span&gt;. &lt;/li&gt;
&lt;li&gt;merge &lt;span class="math"&gt;\(H'\)&lt;/span&gt; and &lt;span class="math"&gt;\(H''\)&lt;/span&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Suppose we perform a DeleteMin on &lt;span class="math"&gt;\(H_3\)&lt;/span&gt; from above. The minimum root is 12, and we have 
&lt;span class="math"&gt;\(H'\)&lt;/span&gt; and &lt;span class="math"&gt;\(H''\)&lt;/span&gt; below:&lt;/p&gt;
&lt;p&gt;&lt;img src="/images/binomial-queue-deleteMin-01.PNG" alt="binomial queue deleteMin 01"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="/images/binomial-queue-deleteMin-02.PNG" alt="binomial queue deleteMin 02"/&gt;&lt;/p&gt;
&lt;p&gt;and our final result is &lt;sup id="fnref:1"&gt;&lt;a class="footnote-ref" href="#fn:1" rel="footnote"&gt;1&lt;/a&gt;&lt;/sup&gt;:&lt;/p&gt;
&lt;p&gt;&lt;img src="/images/binomial-queue-deleteMin-03.PNG" alt="binomial queue deleteMin 03"/&gt;&lt;/p&gt;
&lt;h2 id="runtime-analysis"&gt;Runtime analysis&lt;/h2&gt;
&lt;h3 id="merge_1"&gt;Merge&lt;/h3&gt;
&lt;p&gt;Since merging two binomial trees takes constant time with almost any reasonable
implementation, and there are &lt;span class="math"&gt;\(O(\log N)\)&lt;/span&gt; binomial trees (think of representing
the size of priority queue in terms of binary, and we need to do &lt;span class="math"&gt;\(O(\log N)\)&lt;/span&gt; division),
the merge takes &lt;span class="math"&gt;\(O(\log N)\)&lt;/span&gt; time.&lt;/p&gt;
&lt;h3 id="insertion_1"&gt;Insertion&lt;/h3&gt;
&lt;p&gt;The worst-case time of this operation is &lt;span class="math"&gt;\(O(\log N)\)&lt;/span&gt;. However, this actually can be
constant on average. Details see MAW p.205.&lt;/p&gt;
&lt;h3 id="deletemin_1"&gt;DeleteMin&lt;/h3&gt;
&lt;p&gt;We take &lt;span class="math"&gt;\(O(\log N)\)&lt;/span&gt; time to find the tree containing the minimum element. We take
constant time to create the queues &lt;span class="math"&gt;\(H'\)&lt;/span&gt; and &lt;span class="math"&gt;\(H''\)&lt;/span&gt;. Merging these
two queues takes &lt;span class="math"&gt;\(O(\log N)\)&lt;/span&gt; time and thus, the operation overall takes &lt;span class="math"&gt;\(O(\log N)\)&lt;/span&gt;.&lt;/p&gt;
&lt;h2 id="reference"&gt;Reference&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;MAW Chapter 6&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="footnote"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;For actual implementation details, please see MAW p. 208 - 211.&amp;#160;&lt;a class="footnote-backref" href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['CommonHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' }, Macros: {} }," +
        "    jax: ['input/TeX','input/MathML','output/CommonHTML']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Zeyuan Hu</dc:creator><pubDate>Sat, 08 Apr 2017 23:33:00 +0800</pubDate><guid isPermaLink="false">tag:zhu45.org,2017-04-08:posts/2017/Apr/08/binomial-queue/</guid><category>heaps</category><category>maw</category></item><item><title>Skew heap</title><link>http://zhu45.org/posts/2017/Apr/05/skew-heap/</link><description>&lt;p&gt;This is the summary of &lt;em&gt;skew heap&lt;/em&gt; part in MAW Chapter 6.&lt;/p&gt;
&lt;h2 id="motivation"&gt;Motivation&lt;/h2&gt;
&lt;p&gt;Like the relation between splay trees and AVL trees, we want to have 
&lt;span class="math"&gt;\(O(\log N)\)&lt;/span&gt; amortized cost per operation. In addition, we don't want
to have any auxiliary information stored at the nodes. In other words,
we want to trade strict &lt;span class="math"&gt;\(O(\log N)\)&lt;/span&gt; operation for less space we need 
to use for the data structure. In this case,
like splay trees to AVL trees, we have Skew heaps to leftist heaps.&lt;/p&gt;
&lt;h2 id="concept"&gt;Concept&lt;/h2&gt;
&lt;p&gt;Skew heaps are binary trees with heap order, but there is no structural constraint
on these trees. This means that we don't need the binary tree to be complete 
(i.e. binary heap) or left heavy (i.e. leftist heap).&lt;/p&gt;
&lt;p&gt;In addition, we don't store &lt;span class="math"&gt;\(Npl\)&lt;/span&gt; information in the node.&lt;/p&gt;
&lt;h2 id="properties"&gt;Properties&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;A perfectly balanced tree forms if the keys &lt;span class="math"&gt;\(1\)&lt;/span&gt; to &lt;span class="math"&gt;\(2^k-1\)&lt;/span&gt; are inserted in order
into an initially empty skew heap.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="operations"&gt;Operations&lt;/h2&gt;
&lt;p&gt;Skew heap is extremely similar with leftist heap in terms of &lt;code&gt;merge&lt;/code&gt; operation. 
There is only one difference: for leftist heap, we check to see whether the 
left and right children satisfy the leftist heap order property and swap them
if they do not. However, for skew heaps, the swap is unconditional. In other words,
we &lt;strong&gt;always&lt;/strong&gt; swap the left &amp;amp; right subtrees at each step of merge. &lt;/p&gt;
&lt;p&gt;In the below example, we want to merge two skew heaps &lt;span class="math"&gt;\(H_1\)&lt;/span&gt; and &lt;span class="math"&gt;\(H_2\)&lt;/span&gt;:&lt;/p&gt;
&lt;p&gt;&lt;img src="/images/skew-heap-01.PNG" alt="skew heap 01" style="width: 700px;"/&gt;&lt;/p&gt;
&lt;p&gt;Then, we get the following result of merging &lt;span class="math"&gt;\(H_2\)&lt;/span&gt; with &lt;span class="math"&gt;\(H_1\)&lt;/span&gt;'s right subheap:&lt;/p&gt;
&lt;p&gt;&lt;img src="/images/skew-heap-02.PNG" alt="skew heap 02" style="width: 700px;"/&gt;&lt;/p&gt;
&lt;p&gt;and this is the final merge result:&lt;/p&gt;
&lt;p&gt;&lt;img src="/images/skew-heap-03.PNG" alt="skew heap 03" style="width: 700px;"/&gt;&lt;/p&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;The end result is actually leftist heap but there is no guaranteed that this is
always the case. If you take a look, &lt;span class="math"&gt;\(H_1\)&lt;/span&gt; is not lefist heap.&lt;/p&gt;
&lt;/div&gt;
&lt;h2 id="runtime-analysis"&gt;Runtime analysis&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;merge&lt;/code&gt;, &lt;code&gt;deleteMin&lt;/code&gt;, and &lt;code&gt;insert&lt;/code&gt; are all running in &lt;span class="math"&gt;\(O(\log N)\)&lt;/span&gt; amortized time.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="links-to-resources"&gt;Links to resources&lt;/h2&gt;
&lt;p&gt;Here are some of the resources I found helpful while preparing this article:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MAW Chapter 6&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.cs.cmu.edu/~ckingsf/bioinfo-lectures/heaps.pdf"&gt;CMU lecture slides&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['CommonHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' }, Macros: {} }," +
        "    jax: ['input/TeX','input/MathML','output/CommonHTML']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Zeyuan Hu</dc:creator><pubDate>Wed, 05 Apr 2017 23:33:00 +0800</pubDate><guid isPermaLink="false">tag:zhu45.org,2017-04-05:posts/2017/Apr/05/skew-heap/</guid><category>heaps</category><category>maw</category></item><item><title>Leftist heap</title><link>http://zhu45.org/posts/2017/Apr/04/leftist-heap/</link><description>&lt;p&gt;This is the summary of &lt;em&gt;leftist heaps&lt;/em&gt; part in MAW Chapter 6.&lt;/p&gt;
&lt;h2 id="motivation"&gt;Motivation&lt;/h2&gt;
&lt;p&gt;Merge two priority queues into one can be a very hard operation to do. For binary
heap, this can be done at &lt;span class="math"&gt;\(O(N)\)&lt;/span&gt;. However, we want to do better. Leftist heap
is a priority queue that supports merge operation in &lt;span class="math"&gt;\(O(\log N)\)&lt;/span&gt;.&lt;/p&gt;
&lt;h2 id="concept"&gt;Concept&lt;/h2&gt;
&lt;p&gt;The idea for leftist heap is that we want to make the tree structure imbalance
as much as possible to make merge fast. This is achieved by leftist heap property.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;null path length&lt;/em&gt; &lt;span class="math"&gt;\(Npl(X)\)&lt;/span&gt; of any node &lt;span class="math"&gt;\(X\)&lt;/span&gt; is the length of the shortest path 
from &lt;span class="math"&gt;\(X\)&lt;/span&gt; to a node without two children. Thus, the &lt;span class="math"&gt;\(Npl\)&lt;/span&gt; of a node with zero or
one child is 0 and &lt;span class="math"&gt;\(Npl(NULL) = -1\)&lt;/span&gt;. In addition, the &lt;span class="math"&gt;\(Npl\)&lt;/span&gt; of any node is 1 more
than the minimum of the &lt;span class="math"&gt;\(Npl\)&lt;/span&gt; of its children.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;leftist heap property is that for every node &lt;span class="math"&gt;\(X\)&lt;/span&gt; in the heap, the &lt;span class="math"&gt;\(Npl\)&lt;/span&gt; of the
left child is at least as large as that of the right child.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;In fact, the leftist heap property is the leftist property applies to heap.
In other words, if every node in a tree has the &lt;span class="math"&gt;\(Npl\)&lt;/span&gt; of the left child
is at least as large as that of the right child, then we call this tree
a &lt;em&gt;leftist tree&lt;/em&gt;. A leftist heap is simply a leftist tree with keys in heap order.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The number in the each node below is the &lt;span class="math"&gt;\(Npl\)&lt;/span&gt; of that node. By the leftist property,
only the left tree is leftist.&lt;/p&gt;
&lt;p&gt;&lt;img src="/images/leftist-tree-example.PNG" alt="leftist tree example" style="width: 700px;"/&gt;&lt;/p&gt;
&lt;h2 id="properties"&gt;Properties&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;If rightmost path of leftist tree has &lt;span class="math"&gt;\(r\)&lt;/span&gt; nodes, then the whole tree has at least
&lt;span class="math"&gt;\(2^r-1\)&lt;/span&gt; nodes. &lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;The above property leads to: &lt;span class="math"&gt;\(n \ge 2^r-1\)&lt;/span&gt;, so &lt;span class="math"&gt;\(r\)&lt;/span&gt; is &lt;span class="math"&gt;\(O(\log N)\)&lt;/span&gt;. Since our 
fundamental operation &lt;code&gt;merge&lt;/code&gt; will perform all the work on the right path,
then we can have a &lt;span class="math"&gt;\(O(\log N)\)&lt;/span&gt; &lt;code&gt;merge&lt;/code&gt; operation.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;A perfectly balanced tree forms if keys 1 to &lt;span class="math"&gt;\(2^k-1\)&lt;/span&gt; are inserted in order into an
initially empty leftist heap.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="operations"&gt;Operations&lt;/h2&gt;
&lt;h3 id="mergeh1-h2"&gt;&lt;code&gt;merge(H1, H2)&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;As with &lt;a href="http://zhu45.org/posts/2017/Feb/13/splay-tree/"&gt;splay&lt;/a&gt; in splay trees, &lt;code&gt;merge&lt;/code&gt; is
the fundamental operation that is used to implement other operations in leftist 
heap(i.e., &lt;code&gt;insert&lt;/code&gt;, &lt;code&gt;deleteMin&lt;/code&gt;). &lt;/p&gt;
&lt;p&gt;The key point for the merge operation are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;recursively merge the heap with the larger root with the right subheap of the heap
with the smaller root.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;We update &lt;span class="math"&gt;\(Npl\)&lt;/span&gt; of the merged root and swap left and right subtrees just below
root, if needed, to keep leftist property of merged result.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The following picture shows a good example of &lt;code&gt;merge&lt;/code&gt; steps. Note that the &lt;span class="math"&gt;\(Npl\)&lt;/span&gt; of the node in
picture is 1 larger than our's definition. The blue curve represents the final
swap step.&lt;/p&gt;
&lt;p&gt;&lt;img src="/images/leftist-heap-merge.PNG" alt="leftist heap merge example" style="width: 700px;"/&gt;&lt;/p&gt;
&lt;p&gt;Another example can be seen from MAW 6.16 in 
&lt;a href="http://zhu45.org/posts/2017/Mar/26/maw-chapter-6-priority-queues-heaps-writing-questions/"&gt;my chapter 6 writing question post&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The actual implementation in C is below, which is copied from maw p.198:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;PriorityQueue&lt;/span&gt;
&lt;span class="nf"&gt;Merge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;PriorityQueue&lt;/span&gt; &lt;span class="n"&gt;H1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;PriorityQueue&lt;/span&gt; &lt;span class="n"&gt;H2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;H1&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;H2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;H2&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;H1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;H1&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Element&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;H2&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Element&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;Merge1&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;H1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;H2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;H1&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Element&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;H2&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Element&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;Merge2&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;H2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;H1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="n"&gt;PriorityQueue&lt;/span&gt;
&lt;span class="nf"&gt;Merge1&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;PriorityQueue&lt;/span&gt; &lt;span class="n"&gt;H1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;PriorityQueue&lt;/span&gt; &lt;span class="n"&gt;H2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;H1&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Left&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;H1&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Left&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;H2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// Single node; H1-&amp;gt;Right is already NULL&lt;/span&gt;
  &lt;span class="k"&gt;else&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;H1&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Right&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Merge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;H1&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Right&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;H2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;H1&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Left&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Npl&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;H1&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Right&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Npl&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;swapChildren&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;H1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;H1&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Npl&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;H1&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Right&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Npl&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;    
  &lt;span class="p"&gt;}&lt;/span&gt;    
  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;H1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id="insert"&gt;insert&lt;/h3&gt;
&lt;p&gt;We can carry out insertion by making the item to be inserted a one-node heap
and perform a merge. &lt;/p&gt;
&lt;p&gt;Reference section offers a link to visualize the whole insertion process. The
actual implementation is on maw p.199 and copied below:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;PriorityQueue&lt;/span&gt;
&lt;span class="nf"&gt;Insert1&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ElementType&lt;/span&gt; &lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;PriorityQueue&lt;/span&gt; &lt;span class="n"&gt;H&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;PriorityQueue&lt;/span&gt; &lt;span class="n"&gt;SingleNode&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="n"&gt;SingleNode&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;malloc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
  &lt;span class="n"&gt;assert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;SingleNode&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

  &lt;span class="n"&gt;SingleNode&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Element&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;SingleNode&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Npl&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;SingleNode&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Left&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;SingleNode&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Right&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;H&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;merge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;SingleNode&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;H&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;H&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;    
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id="deletemin"&gt;deleteMin&lt;/h3&gt;
&lt;p&gt;deleteMin can be done by remove the root and merge the left and subtree tree into
a new leftist heap.&lt;/p&gt;
&lt;p&gt;The actual implementation is on maw p.200 and copied below:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;PriorityQueue&lt;/span&gt;
&lt;span class="nf"&gt;DeleteMin&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;PriorityQueue&lt;/span&gt; &lt;span class="n"&gt;H&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;PriorityQueue&lt;/span&gt; &lt;span class="n"&gt;LeftHeap&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;RightHeap&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;IsEmpty&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;H&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;Error&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Priority queue is empty&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;H&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;    
  &lt;span class="p"&gt;}&lt;/span&gt;    
  &lt;span class="n"&gt;LeftHeap&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;H&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Left&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;RightHeap&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;H&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Right&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;free&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;H&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;Merge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;LeftHeap&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;RightHeap&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id="buildheap"&gt;BuildHeap&lt;/h3&gt;
&lt;p&gt;As described in MAW 6.22, we can perform &lt;code&gt;BuildHeap&lt;/code&gt; in linear time for leftist 
heaps by considering each element as a one-node leftist heap, placing all these
heaps on a queue, and performing the following step: Until only one heap is on 
the queue, dequeue two heaps, merge them, and enqueue the result.&lt;/p&gt;
&lt;p&gt;This algorithm is &lt;span class="math"&gt;\(O(N)\)&lt;/span&gt; in the worst time.&lt;/p&gt;
&lt;h2 id="runtime-analysis"&gt;Runtime analysis&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;merge&lt;/code&gt;, &lt;code&gt;deleteMin&lt;/code&gt;, and &lt;code&gt;insert&lt;/code&gt; are all running in &lt;span class="math"&gt;\(O(\log N)\)&lt;/span&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="reference"&gt;Reference&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;MAW Chapter 6&lt;/li&gt;
&lt;li&gt;http://www.cs.cmu.edu/~ckingsf/bioinfo-lectures/heaps.pdf&lt;/li&gt;
&lt;li&gt;https://www.cs.usfca.edu/~galles/visualization/LeftistHeap.html (good tool to visualize the operations)&lt;/li&gt;
&lt;li&gt;http://courses.cs.washington.edu/courses/cse326/08sp/lectures/05-leftist-heaps.pdf&lt;/li&gt;
&lt;/ul&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['CommonHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' }, Macros: {} }," +
        "    jax: ['input/TeX','input/MathML','output/CommonHTML']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Zeyuan Hu</dc:creator><pubDate>Tue, 04 Apr 2017 10:30:00 +0800</pubDate><guid isPermaLink="false">tag:zhu45.org,2017-04-04:posts/2017/Apr/04/leftist-heap/</guid><category>heaps</category><category>maw</category></item><item><title>Binary heap</title><link>http://zhu45.org/posts/2017/Apr/02/binary-heap/</link><description>&lt;p&gt;This is the summary of &lt;em&gt;binary heap&lt;/em&gt; and its generalization &lt;em&gt;d-heap&lt;/em&gt; part in MAW Chapter 6.&lt;/p&gt;
&lt;h2 id="motivation"&gt;Motivation&lt;/h2&gt;
&lt;p&gt;The motivation for priority queue majorly comes from the fact that not all things
are equally weighted. I'll summarize the applications of priority queues in my
end-chapter summary post. &lt;/p&gt;
&lt;h2 id="concept"&gt;Concept&lt;/h2&gt;
&lt;p&gt;A binary heap is a binary tree (NOT a BST) that is:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Complete (structure property):&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;the tree is completely filled except possibly the bottom level, which is filled
from left to right.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;satisfies the heap order property:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;For every nodex &lt;span class="math"&gt;\(X\)&lt;/span&gt;, the key in the parent of &lt;span class="math"&gt;\(X\)&lt;/span&gt; is smaller than (or equal to) the
key in &lt;span class="math"&gt;\(X\)&lt;/span&gt;, with the exception of the root (which has no parent). In other words,
every node is less than or equal to its children.&lt;/p&gt;
&lt;p&gt;This property guarantees that the root node is always the smallest node &lt;sup id="fnref:1"&gt;&lt;a class="footnote-ref" href="#fn:1" rel="footnote"&gt;1&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;
&lt;p&gt;Here are some examples:&lt;/p&gt;
&lt;p&gt;&lt;img src="/images/binary-heap.PNG" alt="binary heap examples" style="width: 700px;"/&gt;&lt;/p&gt;
&lt;h2 id="properties"&gt;Properties&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Since complete binary tree of height &lt;span class="math"&gt;\(h\)&lt;/span&gt; has between &lt;span class="math"&gt;\(2^h\)&lt;/span&gt; and &lt;span class="math"&gt;\(2^{h+1}-1\)&lt;/span&gt; nodes, 
  the height of a binary heap is &lt;span class="math"&gt;\(O(\log N)\)&lt;/span&gt;.&lt;/li&gt;
&lt;li&gt;For binary heaps, &lt;code&gt;BuildHeap&lt;/code&gt; does at most &lt;span class="math"&gt;\(2N-2\)&lt;/span&gt; comparisons between elements.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="remarks-on-implementation"&gt;Remarks on implementation&lt;/h2&gt;
&lt;p&gt;We use array as the actual implementation for the binary heap above. 
For any element in array position &lt;span class="math"&gt;\(i\)&lt;/span&gt;, the left child is in position &lt;span class="math"&gt;\(2i\)&lt;/span&gt;, the
right child is in the cell after the left child &lt;span class="math"&gt;\((2i+1)\)&lt;/span&gt;, and the parent is in position
&lt;span class="math"&gt;\(\lfloor i/2 \rfloor\)&lt;/span&gt;. Position 0 is used as a sentinel.&lt;/p&gt;
&lt;p&gt;The reason we use the array implementation is that dealing with pointers are quite
expensive to do.&lt;/p&gt;
&lt;h2 id="operations"&gt;Operations&lt;/h2&gt;
&lt;h3 id="insert"&gt;Insert&lt;/h3&gt;
&lt;p&gt;We add the value as the new node at the end of the array, which is the next avaliable
location in the tree. Then, we need to maintain the heap order property by doing 
a simple insertion sort operation on the path from the new place to the root to find
the correct place for it in the tree. This is called &lt;em&gt;percolate up&lt;/em&gt; &lt;sup id="fnref:2"&gt;&lt;a class="footnote-ref" href="#fn:2" rel="footnote"&gt;2&lt;/a&gt;&lt;/sup&gt;. &lt;/p&gt;
&lt;p&gt;&lt;img src="/images/binary-heap-percolate-up.PNG" alt="binary heap percolate up" style="width: 700px;"/&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;We start at last node and keep comparing with parent &lt;span class="math"&gt;\(A[i/2]\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;If parent larger, copy parent down and go up one level&lt;/li&gt;
&lt;li&gt;Done if parent &lt;span class="math"&gt;\(\le\)&lt;/span&gt; item or reached top node &lt;span class="math"&gt;\(A[1]\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src="/images/binary-heap-percolate-up-done.PNG" alt="binary heap percolate up done"/&gt;&lt;/p&gt;
&lt;h3 id="deletemin"&gt;DeleteMin&lt;/h3&gt;
&lt;p&gt;We delete and return the value at root node in this operation. Same as the insert, 
we need to maintain the binary heap properties. &lt;/p&gt;
&lt;p&gt;By removing the root node's value, we have a "hole" at the root. We use the last
node's value in the tree to fill in the hole. By doing this way, we maintain the 
structure property. Now, we need to maintain the heap order property. Similar to 
insertion, we can do a simple insertion sort-like operation to find the correct
place for it in the tree. This is called &lt;em&gt;percolate down&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src="/images/binary-heap-percolate-down.PNG" alt="binary heap percolate down" style="width: 700px;"/&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Keep comparing with children &lt;span class="math"&gt;\(A[2i]\)&lt;/span&gt; and &lt;span class="math"&gt;\(A[2i+1]\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;Copy smaller child up and go down one level&lt;/li&gt;
&lt;li&gt;Done if both children are &lt;span class="math"&gt;\(\ge\)&lt;/span&gt; item or reached a leaf node&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="other-heap-operations"&gt;Other heap operations&lt;/h3&gt;
&lt;p&gt;The following operations (with &lt;span class="math"&gt;\(P\)&lt;/span&gt; argument) require the position of every element in the heap known
by some other method in order to make them cheap to perform.&lt;/p&gt;
&lt;h4 id="decreasekeyp-delta-h"&gt;&lt;code&gt;DecreaseKey&lt;/code&gt;(P, &lt;span class="math"&gt;\(\delta\)&lt;/span&gt;, H)&lt;/h4&gt;
&lt;p&gt;decrease the key value of node at position &lt;span class="math"&gt;\(P\)&lt;/span&gt; by a positive amount &lt;span class="math"&gt;\(\delta\)&lt;/span&gt;. We 
can first subtract &lt;span class="math"&gt;\(\delta\)&lt;/span&gt; from current value at &lt;span class="math"&gt;\(P\)&lt;/span&gt;. Then we &lt;em&gt;percolate up&lt;/em&gt; to fix.
This requires &lt;span class="math"&gt;\(O(\log N)\)&lt;/span&gt; time.&lt;/p&gt;
&lt;h4 id="increasekeyp-delta-h"&gt;&lt;code&gt;IncreaseKey&lt;/code&gt;(P, &lt;span class="math"&gt;\(\delta\)&lt;/span&gt;, H)&lt;/h4&gt;
&lt;p&gt;increase the key value of node at position &lt;span class="math"&gt;\(P\)&lt;/span&gt; by a positive amount &lt;span class="math"&gt;\(\delta\)&lt;/span&gt;. We
can add &lt;span class="math"&gt;\(\delta\)&lt;/span&gt; to current value at &lt;span class="math"&gt;\(P\)&lt;/span&gt; then &lt;em&gt;percolate down&lt;/em&gt; to fix. This requires
&lt;span class="math"&gt;\(O(\log N)\)&lt;/span&gt; time.&lt;/p&gt;
&lt;h4 id="deleteph"&gt;&lt;code&gt;Delete(P,H)&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;removes the node at position &lt;span class="math"&gt;\(P\)&lt;/span&gt; from the heap. We can use &lt;code&gt;DecreaseKey&lt;/code&gt;(P, &lt;span class="math"&gt;\(\infty\)&lt;/span&gt;, H)
followed by &lt;code&gt;DeleteMin&lt;/code&gt;. The running time is &lt;span class="math"&gt;\(O(\log N)\)&lt;/span&gt;.&lt;/p&gt;
&lt;h4 id="buildheaph"&gt;&lt;code&gt;Buildheap(H)&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;takes as input &lt;span class="math"&gt;\(N\)&lt;/span&gt; keys and construct a binary heap from it. This is known as Floyd's algorithm.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Place the &lt;span class="math"&gt;\(N\)&lt;/span&gt; keys into the tree in order. This satisfies the structure property.&lt;/li&gt;
&lt;li&gt;Then we do the following to maintain the heap order property.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;for( i = N/2; i &amp;gt; 0; i--)
  PercolateDown(i);
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This alogrithm runs in &lt;span class="math"&gt;\(O(N)\)&lt;/span&gt; time. Detailed proof see MAW p.189.&lt;/p&gt;
&lt;h4 id="mergeh1h2"&gt;&lt;code&gt;Merge(H1,H2)&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;We merge two heaps &lt;span class="math"&gt;\(H1\)&lt;/span&gt; and &lt;span class="math"&gt;\(H2\)&lt;/span&gt; of size &lt;span class="math"&gt;\(O(N)\)&lt;/span&gt;. &lt;span class="math"&gt;\(H1\)&lt;/span&gt; and &lt;span class="math"&gt;\(H2\)&lt;/span&gt; are stored in two
arrays. We can do &lt;span class="math"&gt;\(O(N)\)&lt;/span&gt; insert but this requires &lt;span class="math"&gt;\(O(N\log N)\)&lt;/span&gt; time. We can do better
by copy &lt;span class="math"&gt;\(H2\)&lt;/span&gt; at the end of &lt;span class="math"&gt;\(H1\)&lt;/span&gt; and use &lt;code&gt;BuildHeap&lt;/code&gt;. This requires &lt;span class="math"&gt;\(O(N)\)&lt;/span&gt; time &lt;sup id="fnref:3"&gt;&lt;a class="footnote-ref" href="#fn:3" rel="footnote"&gt;3&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;
&lt;h2 id="runtime-analysis"&gt;Runtime analysis&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Space: &lt;span class="math"&gt;\(O(N)\)&lt;/span&gt; (an array of size &lt;span class="math"&gt;\(N+1\)&lt;/span&gt;)&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Insert: &lt;span class="math"&gt;\(O(\log N)\)&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DeleteMin: &lt;span class="math"&gt;\(O(\log N)\)&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="d-heaps"&gt;d-heaps&lt;/h1&gt;
&lt;p&gt;d-heaps is the generalization of binary heap: we have &lt;span class="math"&gt;\(d\)&lt;/span&gt; children instead of 2.
Similar to B-tree, this structure will makes the heaps shallower and is useful for
heaps too big for memory. &lt;/p&gt;
&lt;p&gt;Everything is same to the binary heap except that it takes &lt;span class="math"&gt;\(d-1\)&lt;/span&gt; comparisons to find
the minimum of &lt;span class="math"&gt;\(d\)&lt;/span&gt; children (in binary heap, we do comparison once). Then, for
&lt;code&gt;DeleteMin&lt;/code&gt;, for example, takes &lt;span class="math"&gt;\(O(d\log_d N)\)&lt;/span&gt;. Other operations runtime adjusts similarly.&lt;/p&gt;
&lt;p&gt;In terms of array implementation, for entry located in position &lt;span class="math"&gt;\(i\)&lt;/span&gt;, the parent is
at &lt;span class="math"&gt;\(\lfloor{\frac{i + (d-2)}{d}}\rfloor\)&lt;/span&gt; and the children are at &lt;span class="math"&gt;\(id-(d-2), \dots, id+1\)&lt;/span&gt;.&lt;/p&gt;
&lt;h2 id="links-to-resources"&gt;Links to resources&lt;/h2&gt;
&lt;p&gt;Here are some of the resources I found helpful while preparing this article:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MAW Chapter 6&lt;/li&gt;
&lt;li&gt;Lecture slides &lt;a href="https://courses.cs.washington.edu/courses/cse332/10sp/lectures/lecture4.pdf"&gt;4&lt;/a&gt;,
&lt;a href="https://courses.cs.washington.edu/courses/cse373/06sp/handouts/lecture08.pdf"&gt;8&lt;/a&gt;, and 
&lt;a href="https://courses.cs.washington.edu/courses/cse373/06sp/handouts/lecture11.pdf"&gt;11&lt;/a&gt; from U.Washington&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="footnote"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;The heap order property is for min heap. If you want to have a max heap, then
the heap order property should be that every node is greater than or equal to 
its children.&amp;#160;&lt;a class="footnote-backref" href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:2"&gt;
&lt;p&gt;Position 0 is used as a sentinel, which holds the value that is smaller than
(or equal to) any element in the heap. This is because every iteration of insert
needs to test: 1. if it has reached the top node A[1] 2. if parent &lt;span class="math"&gt;\(\le\)&lt;/span&gt; item
The first test can be avoid by using sentinel b/c it then becomes a special case
of second test.&amp;#160;&lt;a class="footnote-backref" href="#fnref:2" rev="footnote" title="Jump back to footnote 2 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:3"&gt;
&lt;p&gt;As shown on MAW p.183, empirical study shows that on average, percolation terminates
early: average &lt;em&gt;insert&lt;/em&gt; moves an element up 1.607 levels. This means that 
binary heap support insertion in &lt;em&gt;constant average&lt;/em&gt; time per operation.&amp;#160;&lt;a class="footnote-backref" href="#fnref:3" rev="footnote" title="Jump back to footnote 3 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['CommonHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' }, Macros: {} }," +
        "    jax: ['input/TeX','input/MathML','output/CommonHTML']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Zeyuan Hu</dc:creator><pubDate>Sun, 02 Apr 2017 11:30:00 +0800</pubDate><guid isPermaLink="false">tag:zhu45.org,2017-04-02:posts/2017/Apr/02/binary-heap/</guid><category>heaps</category><category>maw</category></item><item><title>MAW Chapter 6: Priority Queues (Heaps) writing questions</title><link>http://zhu45.org/posts/2017/Mar/26/maw-chapter-6-priority-queues-heaps-writing-questions/</link><description>&lt;h2 id="solutions"&gt;Solutions&lt;/h2&gt;
&lt;p&gt;including: MAW 6.6, 6.7, 6.9, 6.13, 6.14, 6.16, 6.17, 6.27, 6.28,&lt;/p&gt;
&lt;h3 id="maw-66"&gt;MAW 6.6&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;How many nodes are in the large heap in Figure 6.13?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;This question is interesting in the sense that the algorithm of counting reflecting
the underneath implemenation structure. Since the binary heap is actually implemented 
in terms of array, we start with &lt;span class="math"&gt;\(i = 1\)&lt;/span&gt; and position at the root. We follow the path
toward the last node, doubling &lt;span class="math"&gt;\(i\)&lt;/span&gt; when taking a left child, and doubling &lt;span class="math"&gt;\(i\)&lt;/span&gt; and adding
one when taking a right child. Then, we have the following calculation:
&lt;span class="math"&gt;\(2(2(2(2(2(2(2i+1)+1)))))+1 = 225\)&lt;/span&gt;. The picture below shows the path from the root 
to the node in the last position:&lt;/p&gt;
&lt;p&gt;&lt;img src="/images/maw-6-6.PNG" alt="MAW 6.6"/&gt;&lt;/p&gt;
&lt;h3 id="maw-67"&gt;MAW 6.7&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;b. show that a heap of eight elements can be constructed in eight comparisons between 
   heap elements.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Thie question is interesting because it offers another method we can use when build a binary
heap with even number of elements. That is, we build binomial queue first. since the binary 
form of &lt;span class="math"&gt;\(8\)&lt;/span&gt; is &lt;span class="math"&gt;\(1000_2\)&lt;/span&gt;, this means we will have only one binomial tree &lt;span class="math"&gt;\(B_3\)&lt;/span&gt; inside the binomial queue.
Once we construct this binomial tree, we need one last step to tweek the binomial tree to
follow binary heap property, namely each node has to have either zero or two children.&lt;/p&gt;
&lt;p&gt;For this question, it takes seven comparisons to construct the binomial queue (with a solo binomial tree)
and we get the following:&lt;/p&gt;
&lt;p&gt;&lt;img src="/images/maw-6-7-b.PNG" alt="MAW 6.7.b"/&gt;&lt;/p&gt;
&lt;p&gt;Then we need to restore the binary heap property because "a" node has three children.
This can be done by the eighth compariosn between "b" and "c". If "c" is less than "b",
then "b" is made a child of "c". Otherwise, both "c" and "d" are made children of "b".&lt;/p&gt;
&lt;h3 id="maw-69"&gt;MAW 6.9&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;a. Give an algorithm to find all nodes less than some value, X, in a binary heap.
   Your algorithm should run in &lt;span class="math"&gt;\(O(K)\)&lt;/span&gt;, where &lt;span class="math"&gt;\(K\)&lt;/span&gt; is the number of nodes output.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The big idea is that we perform a preorder traversal of the heap. In detail, we start
from the root of the heap. If value of the root is smaller than &lt;span class="math"&gt;\(X\)&lt;/span&gt;, then we output
this value and call procedure recursively once for its left child and once for its right 
child. If the value of a node is bigger or equal than &lt;span class="math"&gt;\(X\)&lt;/span&gt;, then the procedure halts
without printing the value. We don't need to check the children by heap definition.&lt;/p&gt;
&lt;p&gt;The complexity of this algorithm is &lt;span class="math"&gt;\(O(N)\)&lt;/span&gt; in worst case, where &lt;span class="math"&gt;\(N\)&lt;/span&gt; is the total number
of nodes in the heap. This happens when every node in the heap is smaller than &lt;span class="math"&gt;\(X\)&lt;/span&gt;, and 
the procedure has to call each node of the heap.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;b. Does your algorithm extend to any of the other heap structures dicussed in 
   this chapter?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Yes. It works for leftist heap, skew heap, and d-heaps.&lt;/p&gt;
&lt;h3 id="maw-613"&gt;MAW 6.13&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;If a d-heap is stored as an array, for an entry located in position &lt;span class="math"&gt;\(i\)&lt;/span&gt;,
where are the parents and children?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Let's begin with children. Assume that position &lt;span class="math"&gt;\(i\)&lt;/span&gt; corresponds to the &lt;span class="math"&gt;\(X\)&lt;/span&gt;th node
of level &lt;span class="math"&gt;\(l\)&lt;/span&gt;. Therefore&lt;/p&gt;
&lt;div class="math"&gt;$$
i = \sum_{j=0}^{l-1}d^j+X
$$&lt;/div&gt;
&lt;p&gt;&lt;span class="math"&gt;\(\sum_{j=0}^{l-1}d^j\)&lt;/span&gt; is a geometric series whose first term equals &lt;span class="math"&gt;\(1\)&lt;/span&gt;, whose
common ratio is &lt;span class="math"&gt;\(d\)&lt;/span&gt;, and that contains &lt;span class="math"&gt;\(l\)&lt;/span&gt; terms in total. Thus, the result is
&lt;span class="math"&gt;\(\frac{d^l-1}{d-1}\)&lt;/span&gt; and thus, we have &lt;/p&gt;
&lt;div class="math"&gt;$$
i = \frac{d^l-1}{d-1} + X
$$&lt;/div&gt;
&lt;p&gt;We now calculate the position of &lt;span class="math"&gt;\(i\)&lt;/span&gt;'s second last child in terms of &lt;span class="math"&gt;\(d\)&lt;/span&gt;, &lt;span class="math"&gt;\(l\)&lt;/span&gt;, and
&lt;span class="math"&gt;\(X\)&lt;/span&gt;. This equals &lt;span class="math"&gt;\(i\)&lt;/span&gt;, plus the number of nodes after &lt;span class="math"&gt;\(i\)&lt;/span&gt; on level &lt;span class="math"&gt;\(l\)&lt;/span&gt;, plus &lt;span class="math"&gt;\(d\)&lt;/span&gt;
times the number of nodes before &lt;span class="math"&gt;\(i\)&lt;/span&gt; on level &lt;span class="math"&gt;\(l\)&lt;/span&gt;, plus &lt;span class="math"&gt;\(d-1\)&lt;/span&gt;.&lt;/p&gt;
&lt;div class="math"&gt;$$
\begin{eqnarray*}
&amp;amp;=&amp;amp; \frac{d^l-1}{d-1} + X + d^l - X + (X-1)d + d - 1 \\
&amp;amp;=&amp;amp; \frac{d^l-1}{d-1} + d^l-1 + dX \\
&amp;amp;=&amp;amp; \frac{d(d^l-1)}{d-1} + dX \\
&amp;amp;=&amp;amp; d(\frac{d^l-1}{d-1} + X) \\
&amp;amp;=&amp;amp; di
\end{eqnarray*}
$$&lt;/div&gt;
&lt;p&gt;Therefore the second last child of &lt;span class="math"&gt;\(i\)&lt;/span&gt; is in position &lt;span class="math"&gt;\(id\)&lt;/span&gt;. It follows that the children
of &lt;span class="math"&gt;\(i\)&lt;/span&gt; are in positions &lt;span class="math"&gt;\(id-(d-2), \dots, id+1\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;A node is a child of &lt;span class="math"&gt;\(i\)&lt;/span&gt; if and only if it is in one of the positions &lt;span class="math"&gt;\(id-(d-2), \dots, id+1\)&lt;/span&gt;.
So what you want here is a function that will map each of these to &lt;span class="math"&gt;\(i\)&lt;/span&gt;, but will not
map any other value to &lt;span class="math"&gt;\(i\)&lt;/span&gt;. Let &lt;span class="math"&gt;\(j\)&lt;/span&gt; be any of these values. Clearly,&lt;/p&gt;
&lt;div class="math"&gt;$$
\lfloor{\frac{j + (d-2)}{d}}\rfloor = i
$$&lt;/div&gt;
&lt;p&gt;But if &lt;span class="math"&gt;\(j\)&lt;/span&gt; is greater than &lt;span class="math"&gt;\(id+1\)&lt;/span&gt; or less than &lt;span class="math"&gt;\(id - (d-2)\)&lt;/span&gt; then&lt;/p&gt;
&lt;div class="math"&gt;$$
\lfloor{\frac{j + (d-2)}{d}}\rfloor \ne i
$$&lt;/div&gt;
&lt;p&gt;Thus we have our function which can now be used to work out the position of the
parent of &lt;span class="math"&gt;\(i\)&lt;/span&gt;.&lt;/p&gt;
&lt;div class="math"&gt;$$
\lfloor{\frac{i + (d-2)}{d}}\rfloor
$$&lt;/div&gt;
&lt;h2 id="maw-614"&gt;MAW 6.14&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Suppose we need to perform &lt;span class="math"&gt;\(M\)&lt;/span&gt; &lt;code&gt;PercolateUp&lt;/code&gt; and &lt;span class="math"&gt;\(N\)&lt;/span&gt; &lt;code&gt;DeleteMiin&lt;/code&gt; on a d-heap
that initially has &lt;span class="math"&gt;\(N\)&lt;/span&gt; elements.&lt;/p&gt;
&lt;p&gt;a. What is the total running time of all operations in terms of &lt;span class="math"&gt;\(M\)&lt;/span&gt;, &lt;span class="math"&gt;\(N\)&lt;/span&gt;, and &lt;span class="math"&gt;\(d\)&lt;/span&gt;?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;A &lt;code&gt;percolateUp&lt;/code&gt; operation on a d-heap with &lt;span class="math"&gt;\(N\)&lt;/span&gt; elements takes &lt;span class="math"&gt;\(O(\log_d N)\)&lt;/span&gt; steps.
The key is that each time we bubble the hole up, we only do comparison once: 
compare the insertion value with the parent of the hole (Figure 6.6, 6.7 helps understanding).&lt;/p&gt;
&lt;p&gt;A &lt;code&gt;deleteMin&lt;/code&gt; operation on a d-heap with &lt;span class="math"&gt;\(N\)&lt;/span&gt; elements takes &lt;span class="math"&gt;\(O(d \log_d N)\)&lt;/span&gt; steps.
Here, we need to feel the empty hole with the minimum value of its children. This can
take &lt;span class="math"&gt;\(d\)&lt;/span&gt; comparison to find the minimum (see p.184). &lt;/p&gt;
&lt;p&gt;Thus in total this will take &lt;span class="math"&gt;\(O(M\log_d N + Nd\log_d N)\)&lt;/span&gt; steps.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;b. If &lt;span class="math"&gt;\(d = 2\)&lt;/span&gt;, what is the running time of all heap operations?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Substitute 2 into the formula calculated in part a) gives &lt;span class="math"&gt;\(O((M+N)\log_2 N)\)&lt;/span&gt;.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;c. If &lt;span class="math"&gt;\(d = \theta (N)\)&lt;/span&gt;, what is the total running time?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;If &lt;span class="math"&gt;\(d = \theta (N)\)&lt;/span&gt; then &lt;span class="math"&gt;\(d = cN\)&lt;/span&gt;, where &lt;span class="math"&gt;\(c\)&lt;/span&gt; is a constant value independent of &lt;span class="math"&gt;\(N\)&lt;/span&gt;.
Substituting &lt;span class="math"&gt;\(cN\)&lt;/span&gt; into the formula calculated in part a) gives:&lt;/p&gt;
&lt;div class="math"&gt;$$ 
M\log_{cN} N + NcN \log_{cN}N = O(M + N^2)
$$&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;d. What choice of &lt;span class="math"&gt;\(d\)&lt;/span&gt; minimizes the total running time?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span class="math"&gt;\(d = max(2, M/N)\)&lt;/span&gt; (See the related discussion at the end of Section 11.4)&lt;/p&gt;
&lt;!--http://mail.csis.ul.ie/~cs4115/resources/sol10.pdf--&gt;

&lt;h2 id="maw-616"&gt;MAW 6.16&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Merge the two leftist heaps in Figure 6.58&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src="/images/maw-6-16-problem.PNG" alt="MAW 6.16"/&gt;&lt;/p&gt;
&lt;p&gt;The book doesn't do a well job on displaying the detailed steps in merging the 
leftist heap. So, I decide to use this problem as an illustration. By algorithm
description on p. 194 and the actual algorithm implementation on p.189., there are
two key points in the algorithm:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;recursively merge the heap with the larger root with the right subheap of
the heap with the smaller root.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;We do the swap at the root.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The following shows the steps to get the final answer for this problem:&lt;/p&gt;
&lt;p&gt;&lt;img src="/images/maw-6-16-solution.jpg" alt="MAW 6.16 solution" style="width:700px;height:400px"/&gt;&lt;/p&gt;
&lt;h2 id="maw-617"&gt;MAW 6.17&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Show the result of inserting keys 1 to 15 in order into an initially empty leftist heap.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Use &lt;a href="https://www.cs.usfca.edu/~galles/visualization/LeftistHeap.html"&gt;this wonderful site&lt;/a&gt;
to see the whole process of insertion.&lt;/p&gt;
&lt;h2 id="maw-627"&gt;MAW 6.27&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Prove that a binomial tree &lt;span class="math"&gt;\(B_k\)&lt;/span&gt; has binomial trees &lt;span class="math"&gt;\(B_0, B_1, \dots, B_{k-1}\)&lt;/span&gt;
as children of the root.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;I'll try to use two ways to prove this. Both ways are by induction but one of them
is more mathematical formula involved.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Method 1&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Clearly the claim is true for &lt;span class="math"&gt;\(k = 1\)&lt;/span&gt;. Suppose it is true for all values &lt;span class="math"&gt;\(i = 1, 2, \dots, k-1\)&lt;/span&gt;.
Since for &lt;span class="math"&gt;\(B_k\)&lt;/span&gt;, we have &lt;span class="math"&gt;\(2^k\)&lt;/span&gt; nodes. Then, by the induction hypothesis, we have
&lt;span class="math"&gt;\(2^{k-1} = 1 + 2^0 + \dots + 2^{k-2}\)&lt;/span&gt;. Now, multiplying both sides of the equation
by 2, we have &lt;span class="math"&gt;\(2^k = 2 + 2 + \dots + 2^{k-1}\)&lt;/span&gt;, which is the same as
&lt;span class="math"&gt;\(2^k = 1 + 2^0 + \dots + 2^{k-1}\)&lt;/span&gt;. This completes the proof.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Method 2&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Again the claim is true for &lt;span class="math"&gt;\(k = 1\)&lt;/span&gt;. Suppose it is true for all values &lt;span class="math"&gt;\(i = 1, 2, \dots, k-1\)&lt;/span&gt;.
A &lt;span class="math"&gt;\(B_k\)&lt;/span&gt; tree is fromed by attaching a &lt;span class="math"&gt;\(B_{k-1}\)&lt;/span&gt; tree to the root of a &lt;span class="math"&gt;\(B_{k-1}\)&lt;/span&gt; tree.
Thus, by induction, it contains a &lt;span class="math"&gt;\(B_0\)&lt;/span&gt; through &lt;span class="math"&gt;\(B_{k-2}\)&lt;/span&gt; tree, as well as the
newly attached &lt;span class="math"&gt;\(B_{k-1}\)&lt;/span&gt; tree, proving the claim.&lt;/p&gt;
&lt;h2 id="maw-628"&gt;MAW 6.28&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Prove that a binomial tree of height &lt;span class="math"&gt;\(k\)&lt;/span&gt; has &lt;span class="math"&gt;\({k \choose d}\)&lt;/span&gt; nodes at depth &lt;span class="math"&gt;\(d\)&lt;/span&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Proof is by induction. Clearly the claim is true for &lt;span class="math"&gt;\(k=1\)&lt;/span&gt;. Assume true for 
all values &lt;span class="math"&gt;\(i=1,2,\dots,k\)&lt;/span&gt;. A &lt;span class="math"&gt;\(B_{k+1}\)&lt;/span&gt; tree is formed by attaching a &lt;span class="math"&gt;\(B_k\)&lt;/span&gt; tree
to the original &lt;span class="math"&gt;\(B_k\)&lt;/span&gt; tree. The original tree has &lt;span class="math"&gt;\({k \choose d}\)&lt;/span&gt; nodes at depth
&lt;span class="math"&gt;\(d\)&lt;/span&gt; by induction hypothesis. The attached tree had &lt;span class="math"&gt;\(\binom{k}{d-1}\)&lt;/span&gt; nodes at depth
&lt;span class="math"&gt;\(d-1\)&lt;/span&gt;, which are now at depth &lt;span class="math"&gt;\(d\)&lt;/span&gt;. Adding these two terms we have&lt;/p&gt;
&lt;div class="math"&gt;$$
\binom{k+1}{d} = \binom{k}{d} + \binom{k}{d-1}
$$&lt;/div&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['CommonHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' }, Macros: {} }," +
        "    jax: ['input/TeX','input/MathML','output/CommonHTML']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Zeyuan Hu</dc:creator><pubDate>Sun, 26 Mar 2017 12:01:00 +0800</pubDate><guid isPermaLink="false">tag:zhu45.org,2017-03-26:posts/2017/Mar/26/maw-chapter-6-priority-queues-heaps-writing-questions/</guid><category>heaps</category><category>proof</category><category>math</category><category>maw</category></item><item><title>MAW: Chapter 5 Reflection</title><link>http://zhu45.org/posts/2017/Mar/17/maw-chapter-5-reflection/</link><description>&lt;p&gt;This is the summary part of hash table and at the same time, it serves as the Chapter 5
reflection.&lt;/p&gt;
&lt;div class="section" id="reflection"&gt;
&lt;h2&gt;Reflection&lt;/h2&gt;
&lt;div class="section" id="motivation"&gt;
&lt;h3&gt;Motivation&lt;/h3&gt;
&lt;p&gt;In the previous chapter, we implement the dictionary (map) ADT using tree structure.
A typical find or insert operations require &lt;span class="math"&gt;\(O(\log N)\)&lt;/span&gt; time. However, this is
not good enough compared with &lt;span class="math"&gt;\(O(1)\)&lt;/span&gt; time. This is place where hash tables implementation
can shine. Hash tables is a data structure that is designed for &lt;span class="math"&gt;\(O(1)\)&lt;/span&gt; find, insert, and delete
operations. The only downside compared hash tables with tree structure is the ill support for ordering elements.&lt;/p&gt;
&lt;img src="/images/maw-chap5.PNG" alt="chapter5 ADT picture" style="width: 700px;"/&gt;&lt;/div&gt;
&lt;div class="section" id="general-idea"&gt;
&lt;h3&gt;General Idea&lt;/h3&gt;
&lt;p&gt;A hash table is an array of some fixed size. Then we use hash function to map each key
(i.e. a key is a string with an associated value) into some number in the range &lt;tt class="docutils literal"&gt;0&lt;/tt&gt; to
&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;Tablesize-1&lt;/span&gt;&lt;/tt&gt; and place it in the appropriate cell.&lt;/p&gt;
&lt;img alt="" src="/images/hashtable.PNG" /&gt;
&lt;p&gt;Ideally, two distinct keys get different cells. However, this is not possible because
there are a finite number of cells and a virtually infinite supply of keys. Thus the key
concern for hash table data structure is how to distribute the keys evenly among the cells.
This issue is addressed from two ways:
1) pick a good hash function to avoid collision (i.e. two keys hash to the same value)
2) use a good strategy to redistribute keys when collision happens.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="hash-function"&gt;
&lt;h3&gt;Hash function&lt;/h3&gt;
&lt;p&gt;Hash function is a mapping from the element key (string or number) to an integer
(the hash value). The output of the hash function must always be less than the size of
array and should be as evenly distributed as possible. One thing to note here is that
the pick of hash function has high dependency on the actual content of the key set.&lt;/p&gt;
&lt;p&gt;We list some key points from the chapter here:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Choose the table size of the hash table to be the prime.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The rationale for this is that real-life data tends to have pattern, and &amp;quot;multiples of 61&amp;quot;
are probably less likely than &amp;quot;multiples of 60&amp;quot;. In addition, quadratic hashing is an efficient
collision strategy to use (compared with linear hashing, double hashing) and it requires the table size
to be the prime.&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;When we deal with string keys, we may use &lt;span class="math"&gt;\(\big(\sum_{i=0}^{k-1} s_i \cdot 256^i \big) \bmod TableSize\)&lt;/span&gt;
as our function.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Here we use 256 because &lt;cite&gt;char&lt;/cite&gt; data is 1 byte. Other hash function may be adding up the ASCII values ofthe characters
in the string. However, this doesn't work well because if string keys are short, it will not hash evenly to all of the
hash table (see MAW p.151) and different character combinations hash to same value (i.e. &amp;quot;abc&amp;quot;, &amp;quot;bca&amp;quot; all add up to the
same value).&lt;/p&gt;
&lt;p&gt;The slides listed in the reference section offer some examples on hash function pick if
we know the keys beforehand (i.e. if keys &lt;span class="math"&gt;\(s\)&lt;/span&gt; are the real numbers uniformly
distributed over &lt;span class="math"&gt;\(0 \leq s &amp;lt; 1\)&lt;/span&gt;).&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="collision-strategy"&gt;
&lt;h3&gt;Collision strategy&lt;/h3&gt;
&lt;p&gt;A collision occurs when two different keys hash to the same value. By the nature of dictionary ADT,
we cannot store both data records in the same cell in the array. So, we need to come up a strategy
to resolve collision and try our best to make the keys evenly distribute among the table. There are
two main strategies discussed in the chapter: separate chaining and open addressing.&lt;/p&gt;
&lt;div class="admonition note"&gt;
&lt;p class="first admonition-title"&gt;Note&lt;/p&gt;
&lt;p class="last"&gt;Load factor &lt;span class="math"&gt;\(\lambda\)&lt;/span&gt; defined as the ratio of the number of the elements
in the hash table to the table size. This concept appears frequently when we analyze
hash table collision resolution strategy.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="separate-chaining"&gt;
&lt;h4&gt;Separate chaining&lt;/h4&gt;
&lt;p&gt;Separate chaining is to keep a list (chain or bucket) of all elements that hash to the same value. In other words,
each hash table cell holds pointer to linked list of records with same hash value.
When collision happens, we insert the hash value of the key to the corresponding linked list of
the cell that hash value should be stored. When we want to find an item, we compute the
hash value, then do find on linked list.&lt;/p&gt;
&lt;img alt="" src="/images/separate-chaining.PNG" /&gt;
&lt;p&gt;Here the worst case time happens for find operation, which can take linear time.
However, this can happen in the extreme rare case (bad luck or bad hash function).
Of course, we can build a balance tree instead of a linked list on each cell to shrink
the find time. But, the structure overhead and the compelxity of insert may make this effort not
worth it.&lt;/p&gt;
&lt;p&gt;The average length of chained list = &lt;span class="math"&gt;\(\lambda\)&lt;/span&gt;. Thus, the average time for
accessing an item = &lt;span class="math"&gt;\(O(1) + O(\lambda)\)&lt;/span&gt;. So, we want &lt;span class="math"&gt;\(\lambda\)&lt;/span&gt; to be smaller
than 1 but close to 1 if good hashing function. Thus, the general rule for
separate chaining hashing is to make the table size about as large as the number of
elements expected (let &lt;span class="math"&gt;\(\lambda \approx 1\)&lt;/span&gt;).&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="open-addressing"&gt;
&lt;h4&gt;Open addressing&lt;/h4&gt;
&lt;p&gt;One disadvantage for the separate chaining strategy is that we need to build linked list
for each cell, whcih introduces the overhead that can waste space. Another strategy to
resolve collision is to try other empty cells. This is called open addressing. In general,
open addressing means resolving collisions by trying a sequence of other positions in the table.
Trying the next spot is called &lt;em&gt;probing&lt;/em&gt;. More formally, cells &lt;span class="math"&gt;\(h_0(X), h_1(x), h_2(x), \dots\)&lt;/span&gt;
are tried in succession until either x is found or we find an empty location (x not present).
&lt;span class="math"&gt;\(h_i(x) = (Hash(x) + F(i)) \bmod TableSize\)&lt;/span&gt;, with &lt;span class="math"&gt;\(F(0) = 0\)&lt;/span&gt;. The function &lt;span class="math"&gt;\(F\)&lt;/span&gt;
is the collision resolution strategy.&lt;/p&gt;
&lt;p&gt;Various flavors of open addressing differ in which probe sequence they use. This is reflected in &lt;span class="math"&gt;\(F\)&lt;/span&gt;.
Three types of resolution function are discussed in the book:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;Linear probing: &lt;span class="math"&gt;\(F(i) = i\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;Quadratic probing: &lt;span class="math"&gt;\(F(i) = i^2\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;Double hashing: &lt;span class="math"&gt;\(F(i) = i \cdot Hash_2(x)\)&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Generally, the load factor should be below &lt;span class="math"&gt;\(\lambda = 0.5\)&lt;/span&gt; for open addressing hashing.&lt;/p&gt;
&lt;div class="section" id="linear-probing"&gt;
&lt;h5&gt;Linear probing&lt;/h5&gt;
&lt;p&gt;With linear probing, we try the cells sequentially (with wraparound) insearch of an empty cell.
This strategy has a fundamental problem called &lt;em&gt;primary clustering&lt;/em&gt;, which means blocks
of occupied cells start forming. Any key that hashes into the cluster will require several
attempts to resolve the collision, and then it will add to the cluster. In other words, primary
clustering means elements that hash to different cells probe same alternative cells.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="quadratic-probing"&gt;
&lt;h5&gt;Quadratic probing&lt;/h5&gt;
&lt;p&gt;Quadratic probing is a collision resolution method that eliminates the primary clustering problem
of linear probing. But it has its own restriction or problem:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;If quadratic probing is used and the table size is prime, then a new element
can always be inserted if the table is at least half empty. However, insertion is not guaranteed
if &lt;span class="math"&gt;\(\lambda &amp;gt; 0.5\)&lt;/span&gt;.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Secondary clustering&lt;/em&gt;, which means elements that hash to the same position will probe the same alternative cells.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="double-hashing"&gt;
&lt;h5&gt;Double hashing&lt;/h5&gt;
&lt;p&gt;Double hashing &lt;span class="math"&gt;\(F\)&lt;/span&gt; says that we apply a second hash function to x and probe
at a distance &lt;span class="math"&gt;\(hash_2(x), 2hash_2(x), \dots\)&lt;/span&gt;, and so on.&lt;/p&gt;
&lt;p&gt;When &lt;span class="math"&gt;\(\lambda\)&lt;/span&gt; exceeds certain value, we need to build a bigger hash table of
approximately twice the size and be prime. This is called rehashing.&lt;/p&gt;
&lt;p&gt;In addition, when hash table cannot be contained in the memory and have to store part of structure on the disk,
then the disk I/O becomes the main cost. In this case, we use different hash scheme, which is called extendible hashing.
Like B-tree, this structure is widely applied in the database field.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="left-out"&gt;
&lt;h2&gt;Left Out&lt;/h2&gt;
&lt;p&gt;Some material I left out when I work through this chapter majorly due to the time
constraint:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;5.7, 5.12, 5.13, 5.15&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="reference"&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;MAW Chapter 5&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://courses.cs.washington.edu/courses/cse332/10sp/lectures/lecture10.pdf"&gt;https://courses.cs.washington.edu/courses/cse332/10sp/lectures/lecture10.pdf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://courses.cs.washington.edu/courses/cse373/06sp/handouts/lecture16.pdf"&gt;https://courses.cs.washington.edu/courses/cse373/06sp/handouts/lecture16.pdf&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['CommonHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' }, Macros: {} }," +
        "    jax: ['input/TeX','input/MathML','output/CommonHTML']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Zeyuan Hu</dc:creator><pubDate>Fri, 17 Mar 2017 15:56:00 +0800</pubDate><guid isPermaLink="false">tag:zhu45.org,2017-03-17:posts/2017/Mar/17/maw-chapter-5-reflection/</guid><category>meta</category><category>maw</category><category>hashing</category></item><item><title>MAW Chapter 5: Hashing writing questions</title><link>http://zhu45.org/posts/2017/Mar/16/maw-chapter-5-hashing-writing-questions/</link><description>&lt;h2 id="solutions"&gt;Solutions&lt;/h2&gt;
&lt;p&gt;including: MAW 5.4, 5.5, 5.6, 5.10, 5.11&lt;/p&gt;
&lt;h3 id="maw-54"&gt;MAW 5.4&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;A large number of deletions in a separate chaining hash table can cause the 
table to be fairly empty, which wastes space. In this case, we can rehash to 
a table half as large. Assume that we rehash to a larger table when there are 
twice as many elements as the table size. How empty should the table be before
we rehash to a smaller table?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;We must be careful not to rehash too often. Let &lt;span class="math"&gt;\(p\)&lt;/span&gt; be the threshold (fraction of table
size) at which we rehash to a smaller table. Then, if the new table has size &lt;span class="math"&gt;\(N\)&lt;/span&gt;, 
it contains &lt;span class="math"&gt;\(2Np\)&lt;/span&gt; elements. This table will require rehashing after either 
&lt;span class="math"&gt;\(2N-2Np\)&lt;/span&gt; insertions or &lt;span class="math"&gt;\(pN\)&lt;/span&gt; deletions. Then, we don't want to do rehashing either 
after a few insertion or a few deletions. A good strategy is to set &lt;span class="math"&gt;\(2N-2Np\)&lt;/span&gt; equals to &lt;span class="math"&gt;\(pN\)&lt;/span&gt;
and we get &lt;span class="math"&gt;\(p = \frac{2}{3}\)&lt;/span&gt;. For instance, suppose we have a table of size 300.
If we rehash at 200 elements, then the new table size is &lt;span class="math"&gt;\(N = 150\)&lt;/span&gt;, and we can do 
either 100 insertions or 100 deletions until a new rehash is required. &lt;/p&gt;
&lt;p&gt;If we know that insertions are more frequent than deletions, then we might choose &lt;span class="math"&gt;\(p\)&lt;/span&gt;
to be somewhat larger. All in all, we play around the relation between &lt;span class="math"&gt;\(2N-2Np\)&lt;/span&gt; and 
&lt;span class="math"&gt;\(pN\)&lt;/span&gt; depends on which operation we favorite.&lt;/p&gt;
&lt;h3 id="maw-55"&gt;MAW 5.5&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;An alternative collision resolution strategy is to define a sequence, &lt;span class="math"&gt;\(F(i) = r_i\)&lt;/span&gt;,
where &lt;span class="math"&gt;\(r_0 = 0\)&lt;/span&gt; and &lt;span class="math"&gt;\(r_1, r_2, \dots, r_N\)&lt;/span&gt; is a random permutation of the first &lt;span class="math"&gt;\(N\)&lt;/span&gt;
integers (each integer appears exactly once).&lt;/p&gt;
&lt;p&gt;a. Prove that under this strategy, if the table is not full, then the collision can 
always be resolved.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Since the sequence &lt;span class="math"&gt;\(F(i)\)&lt;/span&gt; is defined as a random permutation of the first &lt;span class="math"&gt;\(N\)&lt;/span&gt; integers,
then each cells of the table will be probed eventually. If the table is not full, then the 
collision can always be resolved.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;b. Would this strategy be expected to eliminate clustering?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;This seems to eliminate primary clustering but not secondary clustering because
all elements that hash to some location will try the same collision resolution sequence.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;c. If the load factor of the table is &lt;span class="math"&gt;\(\lambda\)&lt;/span&gt;, what is the expected time to perform
an insert and for a successful search?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The running time is probably similar to quadratic probing. The advantage here is that 
the insertion can't fail unless the table is full.&lt;/p&gt;
&lt;h3 id="maw-56"&gt;MAW 5.6&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;What are the advantages and disadvantages of the various collision resolution strategies?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Separate chaining hashing requires the use of pointers, which costs some memory, and the 
standard method of implementing calls on memory allocation routines, which typically are
expensive. &lt;/p&gt;
&lt;p&gt;Linear probing is easily implemented, but performance degrades severly as the load 
factor increases because of primary clustering. &lt;/p&gt;
&lt;p&gt;Quadratic probing is only slightly more 
difficult to implement and gives good performance in practice. An insertion can fail 
if the table is half empty, but this is not likely. Even if it were, such an insertion 
would be so expensive that it wouldn't matter and would almost certainly point up a 
weakness in the hash function. &lt;/p&gt;
&lt;p&gt;Double hashing eliminates primary and secondary clustering but the computation of a second
hash function can be costly. &lt;/p&gt;
&lt;h3 id="maw-510"&gt;MAW 5.10&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Describe a procedure that avoids initializing a hash table (at the expense of memory).&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;To each hash table slot, we can add an extra field that we'll call &lt;code&gt;WhereOnStack&lt;/code&gt;, and 
we can keep an extra stack. When an insertion is first performed into a slot, we push
the address (or number) of the slot onto the stack and set the &lt;code&gt;WhereOnStack&lt;/code&gt; field to point
to the top of the stack. When we access a hash table slot, we check that &lt;code&gt;WhereOnStack&lt;/code&gt;
points to a valid part of the stack and that the entry in the (middle of the) stack that is 
pointed to by the &lt;code&gt;WhereOnStack&lt;/code&gt; field has that hash table slot as an address.&lt;/p&gt;
&lt;h3 id="maw-511"&gt;MAW 5.11&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Suppose we want to find the first occurrence of a string &lt;span class="math"&gt;\(P_1P_2\dots P_k\)&lt;/span&gt; in a long 
input string &lt;span class="math"&gt;\(A_1A_2\dots A_N\)&lt;/span&gt;. We can solve this problem by hashing the pattern string,
Obtaining a hash value &lt;span class="math"&gt;\(H_p\)&lt;/span&gt;, and comparing this value with the hash value formed from 
&lt;span class="math"&gt;\(A_1A_2\dots A_k\)&lt;/span&gt;, &lt;span class="math"&gt;\(A_2A_3\dots A_{k+1}\)&lt;/span&gt;, &lt;span class="math"&gt;\(A_3A_4\dots A_{k+2}\)&lt;/span&gt;, and so on until 
&lt;span class="math"&gt;\(A_{N-k+1}A_{N-k+2}\dots A_N\)&lt;/span&gt;. If we have a match of hash values, we compare the string character
by character to verify the match. We return the position (in A) if the strings actually 
do match, and we continue in the unlikely event that the match is false.&lt;/p&gt;
&lt;p&gt;a. Show that if the hash value of &lt;span class="math"&gt;\(A_iA_{i+1}\dots A_{i+k-1}\)&lt;/span&gt; is known, then the hash 
value of &lt;span class="math"&gt;\(A_{i+1}A_{i+2}\dots A_{i+k}\)&lt;/span&gt; can be computed in constant time.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;As suggested by MAW p.151, we use &lt;span class="math"&gt;\(\sum_{i=0}^{KeySize-1} Key[KeySize-i-1]\cdot 32^i\)&lt;/span&gt;
as the function to compute the hash value of a given string. Then, by this definition,
&lt;span class="math"&gt;\(A_iA_{i+1}\dots A_{i+k-1}\)&lt;/span&gt; can be computed as &lt;/p&gt;
&lt;div class="math"&gt;$$
H_1 = (32^0A_i + 32^1A_{i+1} + \dots + 32^{k-1}A_{i+k-1}) \bmod N
$$&lt;/div&gt;
&lt;p&gt;similarly, &lt;span class="math"&gt;\(A_{i+1}A_{i+2}\dots A_{i+k}\)&lt;/span&gt; can be computed as &lt;/p&gt;
&lt;div class="math"&gt;$$
H_2 = (32^1A_{i+1} + \dots + 32^kA_{i+k}) \bmod N
$$&lt;/div&gt;
&lt;p&gt;If we take a look at the relationship between these two equations, we can see &lt;/p&gt;
&lt;div class="math"&gt;$$
H_2 = H_1 - 32^0A_i \bmod N + 32^kA_{i+k} \bmod N
$$&lt;/div&gt;
&lt;p&gt;This can be computed in constant time if &lt;span class="math"&gt;\(H_1\)&lt;/span&gt; is known.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;b. Show that the running time is &lt;span class="math"&gt;\(O(k+N)\)&lt;/span&gt; plus the time spent refuting false matches.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The pattern's hash value &lt;span class="math"&gt;\(H_p\)&lt;/span&gt; computed in &lt;span class="math"&gt;\(O(K)\)&lt;/span&gt; time. Then, &lt;span class="math"&gt;\(A_1A_2\dots A_k\)&lt;/span&gt;
is computed in &lt;span class="math"&gt;\(O(K)\)&lt;/span&gt; time. Then starting with &lt;span class="math"&gt;\(A_2A_3\dots A_{k+1}\)&lt;/span&gt; and until
&lt;span class="math"&gt;\(A_{N-k+1}A_{N-k+2}\dots A_N\)&lt;/span&gt;, each hash value is computed in &lt;span class="math"&gt;\(O(1)\)&lt;/span&gt; by a) above.
Since, there are &lt;span class="math"&gt;\(N-k+1-2+1\)&lt;/span&gt; terms of &lt;span class="math"&gt;\(O(1)\)&lt;/span&gt;, then the total running time is
&lt;span class="math"&gt;\(O(K) + O(K) + O(N-K) = O(N+K)\)&lt;/span&gt;. Of course, there is also time we spend on refuting false
matches.&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['CommonHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' }, Macros: {} }," +
        "    jax: ['input/TeX','input/MathML','output/CommonHTML']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Zeyuan Hu</dc:creator><pubDate>Thu, 16 Mar 2017 17:41:00 +0800</pubDate><guid isPermaLink="false">tag:zhu45.org,2017-03-16:posts/2017/Mar/16/maw-chapter-5-hashing-writing-questions/</guid><category>hashing</category><category>proof</category><category>math</category><category>maw</category></item><item><title>MAW: Chapter 4 Reflection</title><link>http://zhu45.org/posts/2017/Mar/12/maw-chapter-4-reflection/</link><description>&lt;div class="section" id="reflection"&gt;
&lt;h2&gt;Reflection&lt;/h2&gt;
&lt;p&gt;In Chapter 4, we learn about the tree data structure. If we take a look from ADT
perspective, the ADT we learn about is called Dictionary (a.k.a Map) ADT, which
represented by a set of (key, value) pairs that support insert, find, delete operations.
The core idea for this ADT, as you can imagine, is to store information according to
some key and be able to retrieve it efficiently. Now our big picture becomes:&lt;/p&gt;
&lt;img src="/images/maw-chap4.PNG" alt="predecessor-successor" style="width: 700px;"/&gt;&lt;p&gt;Implementing dictionary ADT with tree structure brings following advantages:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Trees reflect structural relationships in the data&lt;/li&gt;
&lt;li&gt;Trees are used to represent hierarchies&lt;/li&gt;
&lt;li&gt;Trees provide an efficient insertion and searching&lt;/li&gt;
&lt;li&gt;Trees are very flexible data, allowing to move subtrees around with minumum effort&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Many different tree structures get presented in this chapter. Most fundamental ones are:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://zhu45.org/posts/2017/Jan/29/binary-tree-binary-search-tree/"&gt;Binary Search Tree&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://zhu45.org/posts/2017/Feb/05/avl-tree/"&gt;AVL tree&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://zhu45.org/posts/2017/Feb/13/splay-tree/"&gt;Splay tree&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://zhu45.org/posts/2017/Mar/11/b-tree/"&gt;B-tree&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Some variations to the above structures are Order Statistic Tree (MAW 4.44), Threaded Tree (MAW 4.45),
k-d Tree (MAW 4.46), and B*-tree (MAW 4.38).&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="left-out"&gt;
&lt;h2&gt;Left Out&lt;/h2&gt;
&lt;p&gt;Some material I left out when I work through this chapter:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;4.11 (cursor implementation of trees is not top priority)&lt;/li&gt;
&lt;li&gt;4.33, 4.34 (Form a nice tree drawing project; don't have time to do them now)&lt;/li&gt;
&lt;li&gt;4.12, 4.13, 4.14, 4.26.b, 4.37.b;c, 4.38 (interesting but may require too much effort)&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="reference"&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://courses.cs.washington.edu/courses/cse332/10sp/lectures/lecture6.pdf"&gt;https://courses.cs.washington.edu/courses/cse332/10sp/lectures/lecture6.pdf&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Zeyuan Hu</dc:creator><pubDate>Sun, 12 Mar 2017 10:45:00 +0800</pubDate><guid isPermaLink="false">tag:zhu45.org,2017-03-12:posts/2017/Mar/12/maw-chapter-4-reflection/</guid><category>meta</category><category>maw</category></item><item><title>B-Tree</title><link>http://zhu45.org/posts/2017/Mar/11/b-tree/</link><description>&lt;p&gt;This is the summary of &lt;em&gt;B tree&lt;/em&gt; part in MAW Chapter 4.&lt;/p&gt;
&lt;h2 id="motivation"&gt;Motivation&lt;/h2&gt;
&lt;p&gt;So far we have assumed that an entire data structure can be stored in the main memory. 
However, this is not true in reality because if we have more data than can fit in main 
memory, we have to store data structure on disk. In this case, number of disk 
accesses will dominate the running time because they are very expensive comparing with the 
processor speed. Then, when we design a data structure, we have to try our best to minimize
the number of disk accesses. Under the context of tree structure, B-tree is a structure
that tries to read as much information as possible in every disk access operation.&lt;/p&gt;
&lt;h2 id="concept"&gt;Concept&lt;/h2&gt;
&lt;p&gt;B-tree is by far the most chaoatic defined structure in the sense that different people
have slightly different definitions. I'll follow MAW's definition and points out how MAW's definition
is different from the other commonly seen definition.&lt;/p&gt;
&lt;p&gt;A B-tree of order &lt;span class="math"&gt;\(M\)&lt;/span&gt; is a tree with the following structural properties:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The leaves contain all the actual data, which are either the key temselves or pointers to records containing the keys.&lt;/li&gt;
&lt;li&gt;The root is either a leaf (when tree has &lt;span class="math"&gt;\(\le L\)&lt;/span&gt; items) or has between &lt;span class="math"&gt;\(2\)&lt;/span&gt; and &lt;span class="math"&gt;\(M\)&lt;/span&gt; children.&lt;/li&gt;
&lt;li&gt;All nonleaf nodes (except the root) have between &lt;span class="math"&gt;\(\lceil{M/2}\rceil\)&lt;/span&gt; and &lt;span class="math"&gt;\(M\)&lt;/span&gt; children (at least half full).&lt;/li&gt;
&lt;li&gt;All leaves are the same depth and have between &lt;span class="math"&gt;\(\lceil{L/2}\rceil\)&lt;/span&gt; and &lt;span class="math"&gt;\(L\)&lt;/span&gt; sorted data items, for some L (at least half full).&lt;/li&gt;
&lt;li&gt;The nonleaf nodes have room for up to &lt;span class="math"&gt;\(M-1\)&lt;/span&gt; keys to guide the searching; key &lt;span class="math"&gt;\(i\)&lt;/span&gt; represents the smallest key in subtree &lt;span class="math"&gt;\(i+1\)&lt;/span&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src="/images/b-tree-order-property.PNG" alt="b-tree-order-property"/&gt;&lt;/p&gt;
&lt;p&gt;In MAW, the definition of B-tree is essentially known as &lt;span class="math"&gt;\(B^+-\)&lt;/span&gt;tree. Technically, the real B-tree has the key property that 
the actual data to be stored in both leaves and internal nodes, which is not the case in our definition. In some &lt;span class="math"&gt;\(B^+-\)&lt;/span&gt;tree definition,
the leaves are connected as a linked list so that we don't have to restart the search from the root once we already traverse down to the 
leaf if we want a record that is on a leaf really close to the leaf we currently at. &lt;/p&gt;
&lt;h2 id="examples"&gt;Examples&lt;/h2&gt;
&lt;p&gt;Some typical examples in B-tree are of order 4 (known as 2-3-4 tree) and 3 (known as 2-3 tree).&lt;/p&gt;
&lt;p&gt;&lt;img src="/images/2-3-tree.PNG" alt="2-3-tree" style="width: 700px;"/&gt;&lt;/p&gt;
&lt;p&gt;B-tree is a structure that is widely used in the database system. The following picture shows a more real B-tree example. 
Suppose we have a large customer table with gigabytes of data and an index is created on the phone number column of the 
customer table to speed up search. Phone numbers stored in sorted order with information (page and slot) on where the rest of 
the customer information can be found in the customer table.&lt;/p&gt;
&lt;p&gt;&lt;img src="/images/real-b-tree.PNG" alt="real-b-tree" style="width: 700px;"/&gt;&lt;/p&gt;
&lt;p&gt;In this example, once we continue down the tree and locate the phone number we are searching for, we use the RID to fetch the rest of the customer record from the table. In this case, we use 4 page accesses to get the full customer
record from the table.&lt;/p&gt;
&lt;h2 id="operations"&gt;Operations&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Find:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;For find, we basically do binary search on each node to decide what subtree we should go to search. &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Insertion:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The major unique manipulation is we may need to split the node at the leaves and recursives make the new parent nodes (by pushing a key up to its parent)
to the root. Other strategies regarding nodes overloaded also exist but this one is classic textbook.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Deletion:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I have to say deletion is the most messy one and people may always want to talk about it conceptually instead of getting hands dirty
to actually implement one. Stanford paper listed in the reference section do a concrete implementation but the route they use is to implement
a real-life B-tree deletion which may be complicated for the learner. &lt;/p&gt;
&lt;p&gt;The strategy we use for deletion is that we want to find the key to be deleted and remove it first. Then, if the leaf underflows, we borrow from 
a neighbor. If leaf underflows and can't borrow, we merge nodes and delete parent.&lt;/p&gt;
&lt;h2 id="runtime-analysis"&gt;Runtime analysis&lt;/h2&gt;
&lt;p&gt;We first show that height &lt;span class="math"&gt;\(H\)&lt;/span&gt; is logarithmic in number of data items &lt;span class="math"&gt;\(N\)&lt;/span&gt;. Let &lt;span class="math"&gt;\(M \ge 2\)&lt;/span&gt;. Because all nodes are at least half full (except root may have
only 2 children) and all leaves are at the same level, the minimum number of data items &lt;span class="math"&gt;\(N\)&lt;/span&gt; for a height &lt;span class="math"&gt;\(H\)&lt;/span&gt; tree is &lt;/p&gt;
&lt;div class="math"&gt;$$
N \ge \underbrace{2(\lceil{M/2}\rceil)^{H-1}}_\textrm{min number of leaves}\times\underbrace{\lceil{L/2}\rceil}_\textrm{min data per leaf}
$$&lt;/div&gt;
&lt;p&gt;Then for a B-tree of order &lt;span class="math"&gt;\(M\)&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Each internal node has up to &lt;span class="math"&gt;\(M-1\)&lt;/span&gt; keys to search&lt;/li&gt;
&lt;li&gt;Each internal node has between &lt;span class="math"&gt;\(\lceil{M/2}\rceil\)&lt;/span&gt; and &lt;span class="math"&gt;\(M\)&lt;/span&gt; children&lt;/li&gt;
&lt;li&gt;Depth of B-tree storing &lt;span class="math"&gt;\(N\)&lt;/span&gt; items is &lt;span class="math"&gt;\(O(\log_{\lceil{M/2}\rceil}N)\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Find then takes &lt;span class="math"&gt;\(O(\log M)\)&lt;/span&gt; to do binary search on each node to determine which branch to take. Then the total time is 
&lt;span class="math"&gt;\(O(depth \times \log M)\)&lt;/span&gt; = &lt;span class="math"&gt;\(O(\log N)\)&lt;/span&gt; because &lt;span class="math"&gt;\(M\)&lt;/span&gt; is small compared to &lt;span class="math"&gt;\(N\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;Insertion and deletion doesn't different from &lt;span class="math"&gt;\(O(\log N)\)&lt;/span&gt; because the unique manipulation takes constant amount of work and the number 
of times this unique manipulation is proportional to the height of tree.&lt;/p&gt;
&lt;h2 id="pros-cons-of-data-structure"&gt;Pros &amp;amp; Cons of data structure&lt;/h2&gt;
&lt;p&gt;What makes B-trees so disk friendly?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Many keys stored in one node &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;All brought into memory in one disk access&lt;/li&gt;
&lt;li&gt;Pick &lt;span class="math"&gt;\(M\)&lt;/span&gt; wisely. See MAW's Java version (3rd edition) p.149 for an example.&lt;/li&gt;
&lt;li&gt;Makes the binary searhc over &lt;span class="math"&gt;\(M-1\)&lt;/span&gt; keys totally worth it.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Internal nodes contain only keys&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;All find wants only one data item. So only bring one leaf of data items into memory.&lt;/li&gt;
&lt;li&gt;Data-item size doesn't affect what &lt;span class="math"&gt;\(M\)&lt;/span&gt; is. We determine &lt;span class="math"&gt;\(M\)&lt;/span&gt; only by how many keys can be packed into a disk block (node).
  Thus, the key size, the children pointer size, and the block size are the only factors here.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="links-to-resources"&gt;Links to resources&lt;/h2&gt;
&lt;p&gt;Here are some of the resources I found helpful while preparing this article:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MAW Chapter 4&lt;/li&gt;
&lt;li&gt;Lecture slides &lt;a href="https://courses.cs.washington.edu/courses/cse373/06sp/handouts/lecture15.pdf"&gt;15&lt;/a&gt;,
&lt;a href="https://courses.cs.washington.edu/courses/cse332/10sp/lectures/lecture8.pdf"&gt;8&lt;/a&gt;, and 
&lt;a href="https://courses.cs.washington.edu/courses/cse332/10sp/lectures/lecture9.pdf"&gt;9&lt;/a&gt;
from U.Washington&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.cs.yale.edu/homes/aspnes/pinewiki/BTrees.html"&gt;Yale pinewiki on B-tree&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://ilpubs.stanford.edu:8090/85/1/1995-19.pdf"&gt;Stanford B-tree implementation paper&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['CommonHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' }, Macros: {} }," +
        "    jax: ['input/TeX','input/MathML','output/CommonHTML']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Zeyuan Hu</dc:creator><pubDate>Sat, 11 Mar 2017 21:32:00 +0800</pubDate><guid isPermaLink="false">tag:zhu45.org,2017-03-11:posts/2017/Mar/11/b-tree/</guid><category>trees</category><category>maw</category></item><item><title>Splay Tree</title><link>http://zhu45.org/posts/2017/Feb/13/splay-tree/</link><description>&lt;p&gt;This is the summary of &lt;em&gt;Splay tree&lt;/em&gt; part in MAW Chapter 4.&lt;/p&gt;
&lt;h2 id="motivation"&gt;Motivation&lt;/h2&gt;
&lt;p&gt;Ordinary BST has no balance conditions and thus, it is possible for a whole sequnece of &lt;span class="math"&gt;\(O(N)\)&lt;/span&gt; accesses to take place. This cumulative running time 
then becomes noticeable. So, we introduce the balance condition on BST to improve our running time. One way to do so is to enforce a balance condition
when nodes change (i.e. insert or delete) like AVL. However, this data structure is hard to code and rebalancing costs time. In addition, sometimes it is 
OK for us to have &lt;span class="math"&gt;\(O(N)\)&lt;/span&gt; operation as long as it occurs infrequently. In other words, A search data structure with &lt;span class="math"&gt;\(O(N)\)&lt;/span&gt; worst-case time, but a &lt;em&gt;guarantee&lt;/em&gt;
of at most &lt;span class="math"&gt;\(O(M \log N)\)&lt;/span&gt; for any &lt;span class="math"&gt;\(M\)&lt;/span&gt; consecutive operations, is good enough. Splay tree meets our needs. It is a data structure that 
lies right in-between BST (no balance condition) and AVL (very strict balance condition).&lt;/p&gt;
&lt;h2 id="concept"&gt;Concept&lt;/h2&gt;
&lt;p&gt;A splay tree is a type of balanced binary search tree. Structurally, it is identical to an ordinary binary search tree; the only difference is in the 
algorithms for finding, inserting, and deleting entries. Specifically, splay tree is a self-adjusting tree, which the structure get organized over time
as nodes are accessed (i.e., insert, delete, or find). This makes sense because if we don't re-structure the tree each time we access an node, then 
the amortized time bound should be &lt;span class="math"&gt;\(O(M N)\)&lt;/span&gt; for a sequence of &lt;span class="math"&gt;\(M\)&lt;/span&gt; accesses instead of &lt;span class="math"&gt;\(O(M \log N)\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;The way we restructure the tree is called &lt;em&gt;splaying&lt;/em&gt;. Chapter 4 talks about bottom-up splaying algorithms. Every time a node is accessed in a splay tree,
it is moved to the root of the tree. The amortized cost of the operation is &lt;span class="math"&gt;\(O(\log N)\)&lt;/span&gt;. As shown by MAW, simply moving the element to the root by
rotating it up the trees does not have this property. However, the following three structuring rules do guarantee this amortized bound.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;                             y             x
   Zig (terminal case):     /     ====&amp;gt;     \               (same as AVL single rotation)
                           x                 y

                    z              z
                   /              /             x
   Zig-zag:       y     ====&amp;gt;    x   ====&amp;gt;     / \          (same as AVL double rotation)
                   \            /             y   z
                    x          y

                    z                         x
                   /            y              \
   Zig-zig:       y     ====&amp;gt;  / \   ====&amp;gt;      y
                 /            x   z              \
                x                                 z
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;In the above pictures, x is the node that was accessed (that will
eventually be at the root of the tree).  By looking at the local
structure of the tree defined by x, x's parent, and x's grandparent we
decide which of three rules to follow.  We continue to
apply the rules until x is at the root of the tree.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Splay(1)

              7                    7                   7               1
             /                    /                   /                 \
            6                    6                   6                   6
           /                    /                   /                   / \
          5                    5                   1                   4   7 
         /      =======&amp;gt;      /        =======&amp;gt;     \    ======&amp;gt;      / \
        4                    4                       4               2   5
       /                    /                       / \               \
      3                    1                       2   5               3
     /                      \                       \
    2                        2                       3
   /                          \
  1                            3
&lt;/pre&gt;&lt;/div&gt;


&lt;h2 id="implementation-details"&gt;Implementation details&lt;/h2&gt;
&lt;p&gt;Splay tree is really a flexible data structure in the sense that there are many options to implement 
the "splay" rules and corresponding tree operations and still have the property hold. Reference &lt;a href="https://en.wikipedia.org/wiki/Splay_tree"&gt;wiki&lt;/a&gt;
for complete summary. Here, I only mention some of my findings. Please note that depends on how you implement your operations, the resulting tree
may be different (i.e. different insert algorithm may result in different tree structure but there root will be the same).&lt;/p&gt;
&lt;h3 id="insertion-bottom-up"&gt;Insertion (bottom-up)&lt;/h3&gt;
&lt;p&gt;There are two ways to do this. The first way is to use "split" to split the tree based upon the insertion value. By the property of splaying, 
we will either have the insertion value (already inside the tree) or the parent of the insertion point at the root. Then we can make our insertion 
value as the new root and adjust the orginal tree to form the new tree. For example,  if the insertion value &lt;code&gt;elem&lt;/code&gt; smaller than the root, we do&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;elem&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Element&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;newT&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Right&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;newT&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Left&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Left&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// we can do this b/c the result of splaying is the parent node of where we should insert.&lt;/span&gt;
  &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Left&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The code is straightforward but &lt;code&gt;newT-&amp;gt;Left = T-&amp;gt;Left&lt;/code&gt; is worth a remark. Here, when &lt;code&gt;T&lt;/code&gt; is the parent of the insertion point, 
we know &lt;code&gt;T&lt;/code&gt;'s left subtree's values are smaller than &lt;code&gt;elem&lt;/code&gt; as well. This is because 
if there is any node &lt;span class="math"&gt;\(x\)&lt;/span&gt; greater than &lt;code&gt;elem&lt;/code&gt; but smaller than &lt;code&gt;T&lt;/code&gt;'s value, then &lt;code&gt;T&lt;/code&gt; should be &lt;span class="math"&gt;\(x\)&lt;/span&gt; instead (by splaying), which is a contradiction.&lt;/p&gt;
&lt;p&gt;The second way is to do BST insertion first and then splay the insertion value, which is really straightforward and easy to code. &lt;/p&gt;
&lt;h2 id="deletion-bottom-up"&gt;Deletion (bottom-up)&lt;/h2&gt;
&lt;p&gt;Correspondingly there are two methods to deletion as well. The first way is to splay the to-be-deleted node. This puts the node at the root. If it is
deleted, we get two subtrees &lt;span class="math"&gt;\(T_L\)&lt;/span&gt; and &lt;span class="math"&gt;\(T_R\)&lt;/span&gt;. If we find the largest element in &lt;span class="math"&gt;\(T_L\)&lt;/span&gt;, then this element is rotated to the root of &lt;span class="math"&gt;\(T_L\)&lt;/span&gt;, and 
&lt;span class="math"&gt;\(T_L\)&lt;/span&gt; will now have a root with no right child. We can finish the deletion by making &lt;span class="math"&gt;\(T_R\)&lt;/span&gt; the right child.&lt;/p&gt;
&lt;p&gt;The second way is to do BST deletion first, and then splay the parent of the deletion point to the root. It is quite similar to BST deletion and see
the implementation &lt;a href="https://github.com/xxks-kkk/algo/blob/master/trees/splay/splay.c"&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id="properties"&gt;Properties&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;any &lt;span class="math"&gt;\(M\)&lt;/span&gt; consecutive tree operations starting from an empty tree take at most &lt;span class="math"&gt;\(O(M \log N)\)&lt;/span&gt; time.&lt;/li&gt;
&lt;li&gt;Even though the worst-case running time is &lt;span class="math"&gt;\(O(N)\)&lt;/span&gt; for operation, the amortized cost of the operation is &lt;span class="math"&gt;\(O(\log N)\)&lt;/span&gt;.&lt;/li&gt;
&lt;li&gt;if all nodes in a splay tree are accessed in sequential order, the resulting tree consists of a chain of left children. (MAW 4.26.a)&lt;/li&gt;
&lt;li&gt;if all nodes in a splay tree are accessed in sequential order, then the total access time is &lt;span class="math"&gt;\(O(N)\)&lt;/span&gt;, regardless of the initial tree.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="pros-cons-of-data-structure"&gt;Pros &amp;amp; Cons of data structure&lt;/h2&gt;
&lt;p&gt;Splay tree is simpler and easier to program. Because of its implicity, splay tree insertion and deletion is typically faster in practice.
Find operation can be faster or slower, depending on circumstances. Splay trees are designed to give especially fast access to nodes that 
have been accessed recently, so they really excel in applications where a small fraction of the nodes are the targets of most of the find operation.&lt;/p&gt;
&lt;h2 id="todo"&gt;Todo&lt;/h2&gt;
&lt;p&gt;This post does not cover every part of the splay tree. This post will be updated once I complete the following two parts study:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MAW Chapter 11 gives a thorough study of the amortized cost of the splay tree operations &lt;span class="math"&gt;\(O( \log N)\)&lt;/span&gt;.&lt;/li&gt;
&lt;li&gt;MAW Chapter 12 gives implementation details on top-down splay tree.  &lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="reference"&gt;Reference&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;http://www.cs.cmu.edu/afs/cs/academic/class/15859-f05/www/documents/splay-trees.txt&lt;/li&gt;
&lt;li&gt;http://web.stanford.edu/class/archive/cs/cs166/cs166.1146/lectures/08/Small08.pdf (proof of properties in a concise structure)&lt;/li&gt;
&lt;li&gt;http://digital.cs.usu.edu/~allan/DS/Notes/Ch22.pdf&lt;/li&gt;
&lt;li&gt;https://courses.cs.washington.edu/courses/cse373/06sp/handouts/lecture14.pdf&lt;/li&gt;
&lt;li&gt;https://people.eecs.berkeley.edu/~jrs/61b/lec/36&lt;/li&gt;
&lt;/ul&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['CommonHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' }, Macros: {} }," +
        "    jax: ['input/TeX','input/MathML','output/CommonHTML']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Zeyuan Hu</dc:creator><pubDate>Mon, 13 Feb 2017 01:12:00 +0800</pubDate><guid isPermaLink="false">tag:zhu45.org,2017-02-13:posts/2017/Feb/13/splay-tree/</guid><category>trees</category><category>maw</category></item><item><title>AVL Tree</title><link>http://zhu45.org/posts/2017/Feb/05/avl-tree/</link><description>&lt;p&gt;This is the summary of &lt;em&gt;AVL tree&lt;/em&gt; part in MAW Chapter 4.&lt;/p&gt;
&lt;h2 id="motivation"&gt;Motivation&lt;/h2&gt;
&lt;p&gt;All BST operations are &lt;span class="math"&gt;\(O(H)\)&lt;/span&gt; time, where &lt;span class="math"&gt;\(H\)&lt;/span&gt; is the height of the tree. In the worst case
scenario, when the tree is degenerated, &lt;span class="math"&gt;\(H = N\)&lt;/span&gt;, where &lt;span class="math"&gt;\(N\)&lt;/span&gt; is the number of nodes.
Thus, the problem with BST is that it can get unbalanced and lead to the worst running time.
AVL tree is one of algorithms for keeping BST balanced (others including red-black trees, splay trees, B-trees).
Its approach to balancing tree is that we want a pretty good balance (allow a little out of balance).&lt;/p&gt;
&lt;h2 id="concept"&gt;Concept&lt;/h2&gt;
&lt;p&gt;AVL tree is a &lt;em&gt;guaranteed&lt;/em&gt; &lt;span class="math"&gt;\(O(log N)\)&lt;/span&gt; binary search tree. It is identical to a BST, except 
that for every node in the tree, the height of the left and right subtrees can differ by at most 1.
(The height of an empty tree is defined to be -1).&lt;/p&gt;
&lt;p&gt;&lt;img src="/images/AVL.PNG" alt="AVL-tree-concept" style="width: 700px;"/&gt;&lt;/p&gt;
&lt;p&gt;For simplicity, we really omit the actual data part of the node. The following picture demonstrate
what AVL tree should really look like:&lt;/p&gt;
&lt;p&gt;&lt;img src="/images/AVL-real.PNG" alt="AVL-tree-real" style="height: 300px; width: 700px;"/&gt;&lt;/p&gt;
&lt;h2 id="insertion"&gt;Insertion&lt;/h2&gt;
&lt;p&gt;AVL tree insertion is based upon BST insertion with two addition treatments:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Update the height information of the nodes on the path from the root to the insertion point.&lt;/li&gt;
&lt;li&gt;Restores the AVL property when find the node that violates it on the road through &lt;em&gt;rotation&lt;/em&gt; operations.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;There are four cases inside the insertion (see MAW p.111) and we handle "outside" cases (i.e. left-left or right-right)
and "inside" cases (i.e. left-right or right-left) using single rotation and double rotation respectively.&lt;/p&gt;
&lt;p&gt;To remember single rotation, you can pick a case, say left-left and remember its picture. (right-right is a mirror case)&lt;/p&gt;
&lt;p&gt;&lt;img alt="AVL-single-rotation-left" src="http://zhu45.org/images/AVL-single-rotation-left.PNG" /&gt;&lt;/p&gt;
&lt;p&gt;In the picture, we need to rebalance the tree at &lt;span class="math"&gt;\(k_2\)&lt;/span&gt;. This picture shows how we can implement &lt;code&gt;singleRotateWithLeft&lt;/code&gt; routine as well.
(Here, "left" means the inbalance is caused by the insertion into the left subtree of the inbalance node.)&lt;/p&gt;
&lt;p&gt;Similarly, to remember double rotation, we pick a case, say right-left and remember its picture. (left-right is a mirror case)&lt;/p&gt;
&lt;p&gt;&lt;img alt="AVL-double-rotation-right" src="http://zhu45.org/images/AVL-double-rotation-right.PNG" /&gt;&lt;/p&gt;
&lt;p&gt;In the picture, we need to rebalance the tree at &lt;span class="math"&gt;\(k_3\)&lt;/span&gt;. The picture shows how we can implement &lt;code&gt;doubleRotateWithRight&lt;/code&gt; routine as well.
As you can see from the picture, "double rotation" is essentially the same as two "single rotation": rotate &lt;span class="math"&gt;\(k_2\)&lt;/span&gt; and &lt;span class="math"&gt;\(k_1\)&lt;/span&gt;, then &lt;span class="math"&gt;\(k_2\)&lt;/span&gt; and &lt;span class="math"&gt;\(k_3\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;Identifying which rotation to use by strictly based upon these four cases can work but time-consuming. Here is how I think about 
this issue from practical point of view: you may compare the insertion value with the inbalance node value to determine which node to use.
Here is the detail steps:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Compare the insertion value with the inbalance node value:
   if comparison result is &lt;span class="math"&gt;\(&amp;lt;\)&lt;/span&gt;, then we insert into the left subtree of inbalance node. &lt;span class="math"&gt;\(&amp;gt;\)&lt;/span&gt; otherwise.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;If the insertion value is &lt;span class="math"&gt;\(&amp;lt;\)&lt;/span&gt; (or &lt;span class="math"&gt;\(&amp;gt;\)&lt;/span&gt;) than the left (or right) child value of the inbalance node, we are doing single rotation.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;If the insertion value is in-between, then we are doing double rotation. &lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;See MAW p.117 insertion 13 for an example.&lt;/p&gt;
&lt;h2 id="deletion"&gt;Deletion&lt;/h2&gt;
&lt;p&gt;Deletion, in fact, is extremely similar to the insertion in the sense that: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;It is based upon BST deletion with extra treatment towards node height information and AVL property&lt;/li&gt;
&lt;li&gt;There are the same rotation cases we need to consider when we ensure the AVL property satisfied for the nodes.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;There is only one difference than insertion, which is there can be more than unbalanced node needed to be taken care of when we walk
through the deletion point to the root.&lt;/p&gt;
&lt;p&gt;There is nuance in terms of how we think about which rotation to use. In insertion, we think about in terms of insertion point. For instance,
if the insert value is smaller than unbalanced node value, and smaller than the unbalanced node's child value, we know we are in left-left case, which is 
single rotation. However, when we deal with deletion, we actually think about the height of the subtree: a left-left insertion is equivalent as 
we make the the left subtree of unbalanced node's child taller than its right subtree. In deletion, there is no way we can use a specific element value 
to decide what rotation we should use (like insertion). Thus, we have the following code in our &lt;code&gt;deletion&lt;/code&gt; routine:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Height&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Left&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;Height&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Right&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Height&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Left&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Left&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;Height&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Left&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Right&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; 
      &lt;span class="n"&gt;T&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;singleRotateWithLeft&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;//Left Left case&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;
      &lt;span class="n"&gt;T&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;doubleRotateWithLeft&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;//Left Right case&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Height&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Right&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;Height&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Left&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Height&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Right&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Right&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;Height&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Right&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Left&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="n"&gt;T&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;singleRotateWithRight&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;//Right Right case&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;
      &lt;span class="n"&gt;T&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;doubleRotateWithRight&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;//Right Left case&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Of course, the following simple example may help you understand the code chunk above:&lt;/p&gt;
&lt;p&gt;&lt;img alt="AVL-deletion" src="http://zhu45.org/images/AVL-deletion.PNG" /&gt;&lt;/p&gt;
&lt;h2 id="properties"&gt;Properties&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;For every node of the AVL tree, &lt;span class="math"&gt;\(|Height(left child) - Height(right child)| \le 1\)&lt;/span&gt;.&lt;/li&gt;
&lt;li&gt;Running time for "find", "insert", "delete" is &lt;em&gt;guaranteed&lt;/em&gt; to be &lt;span class="math"&gt;\(O(\log N)\)&lt;/span&gt;.&lt;/li&gt;
&lt;li&gt;The height of AVL tree &lt;span class="math"&gt;\(H\)&lt;/span&gt; is at most &lt;span class="math"&gt;\(1.44\log _2 N\)&lt;/span&gt;. 
  (see &lt;a href="http://zhu45.org/posts/2017/Jan/26/maw-chapter-4-tree-writing-questions/"&gt;this post&lt;/a&gt; for the proof)&lt;/li&gt;
&lt;li&gt;For an insertion, there is &lt;em&gt;at most one&lt;/em&gt; rotation (used in non-recursive insertion routine).&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="pros-cons-of-data-structure"&gt;Pros &amp;amp; Cons of data structure&lt;/h2&gt;
&lt;p&gt;Pros:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Search is &lt;span class="math"&gt;\(O(\log N)\)&lt;/span&gt; since AVL trees are always balanced.&lt;/li&gt;
&lt;li&gt;Insertion and deletions are also &lt;span class="math"&gt;\(O(\log N)\)&lt;/span&gt;.&lt;/li&gt;
&lt;li&gt;The height balancing adds no more than a constant factor to the speed of insertion.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Cons:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Difficult to program &amp;amp; debug; more space for height information.&lt;/li&gt;
&lt;li&gt;Asymptotically faster but rebalancing costs time.&lt;/li&gt;
&lt;li&gt;Most large searches are done in database systems on disk and use
  other structures (e.g. B-trees).&lt;/li&gt;
&lt;li&gt;May be OK to have &lt;span class="math"&gt;\(O(N)\)&lt;/span&gt; for a single operation if total run time for
  many consecutive operations is fast (e.g. Splay trees). In other words,
  If &lt;em&gt;amortized&lt;/em&gt; logarithmic time is enough, use splay trees.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="reference"&gt;Reference&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;MAW Chapter 4&lt;/li&gt;
&lt;li&gt;https://courses.cs.washington.edu/courses/cse373/06sp/handouts/lecture12.pdf &lt;/li&gt;
&lt;li&gt;https://courses.cs.washington.edu/courses/cse332/10sp/lectures/lecture8.pdf&lt;/li&gt;
&lt;li&gt;http://www.geeksforgeeks.org/avl-tree-set-2-deletion/&lt;/li&gt;
&lt;li&gt;http://www.mathcs.emory.edu/~cheung/Courses/323/Syllabus/Trees/AVL-delete.html&lt;/li&gt;
&lt;/ul&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['CommonHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' }, Macros: {} }," +
        "    jax: ['input/TeX','input/MathML','output/CommonHTML']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Zeyuan Hu</dc:creator><pubDate>Sun, 05 Feb 2017 10:43:00 +0800</pubDate><guid isPermaLink="false">tag:zhu45.org,2017-02-05:posts/2017/Feb/05/avl-tree/</guid><category>trees</category><category>maw</category></item><item><title>Solving recurrence relations in a nutshell</title><link>http://zhu45.org/posts/2017/Feb/02/solving-recurrence-relations-in-a-nutshell/</link><description>&lt;p&gt;Able to solve recurrence relation is a very important skill when we study data structures
and algorithm. This is a ability that I used to be familar with when I took combinatorics
class when I was an undergraduate. However, by that time, I didn't realize how important 
this skill is from computer science point of view. But, thanks to MAW, I do now.&lt;/p&gt;
&lt;p&gt;This post is a study summary note on this very important subject. The aim of this note 
is to help at least me quickly solve any types of recurrence relation in the future.
The content closely follows Chapter 7
"Recurrence Relations and Generating Functions" of 
&lt;a href="https://www.amazon.com/Introductory-Combinatorics-5th-Richard-Brualdi/dp/0136020402"&gt;"Introductory Combinatorics"&lt;/a&gt;,
which is the textbook I used.&lt;/p&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;This note is practical-oriented. I will skip the proof of the theorem 
whenever possible.If you are interested in the proof side of the universe, 
please read the book.&lt;/p&gt;
&lt;/div&gt;
&lt;h2 id="toc"&gt;TOC&lt;/h2&gt;
&lt;p&gt;The post will be organized in the following format:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Linear homogeneous recurrence relation with constant coefficients&lt;ul&gt;
&lt;li&gt;Method 1: Characteristic equation&lt;ul&gt;
&lt;li&gt;distinct roots (theorem 7.4.1)&lt;/li&gt;
&lt;li&gt;roots with multiplicities (theorem 7.4.2)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Method 2: Generating function&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Linear nonhomogeneous recurrence relation with constant coefficients&lt;ul&gt;
&lt;li&gt;Method 1: Characteristic equation&lt;/li&gt;
&lt;li&gt;Method 2: Generating functions&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="linear-homogeneous-recurrence-relation-with-constant-coefficients"&gt;Linear homogeneous recurrence relation with constant coefficients&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;Definition:&lt;/em&gt; Let &lt;span class="math"&gt;\(h_0, h_1, h_2, \dots, h_n, \dots\)&lt;/span&gt; be a sequence of numbers. This sequence is 
said to satisfy a &lt;strong&gt;linear recurrence relation of order &lt;span class="math"&gt;\(k\)&lt;/span&gt;&lt;/strong&gt;, provided that there
exist quantities &lt;span class="math"&gt;\(a_1, a_2, \dots, a_k,\)&lt;/span&gt; with &lt;span class="math"&gt;\(a_k \ne 0\)&lt;/span&gt;, and a quantity &lt;span class="math"&gt;\(b_n\)&lt;/span&gt;
(each of these quantities &lt;span class="math"&gt;\(a_1,a_2,\dots,a_k,b_n\)&lt;/span&gt; may depend on &lt;span class="math"&gt;\(n\)&lt;/span&gt;) such that &lt;/p&gt;
&lt;div class="math"&gt;$$
\begin{equation}
h_n = a_1h_{n-1} + a_2h_{n-2} + \dots + a_kh_{n-k} + b_n, (n\ge k) \label{eq:1}
\end{equation}
$$&lt;/div&gt;
&lt;p&gt;&lt;em&gt;Example:&lt;/em&gt; The Fabonacci sequence &lt;span class="math"&gt;\(f_0, f_1, f_2, \dots, f_n, \dots\)&lt;/span&gt; satisfies
the linear recurrence relation&lt;/p&gt;
&lt;div class="math"&gt;$$
\begin{equation}
f_n = f_{n-1} + f_{n-2} (n\ge 2)
\end{equation}
$$&lt;/div&gt;
&lt;p&gt;of order 2 with &lt;span class="math"&gt;\(a_1 = 1, a_2 = 1,\)&lt;/span&gt; and &lt;span class="math"&gt;\(b_n = 0\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Definition:&lt;/em&gt; The linear recurrence relation \ref{eq:1} is called &lt;strong&gt;homogeneous&lt;/strong&gt; 
provided that &lt;span class="math"&gt;\(b_n\)&lt;/span&gt; is zero and is said to have &lt;strong&gt;constant coefficients&lt;/strong&gt; provided that
&lt;span class="math"&gt;\(a_1, a_2, \dots, a_k\)&lt;/span&gt; are constants.&lt;/p&gt;
&lt;h3 id="method-1-characteristic-equation"&gt;Method 1: Characteristic equation&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;Theorem 7.4.1:&lt;/em&gt; Let &lt;span class="math"&gt;\(q\)&lt;/span&gt; be a nonzero number. Then &lt;span class="math"&gt;\(h_n = q^n\)&lt;/span&gt; is a solution of the
linear homogeneous recurrence relation&lt;/p&gt;
&lt;div class="math"&gt;$$
\begin{equation}
h_n - a_1h_{n-1}-a_2h_{n-2}- \dots - a_kh_{n-k} = 0, (a_k \ne 0, n \ge k) \label{eq:2}
\end{equation}
$$&lt;/div&gt;
&lt;p&gt;with constant coefficients iff &lt;span class="math"&gt;\(q\)&lt;/span&gt; is a root of the polynomial equation (called &lt;strong&gt;characteristic equation&lt;/strong&gt;) &lt;/p&gt;
&lt;div class="math"&gt;$$
\begin{equation}
x_k-a_1x^{k-1}-a_2x^{k-2}- \dots - a_k = 0 \label{eq:3}
\end{equation}
$$&lt;/div&gt;
&lt;p&gt;If the polynomial equation has &lt;span class="math"&gt;\(k\)&lt;/span&gt; &lt;em&gt;distinct&lt;/em&gt; roots &lt;span class="math"&gt;\(q_1, q_2, \dots, q_k\)&lt;/span&gt;, then&lt;/p&gt;
&lt;div class="math"&gt;$$
\begin{equation}
h_n = c_1q_1^{n}+c_2q_2^n+ \dots + c_kq_k^n \label{eq:4}
\end{equation}
$$&lt;/div&gt;
&lt;p&gt;is the general solution of \ref{eq:2} in the following sense: No matter what initial
values for &lt;span class="math"&gt;\(h_0, h_1, \dots, h_{k-1}\)&lt;/span&gt; are given, there are constants &lt;span class="math"&gt;\(c_1, c_2, \dots, c_k\)&lt;/span&gt;
so that \ref{eq:4} is the unique sequence which satisfies both the recurrence relation 
\ref{eq:2} and the initial values.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Example:&lt;/em&gt; Solve the Fabonacci recurrence relation&lt;/p&gt;
&lt;div class="math"&gt;$$
\begin{equation*}
f_n = f_{n-1} + f_{n-2} (n\ge 2)
\end{equation*}
$$&lt;/div&gt;
&lt;p&gt;subject to the initial values &lt;span class="math"&gt;\(f_0 = 0\)&lt;/span&gt;, and &lt;span class="math"&gt;\(f_1\)&lt;/span&gt; = 1.&lt;/p&gt;
&lt;p&gt;We rewrite reccurrence relation into &lt;span class="math"&gt;\(f(n) - f(n-1) - f(n-2) = 0\)&lt;/span&gt; and the characteristic 
equation of this recurrence relation is&lt;/p&gt;
&lt;div class="math"&gt;$$
\begin{equation*}
x^2 - x - 1 = 0
\end{equation*}
$$&lt;/div&gt;
&lt;p&gt;and its two roots are &lt;span class="math"&gt;\(\frac{1+\sqrt 5}{2}\)&lt;/span&gt;, &lt;span class="math"&gt;\(\frac{1-\sqrt 5}{2}\)&lt;/span&gt;, and by theorem 7.4.1,&lt;/p&gt;
&lt;div class="math"&gt;$$
\begin{equation*}
f_n = c_1 \Big(\frac{1+\sqrt 5}{2}\Big)^n + c_2 \Big(\frac{1-\sqrt 5}{2}\Big)^n
\end{equation*}
$$&lt;/div&gt;
&lt;p&gt;is the general solution. We now want constants c_1, and c_2 so that &lt;/p&gt;
&lt;div class="math"&gt;$$
\begin{equation*}
\begin{cases}
c_1 \Big(\frac{1+\sqrt 5}{2}\Big) + c_2 \Big(\frac{1-\sqrt 5}{2}\Big) &amp;amp;=&amp;amp; 1 \qquad (n=1)\\
c_1 + c_2 &amp;amp;=&amp;amp; 0 \qquad (n=0)\\
\end{cases}
\end{equation*}
$$&lt;/div&gt;
&lt;p&gt;and we have &lt;span class="math"&gt;\(c_1 = \frac{1}{\sqrt 5}\)&lt;/span&gt;, and &lt;span class="math"&gt;\(c_2 = -\frac{1}{\sqrt 5}\)&lt;/span&gt;. Thus,&lt;/p&gt;
&lt;div class="math"&gt;$$
\begin{equation*}
f_n = \frac{1}{\sqrt 5}\Big(\frac{1+\sqrt 5}{2}\Big)^n - \frac{1}{\sqrt 5}\Big(\frac{1-\sqrt 5}{2}\Big)^n
\end{equation*}
$$&lt;/div&gt;
&lt;p&gt;is the solution of the Fabonacci recurrence relation.&lt;/p&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;As you might notice, theorem 7.4.1 explicitly requires that the roots of the 
characteristic equation have to be distinct. However, that's not always the case 
and theorem 7.4.1 will not work (see book for an example). 
That's why we need theorem 7.4.2.&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;em&gt;Theorem 7.4.2:&lt;/em&gt; Let &lt;span class="math"&gt;\(q_1, q_2, \dots, q_n\)&lt;/span&gt; be the distinct roots of the following characteristic equation of the 
linear homogeneous recurrence relation with constant coefficients:&lt;/p&gt;
&lt;div class="math"&gt;$$
\begin{equation}
h_n = a_1h_{n-1}+a_2h_{n-2}+ \dots + a_kh_{n-k}, a_k \ne 0, \qquad (n \ge k) \label{eq:5}
\end{equation}
$$&lt;/div&gt;
&lt;p&gt;If &lt;span class="math"&gt;\(q_i\)&lt;/span&gt; is an &lt;span class="math"&gt;\(s_i\)&lt;/span&gt;-fold root fo the characteristic equation of \ref{eq:5}, the part of the general solution of this recurrence 
relation corresponding to &lt;span class="math"&gt;\(q_i\)&lt;/span&gt; is &lt;/p&gt;
&lt;div class="math"&gt;$$
\begin{equation*}
H_{n}^{(i)} = c_1q_i^n + c_2nq_i^n + \dots + c_{s_i}n^{s_i-1}q_i^n
\end{equation*}
$$&lt;/div&gt;
&lt;p&gt;The general solution of the recurrence relation is &lt;/p&gt;
&lt;div class="math"&gt;$$
\begin{equation*}
h_n = H_n^{(1)} + H_n^{(2)} + \dots + H_n^{(t)}
\end{equation*}
$$&lt;/div&gt;
&lt;p&gt;&lt;em&gt;Example:&lt;/em&gt; Solve the recurrence relation&lt;/p&gt;
&lt;div class="math"&gt;$$
\begin{equation*}
h_n = -h_{n-1} + 3h_{n-2}+5h_{n-3}+2h_{n-4} \qquad (n \ge 4)
\end{equation*}
$$&lt;/div&gt;
&lt;p&gt;subject to the initial values &lt;span class="math"&gt;\(h_0=1\)&lt;/span&gt;, &lt;span class="math"&gt;\(h_1 = 0\)&lt;/span&gt;, &lt;span class="math"&gt;\(h_2 = 1\)&lt;/span&gt;, and &lt;span class="math"&gt;\(h_3 = 2\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;The characteristic equation of this recurrence relation is &lt;span class="math"&gt;\(x^4 + x^3 -3x^2 - 5x - 2 = 0\)&lt;/span&gt;, which has roots &lt;span class="math"&gt;\(-1\)&lt;/span&gt;, &lt;span class="math"&gt;\(-1\)&lt;/span&gt;, &lt;span class="math"&gt;\(-1\)&lt;/span&gt;, &lt;span class="math"&gt;\(-2\)&lt;/span&gt;.
Thus, the part of the general solution corresponding to the root &lt;span class="math"&gt;\(-1\)&lt;/span&gt; is&lt;/p&gt;
&lt;div class="math"&gt;$$
\begin{equation*}
H_n^{(1)} = c_1(-1)^n + c_2n(-1)^n + c_3n^2(-1)^n
\end{equation*}
$$&lt;/div&gt;
&lt;p&gt;while the part of a general solution corresponding to the root &lt;span class="math"&gt;\(2\)&lt;/span&gt; is &lt;span class="math"&gt;\(H_n^{(2)} = c_42^n\)&lt;/span&gt;. The general solution is &lt;/p&gt;
&lt;div class="math"&gt;$$
\begin{equation*}
h_n = H_n^{(1)} + H_n^{(2)} = c_1(-1)^n + c_2n(-1)^n + c_3n^2(-1)^n + c_42^n
\end{equation*}
$$&lt;/div&gt;
&lt;p&gt;Then we can use initial values to determine &lt;span class="math"&gt;\(c1\)&lt;/span&gt;, &lt;span class="math"&gt;\(c2\)&lt;/span&gt;, &lt;span class="math"&gt;\(c3\)&lt;/span&gt;, &lt;span class="math"&gt;\(c4\)&lt;/span&gt; and we have &lt;span class="math"&gt;\(h_n = \frac{7}{9} (-1)^n - \frac{3}{9}n(-1)^n + \frac{2}{9}2^n\)&lt;/span&gt;.&lt;/p&gt;
&lt;!--
&gt; You probably already notice from the previous example that "characteristic equation" method really depends on the diffculty in finding all roots
&gt; of a polynomial equation. Sometimes finding the roots of characteristic equation can be quite diffcult. That's what second method tries to address.
&gt; If you find out that characteristic equation is really diffcult to solve, you can always use "generating function" method.--&gt;

&lt;h3 id="method-2-generating-function"&gt;Method 2: Generating function&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;Definition:&lt;/em&gt; Let &lt;span class="math"&gt;\(h_0, h_1, h_2, \dots, h_n, \dots\)&lt;/span&gt; be an infinite sequence of numbers. Its &lt;strong&gt;generating function&lt;/strong&gt; is defined to be the infinite
series&lt;/p&gt;
&lt;div class="math"&gt;$$
\begin{equation}
g(x) = h_0 + h_1x + h_2x^2 + \dots + h_nx^n + \cdots
\end{equation}
$$&lt;/div&gt;
&lt;p&gt;The coefficient of &lt;span class="math"&gt;\(x^n\)&lt;/span&gt; in &lt;span class="math"&gt;\(g(x)\)&lt;/span&gt; is the general solution to &lt;span class="math"&gt;\(h_n\)&lt;/span&gt;. As you can see, generating functions are Taylor series (power series expansion)
of infinitely differentiable functions. If we can find the function (i.e. &lt;span class="math"&gt;\(g(x)\)&lt;/span&gt;) and its Taylor series, then the coefficients of the Taylor series give the solution 
to the problem.&lt;/p&gt;
&lt;p&gt;Let's illustrate this method using an example.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Example:&lt;/em&gt; Solve the recurrence relation &lt;/p&gt;
&lt;div class="math"&gt;$$
\begin{equation*}
h_n = 5h_{n-1} - 6h_{n-2} \qquad (n \ge 2) 
\end{equation*}
$$&lt;/div&gt;
&lt;p&gt;subject to the initial values &lt;span class="math"&gt;\(h_0 = 1\)&lt;/span&gt; and &lt;span class="math"&gt;\(h_1 = -2\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;We first rewrite the recurrence relation into &lt;span class="math"&gt;\(h_n -5h_{n-1} + 6h_{n-2} = 0 \quad (n \ge 2)\)&lt;/span&gt;. Let &lt;span class="math"&gt;\(g(x) = h_0 + h_1x + h_2x^2 + \dots + h_nx^n + \cdots\)&lt;/span&gt;
be the generating function for the sequence &lt;span class="math"&gt;\(h_0, h_1, \dots, h_n, \dots\)&lt;/span&gt;. We then form the following system of equations with the multipliers chosen based 
upon our rewritten recurrence relation initially.&lt;/p&gt;
&lt;div class="math"&gt;$$
\begin{eqnarray*}
g(x) &amp;amp;=&amp;amp; h_0 + h_1x + h_2x^2 + \dots + h_nx^n + \cdots \\
-5xg(x) &amp;amp;=&amp;amp;   -5h_0x - 5h_1x^2 - \dots - 5h_{n-1}x^n - \cdots \\
6x^2g(x) &amp;amp;=&amp;amp;         6h_0x^2 + \dots + 6h_{n-2}x^n + \cdots
\end{eqnarray*}
$$&lt;/div&gt;
&lt;p&gt;If you look at the coefficients of &lt;span class="math"&gt;\(x^n\)&lt;/span&gt; term vertically of all these three equations, you can see that they match our recurrence relation exactly.
Now, we add these three equations together, we obtain&lt;/p&gt;
&lt;div class="math"&gt;$$
\begin{equation*}
(1-5x+6x^2)g(x) = h_0 + (h_1-5h_0)x + (h_2 - 5h_1 + 6h_0)x^2 + \dots + (h_n - 5h_{n-1} + 6h_{n-2})x^n + \cdots .
\end{equation*}
$$&lt;/div&gt;
&lt;p&gt;since &lt;span class="math"&gt;\($h_n - 5h_{n-1} + 6h_{n-2} = 0 \quad (n \ge 2)\)&lt;/span&gt; and our initial condition, we have&lt;/p&gt;
&lt;div class="math"&gt;$$
\begin{equation*}
(1-5x+6x^2)g(x) = h_0 + (h_1 - 5h_0)x = 1 -7x
\end{equation*}
$$&lt;/div&gt;
&lt;p&gt;Thus,&lt;/p&gt;
&lt;div class="math"&gt;$$
\begin{equation*}
g(x) = \frac{1-7x}{1-5x+6x^2}
\end{equation*}
$$&lt;/div&gt;
&lt;p&gt;Now, we need to expand &lt;span class="math"&gt;\(g(x)\)&lt;/span&gt; in order to get the coefficient of &lt;span class="math"&gt;\(h_n\)&lt;/span&gt;. Since &lt;span class="math"&gt;\(1-5x+6x^2 = (1-2x)(1-3x)\)&lt;/span&gt;, we can write&lt;/p&gt;
&lt;div class="math"&gt;$$
\begin{equation*}
\frac{1-7x}{1-5x+6x^2} = \frac{c_1}{1-2x} + \frac{c_2}{1-3x}
\end{equation*}
$$&lt;/div&gt;
&lt;p&gt;for some constants &lt;span class="math"&gt;\(c1\)&lt;/span&gt; and &lt;span class="math"&gt;\(c2\)&lt;/span&gt;. We can determine &lt;span class="math"&gt;\(c1\)&lt;/span&gt; and &lt;span class="math"&gt;\(c2\)&lt;/span&gt; by multiplying both sides of this equation by &lt;span class="math"&gt;\(1-5x+6x^2\)&lt;/span&gt; to get&lt;/p&gt;
&lt;div class="math"&gt;$$
\begin{equation*}
1 - 7x = (c_1 + c_2) + (-3c_1 -2c_2)x
\end{equation*}
$$&lt;/div&gt;
&lt;p&gt;We can get &lt;span class="math"&gt;\(c_1 = 5\)&lt;/span&gt; and &lt;span class="math"&gt;\(c_2 = -4\)&lt;/span&gt;. Since &lt;/p&gt;
&lt;div class="math"&gt;$$
\begin{equation*}
\frac{1}{(1-rx)^n} = \sum_{k=0}^\infty\dbinom{n+k-1}{k}r^kx^k \qquad \Big(|x| &amp;lt; \frac{1}{|r|}\Big)
\end{equation*}
$$&lt;/div&gt;
&lt;p&gt;We have &lt;/p&gt;
&lt;div class="math"&gt;$$
\begin{equation*}
\frac{1}{1-2x} = 1 + 2x + 2^2x^2 + \dots + 2^nx^n + \cdots
\end{equation*}
$$&lt;/div&gt;
&lt;div class="math"&gt;$$
\begin{equation*}
\frac{1}{1-3x} = 1 + 3x + 3^2x^2 + \dots + 3^nx^n + \cdots
\end{equation*}
$$&lt;/div&gt;
&lt;p&gt;So&lt;/p&gt;
&lt;div class="math"&gt;$$
\begin{eqnarray*}
g(x) &amp;amp;=&amp;amp; 5(1 + 2x + 2^2x^2 + \dots + 2^nx^n + \cdots) -4(1 + 3x + 3^2x^2 + \dots + 3^nx^n + \cdots) \\
&amp;amp;=&amp;amp; 1 + (-2)x + (-15)x^2 + \dots + (5\times2^n - 4\times3^n)x^n + \cdots
\end{eqnarray*}
$$&lt;/div&gt;
&lt;p&gt;Thus, &lt;span class="math"&gt;\(h_n = 5\times2^n - 4\times3^n\)&lt;/span&gt;.&lt;/p&gt;
&lt;!-- Getting the polynomial expansion of $g(x)$ is the hardest part of this method. For instance, factoring the 
denominator of $g(x)$ can be tricky for high degree polynomials. I need more practice on solving recurrence
relation to decide which method is superior under what kind of situation.--&gt;

&lt;h2 id="linear-nonhomogeneous-recurrence-relation-with-constant-coefficients"&gt;Linear nonhomogeneous recurrence relation with constant coefficients&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;nonhomogeneous&lt;/strong&gt; means &lt;span class="math"&gt;\(b_n\)&lt;/span&gt; in \ref{eq:1} is no longer zero constant.&lt;/p&gt;
&lt;h3 id="method-1-characteristic-equation_1"&gt;Method 1: Characteristic equation&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;Steps:&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;1) Find the general solution of the homogeneous relation.&lt;/p&gt;
&lt;p&gt;2) Find a particular solution of the nonhomogeneous relation.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;If &lt;span class="math"&gt;\(b_n\)&lt;/span&gt; is a polynomial of degree &lt;span class="math"&gt;\(k\)&lt;/span&gt; in &lt;span class="math"&gt;\(n\)&lt;/span&gt;, then look for a particular solution &lt;span class="math"&gt;\(h_n\)&lt;/span&gt; that is also a polynomial of degree &lt;span class="math"&gt;\(k\)&lt;/span&gt; in &lt;span class="math"&gt;\(n\)&lt;/span&gt;. Thus, try &lt;ul&gt;
&lt;li&gt;&lt;span class="math"&gt;\(h_n = r\)&lt;/span&gt; (a constant) if &lt;span class="math"&gt;\(b_n = d\)&lt;/span&gt; (a constant)&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(h_n = rn + s\)&lt;/span&gt; if &lt;span class="math"&gt;\(b_n = dn + e\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(h_n = rn^2 + sn + t\)&lt;/span&gt; if &lt;span class="math"&gt;\(b_n = dn^2 + en + f\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;If &lt;span class="math"&gt;\(b_n\)&lt;/span&gt; is an exponential, then look for a particular solution that is also an exponential. Thus, try &lt;span class="math"&gt;\(h_n = pd^n\)&lt;/span&gt; if &lt;span class="math"&gt;\(b_n = d^n\)&lt;/span&gt; or &lt;span class="math"&gt;\(h_n = pnd^n\)&lt;/span&gt; if 
  the first try doesn't work.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;3) Combine the general solution and the particular solution so that the combined solution satisfies the initial conditions.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Example:&lt;/em&gt; Solve &lt;/p&gt;
&lt;div class="math"&gt;$$
\begin{eqnarray*}
h_n &amp;amp;=&amp;amp; 3h_{n-1} - 4n, \qquad (n \ge 1) \\
h_0 &amp;amp;=&amp;amp; 2
\end{eqnarray*}
$$&lt;/div&gt;
&lt;p&gt;We first consider corresponding homogeneous recurrence relation &lt;span class="math"&gt;\(h_n = 3h_{n-1}\)&lt;/span&gt; and its characteristic equation is &lt;span class="math"&gt;\(x - 3 = 0\)&lt;/span&gt;. and thus
we have the general solution &lt;span class="math"&gt;\(h_n = c3^n, \quad (n \ge 1)\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;Now we seek a particular solution of the nonhomogeneous recurrence relation &lt;span class="math"&gt;\(h_n = 3h_{n-1}-4n, \quad (n \ge 1)\)&lt;/span&gt;. We try to find a solution of the 
form &lt;span class="math"&gt;\(h_n = rn + s\)&lt;/span&gt; for some constant number &lt;span class="math"&gt;\(r\)&lt;/span&gt; and &lt;span class="math"&gt;\(s\)&lt;/span&gt;. We plug in our conjecture into the recurrence relation and get&lt;/p&gt;
&lt;div class="math"&gt;$$
\begin{equation*}
rn + s = 3(r(n-1)+s) - 4n = (3r-4)n + (-3r+3s)
\end{equation*}
$$&lt;/div&gt;
&lt;p&gt;Thus, &lt;span class="math"&gt;\(r = 2\)&lt;/span&gt; and &lt;span class="math"&gt;\(s = 3\)&lt;/span&gt; and &lt;span class="math"&gt;\(h_n = 2n + 3\)&lt;/span&gt;. Now, we combine the general solution of the homogeneous relation with the particular solution 
of the nonhomogeneous relation to obtain&lt;/p&gt;
&lt;div class="math"&gt;$$
\begin{equation*}
h_n = c3^n + 2n + 3
\end{equation*}
$$&lt;/div&gt;
&lt;p&gt;Now, let's use inital condition to solve for &lt;span class="math"&gt;\(c\)&lt;/span&gt; and we have &lt;span class="math"&gt;\(c = -1\)&lt;/span&gt;. So, &lt;span class="math"&gt;\(h_n = -3^n + 2n + 3\)&lt;/span&gt;.&lt;/p&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;As you can see, solving recurrence relation using characteristic equation has 
strong connection with solving differential equations (both homogeneous and 
nonhomogeneous). &lt;/p&gt;
&lt;/div&gt;
&lt;h3 id="method-2-generating-function_1"&gt;Method 2: Generating function&lt;/h3&gt;
&lt;p&gt;There is nothing difference in using "generating function" method to solve nonhomogeneous than solve homogeneous recurrence relation. That's actually 
a beauty of this method: nothing needs to tweak in order to work under different situation.&lt;/p&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;Certainly, not all recurrence relation appeard in computer science can be easily 
solved by the method described in this post. For instance, inside 
&lt;a href="http://zhu45.org/posts/2016/Dec/31/josephus-problem/"&gt;Josephus problem&lt;/a&gt;, recurrence 
relation may depend on whether &lt;span class="math"&gt;\(n\)&lt;/span&gt; is odd or even and 
methods may not apply nicely. This implies another type of technique to solve 
recurrence relation is to guess the solution and prove it by induction.
Also, in the book, solving &lt;span class="math"&gt;\(h_n = h_{n-1} + n^3\)&lt;/span&gt; on p. 250 is not standard as 
well.&lt;/p&gt;
&lt;/div&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['CommonHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' }, Macros: {} }," +
        "    jax: ['input/TeX','input/MathML','output/CommonHTML']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Zeyuan Hu</dc:creator><pubDate>Thu, 02 Feb 2017 01:05:00 +0800</pubDate><guid isPermaLink="false">tag:zhu45.org,2017-02-02:posts/2017/Feb/02/solving-recurrence-relations-in-a-nutshell/</guid><category>recursion</category><category>combinatorics</category><category>math</category></item><item><title>Binary Tree &amp; Binary Search Tree</title><link>http://zhu45.org/posts/2017/Jan/29/binary-tree-binary-search-tree/</link><description>&lt;p&gt;This is the summary of &lt;em&gt;binary tree&lt;/em&gt; and &lt;em&gt;binary search tree&lt;/em&gt; part in MAW Chapter 4.&lt;/p&gt;
&lt;h2 id="concept"&gt;Concept&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;A &lt;em&gt;binary tree&lt;/em&gt; is a tree in which no node can have more than two children. &lt;/li&gt;
&lt;li&gt;An important application of binary trees is &lt;em&gt;binary search tree&lt;/em&gt;: for every node,
  &lt;span class="math"&gt;\(X\)&lt;/span&gt;, in the tree, the values of all the keys in its left subtree are smaller than
  the key value in &lt;span class="math"&gt;\(X\)&lt;/span&gt;, and the values of all the keys in its right subtree are larger
  than the key value in &lt;span class="math"&gt;\(X\)&lt;/span&gt; (&lt;em&gt;BST-property&lt;/em&gt;).&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="classification-of-binary-trees"&gt;Classification of binary trees&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;A &lt;em&gt;full&lt;/em&gt; binary tree (proper binary tree or 2-tree) is a binary tree in which each node
  has exactly zero or two children.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;A &lt;em&gt;full node&lt;/em&gt; in a binary tree is a node that has exactly two non-null children.&lt;/p&gt;
&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;A &lt;em&gt;complete&lt;/em&gt; binary tree is a binary tree, which is completely filled, with the possible
  exception of the bottom level, which is filled from left to right.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="full-complete-binary-tree" src="http://zhu45.org/images/full-complete-binary-tree.PNG" /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A &lt;em&gt;perfect&lt;/em&gt; binary tree: A binary tree in which all internal nodes have exactly two children 
  and all leaves are at the same level. It has property: each level has exactly twice as many 
  nodes as the previous level (since each internal node has exactly two children).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="perfect-binary-tree" src="http://zhu45.org/images/perfect-binary-tree.png" /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A &lt;em&gt;balance&lt;/em&gt; binary tree: a binary tree structure in which the left and right 
  subtrees of every node differ in height by no more than 1. Yes, &lt;a href="http://zhu45.org/posts/2017/Feb/05/avl-tree/"&gt;AVL tree&lt;/a&gt;
  definition.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="properties"&gt;Properties&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;The average depth of binary tree is &lt;span class="math"&gt;\(O(\sqrt{n})\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;A binary tree of &lt;span class="math"&gt;\(N\)&lt;/span&gt; nodes, there are &lt;span class="math"&gt;\(N+1\)&lt;/span&gt; &lt;code&gt;NULL&lt;/code&gt; pointers representing children (MAW 4.4)&lt;/li&gt;
&lt;li&gt;The maximum number of nodes in a binary tree of height &lt;span class="math"&gt;\(H\)&lt;/span&gt; is &lt;span class="math"&gt;\(2^{H+1}-1\)&lt;/span&gt; (MAW 4.5)&lt;/li&gt;
&lt;li&gt;The number of full nodes plus one is equal to the number of leaves in a nonempty binary tree&lt;/li&gt;
&lt;li&gt;The average depth of a node in a binary search tree constructed from random data is &lt;span class="math"&gt;\(O(\log n)\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;The average of height of a random binary search tree is &lt;span class="math"&gt;\(O(\log n)\)&lt;/span&gt; (i.e., &lt;span class="math"&gt;\(E[h] = O(\log n)\)&lt;/span&gt;) (MAW 4.14)&lt;/li&gt;
&lt;li&gt;All the basic operations &lt;code&gt;find&lt;/code&gt;, &lt;code&gt;findMin&lt;/code&gt;, &lt;code&gt;findMax&lt;/code&gt;, &lt;code&gt;insert&lt;/code&gt;, and &lt;code&gt;delete&lt;/code&gt;
  &lt;span class="math"&gt;\(O(H)\)&lt;/span&gt; time, where &lt;span class="math"&gt;\(H\)&lt;/span&gt; is the height of the tree.&lt;ul&gt;
&lt;li&gt;worst case: height &lt;span class="math"&gt;\(H = n - 1\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;base case: height &lt;span class="math"&gt;\(H = \log N\)&lt;/span&gt;, where the tree is a complete binary tree.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Randomly built binary search trees:&lt;ul&gt;
&lt;li&gt;The &lt;em&gt;average height&lt;/em&gt; is much closer to the best case.&lt;/li&gt;
&lt;li&gt;Little is known about the average height when &lt;em&gt;both insertion and deletion&lt;/em&gt; are used.&lt;/li&gt;
&lt;li&gt;characteristics&lt;ul&gt;
&lt;li&gt;Keys inserting in &lt;em&gt;random order&lt;/em&gt; into an initially empty tree.&lt;/li&gt;
&lt;li&gt;Each of the &lt;span class="math"&gt;\(n!\)&lt;/span&gt; &lt;em&gt;permutations&lt;/em&gt; of the input keys is &lt;em&gt;equally likely&lt;/em&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="reference"&gt;Reference&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;MAW Chapter 4&lt;/li&gt;
&lt;li&gt;https://en.wikipedia.org/wiki/Binary_tree&lt;/li&gt;
&lt;li&gt;https://www.cs.cmu.edu/~adamchik/15-121/lectures/Trees/trees.html&lt;/li&gt;
&lt;/ul&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['CommonHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' }, Macros: {} }," +
        "    jax: ['input/TeX','input/MathML','output/CommonHTML']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Zeyuan Hu</dc:creator><pubDate>Sun, 29 Jan 2017 13:20:00 +0800</pubDate><guid isPermaLink="false">tag:zhu45.org,2017-01-29:posts/2017/Jan/29/binary-tree-binary-search-tree/</guid><category>trees</category><category>maw</category></item><item><title>MAW Chapter 4: Tree writing questions</title><link>http://zhu45.org/posts/2017/Jan/26/maw-chapter-4-tree-writing-questions/</link><description>&lt;p&gt;There are a lot of writing questions in Chapter 4. Some questions offer
great insights on the general techniques in solving algorithmatic proving questions.
So, I decide to record them in this single post. Of course, this post will be continually
updated as I work through the chapter.&lt;/p&gt;
&lt;h2 id="insights"&gt;Insights&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Recursive tree definition is a natural fit with induction (i.e., MAW 4.5, 4.6, 4.7).&lt;/li&gt;
&lt;li&gt;Usually there are two ways to prove a problem in tree, one direction is from induction
  and the other one is from basic tree property (i.e., MAW 4.4, 4.6).&lt;/li&gt;
&lt;li&gt;Combinatorics (relating to binomials) and Probability theory (discrete part) are important to look at (i.e., MAW 4.14)&lt;/li&gt;
&lt;li&gt;We can usually study some specific examples, and try to generalize them to form induction proof. 
  In addition, always remember we want to convert the problem for &lt;span class="math"&gt;\(n+1\)&lt;/span&gt; into the same problem but 
  with the inductive step on &lt;span class="math"&gt;\(n\)&lt;/span&gt;. (MAW 4.17)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="solutions"&gt;Solutions&lt;/h2&gt;
&lt;p&gt;including: MAW 4.4, 4.5, 4.6, 4.7, 4.14, 4.15, 4.16, 4.17, 4.23, 4.24, 4.25, 4.26.a, 4.43&lt;/p&gt;
&lt;h3 id="maw-44"&gt;MAW 4.4&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Show that in a binary tree of &lt;span class="math"&gt;\(N\)&lt;/span&gt; nodes, there are &lt;span class="math"&gt;\(N + 1\)&lt;/span&gt; &lt;code&gt;NULL&lt;/code&gt; pointers
representing children.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Proof:&lt;/strong&gt;
For a binary tree with &lt;span class="math"&gt;\(N\)&lt;/span&gt; nodes, there are two types of edges (pointers): &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;edges that are doesn't exist (&lt;code&gt;NULL&lt;/code&gt; pointers).&lt;/li&gt;
&lt;li&gt;edges that exist to connect nodes (not &lt;code&gt;NULL&lt;/code&gt; pointers).&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Let's first calculate the number of pointers in total, regardless whether the pointer
is &lt;code&gt;NULL&lt;/code&gt; or not. Since each node has &lt;span class="math"&gt;\(2\)&lt;/span&gt; outgoing pointers, 
there are &lt;span class="math"&gt;\(2N\)&lt;/span&gt; pointers in total. Next, we need to calculate the number of edges that actuall
exist. Since each edge connects some node to its parent, and every node except 
the root has one parent. In other words, each node, except the root node, has one incoming
pointer from its parent. So, we have &lt;span class="math"&gt;\(N-1\)&lt;/span&gt; edges existing. Thus the remaining
&lt;span class="math"&gt;\(2N - (N-1) = N+1\)&lt;/span&gt; edges are actually non-existing. Thus, we have &lt;span class="math"&gt;\(N+1\)&lt;/span&gt; &lt;code&gt;NULL&lt;/code&gt; pointers.&lt;/p&gt;
&lt;h3 id="maw-45"&gt;MAW 4.5&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Show that the maximum number of nodes in a binary tree of height &lt;span class="math"&gt;\(H\)&lt;/span&gt; is &lt;span class="math"&gt;\(2^{H+1}-1\)&lt;/span&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Proof:&lt;/strong&gt; 
Let's prove this by induction.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Base case:&lt;/em&gt; &lt;span class="math"&gt;\(H = 0\)&lt;/span&gt;. A binary tree of height &lt;span class="math"&gt;\(0\)&lt;/span&gt; has only one node, root. &lt;span class="math"&gt;\(2^{H+1}-1\)&lt;/span&gt; equals
one for &lt;span class="math"&gt;\(H = 0\)&lt;/span&gt;. Therefore ture for &lt;span class="math"&gt;\(H = 0\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Inductive Hypothesis:&lt;/em&gt; Assume that the maximum number of nodes in a binary tree of height &lt;span class="math"&gt;\(H\)&lt;/span&gt; is
&lt;span class="math"&gt;\(2^{H+1}-1\)&lt;/span&gt; for &lt;span class="math"&gt;\(H = 1, 2, ..., k\)&lt;/span&gt;. Consider a tree &lt;span class="math"&gt;\(T\)&lt;/span&gt; of height &lt;span class="math"&gt;\(k+1\)&lt;/span&gt;. The root of &lt;span class="math"&gt;\(T\)&lt;/span&gt; has 
a left subtree and a right subtree each of which has height at most &lt;span class="math"&gt;\(k\)&lt;/span&gt;. These can have
at most &lt;span class="math"&gt;\(2^{k+1}-1\)&lt;/span&gt; nodes each by the inductive hypothesis. Adding the root node gives the 
maximum number of nodes in a binary tree of height &lt;span class="math"&gt;\(k+1\)&lt;/span&gt;, &lt;/p&gt;
&lt;div class="math"&gt;$$
\begin{equation} 
2(2^{k+1} - 1) + 1 = 2^{(k+1)+1} - 1 
\end{equation}
$$&lt;/div&gt;
&lt;p&gt;Remarks:&lt;/p&gt;
&lt;p&gt;The maximum condition achieves when we have &lt;em&gt;perfect binary tree&lt;/em&gt;.&lt;/p&gt;
&lt;div class="math"&gt;$$
\begin{equation}
n = \sum_{i=0}^{h} 2^i = 2^{h+1} - 1 \text{where n is the number of nodes} 
\end{equation}
$$&lt;/div&gt;
&lt;h3 id="maw-46"&gt;MAW 4.6&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;A &lt;em&gt;full node&lt;/em&gt; is a node with two children. Prove that the number of full nodes
plus one is equal to the number of leaves in a nonempty binary tree.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Let's use two methods to prove this question.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Method 1:&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Proof:&lt;/strong&gt;
Let's use the following notation for our proof:&lt;/p&gt;
&lt;div class="math"&gt;$$
\begin{eqnarray*}
N &amp;amp; = &amp;amp; \text{number of nodes in a nonempty binary tree} \\
F &amp;amp; = &amp;amp; \text{number of full nodes} \\
H &amp;amp; = &amp;amp; \text{number of nodes with one child} \\
L &amp;amp; = &amp;amp; \text{number of leaves}
\end{eqnarray*}
$$&lt;/div&gt;
&lt;p&gt;Then, we have &lt;span class="math"&gt;\(N = F + H + L \label{eq:1}\)&lt;/span&gt;. We can get another equation based on the number of 
edges: &lt;span class="math"&gt;\(N - 1 = 2F + H \label{eq:2}\)&lt;/span&gt;. &lt;span class="math"&gt;\(N-1\)&lt;/span&gt; is the number of edges for a &lt;span class="math"&gt;\(N\)&lt;/span&gt; node binary tree 
and &lt;span class="math"&gt;\(2F + H\)&lt;/span&gt; is another way to calculate the number of edges. Now based on these 
two euqations we have:&lt;/p&gt;
&lt;div class="math"&gt;$$
\begin{eqnarray*}
2F + H + 1 &amp;amp; = &amp;amp; F + H + L \\
F + 1 &amp;amp; = &amp;amp; L
\end{eqnarray*}
$$&lt;/div&gt;
&lt;p&gt;&lt;em&gt;Method 2:&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Proof:&lt;/strong&gt;
Let's prove by induction. If there are &lt;span class="math"&gt;\(N\)&lt;/span&gt; full nodes in a non-empty binary tree
then there are &lt;span class="math"&gt;\(N+1\)&lt;/span&gt; leaves.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Base case:&lt;/em&gt; &lt;span class="math"&gt;\(N = 0\)&lt;/span&gt; This is ture because the tree has one node and the root is 
a leaf.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Inductive hypothesis:&lt;/em&gt; Suppose the theorem holds for &lt;span class="math"&gt;\(N = 1, 2, ..., k\)&lt;/span&gt;. Then we 
want to show that if there are &lt;span class="math"&gt;\(k+1\)&lt;/span&gt; full nodes in a non-empty binary tree then there 
are &lt;span class="math"&gt;\(k+2\)&lt;/span&gt; leaves. Pick a leaf node and keep removing its parent recursively 
(i.e., remove its parent and then parent's parent and so on) until a full node
is reached. That is, you are traversing from a leaf along the path towards the root,
while removing the nodes along the path before a full node is reached. This full node
becomes a non-full node because one of its child node is removed. At this point the
tree will have one less leaf and one less full node.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://zhu45.org/images/maw-4-6.PNG" /&gt;&lt;/p&gt;
&lt;p&gt;Therefore, the tree has &lt;span class="math"&gt;\(k\)&lt;/span&gt; full nodes after the nodes are removed. By the inductive
hypothesis there are &lt;span class="math"&gt;\(k+1\)&lt;/span&gt; leaves. Add all the nodes that were removed back into the 
tree the same way to create the original tree. We are adding one full node and 
one leaf node. Therefore, we have &lt;span class="math"&gt;\(k+1\)&lt;/span&gt; full nodes with &lt;span class="math"&gt;\(k+2\)&lt;/span&gt; leaves.&lt;/p&gt;
&lt;h3 id="maw-47"&gt;MAW 4.7&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Suppose a binary tree has leaves &lt;span class="math"&gt;\(l_{1}, l_{2}, ..., l_{M}\)&lt;/span&gt; at depths
&lt;span class="math"&gt;\(d_{1}, d_{2}, ...,d_{M}\)&lt;/span&gt;, repectively. Prove that &lt;span class="math"&gt;\(\sum_{i=1}^M 2^{-d_{i}} \leq 1\)&lt;/span&gt;
and determine when the quality is true.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Proof:&lt;/strong&gt;
Let's prove this by induction. &lt;/p&gt;
&lt;p&gt;&lt;em&gt;Base case:&lt;/em&gt; when &lt;span class="math"&gt;\(M = 1\)&lt;/span&gt;, there is one node: the root is a leaf wit depth zero. Then
the sum is one, and claim holds.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Inductive hypothesis:&lt;/em&gt; Suppose the theorem is true for all trees with at most &lt;span class="math"&gt;\(k\)&lt;/span&gt; nodes.
Consider any tree with &lt;span class="math"&gt;\(k+1\)&lt;/span&gt; nodes. Such a tree consists of an &lt;span class="math"&gt;\(i\)&lt;/span&gt; node left subtree and 
a &lt;span class="math"&gt;\(k-i\)&lt;/span&gt; node right subtree. By the inductive hypothesis, the sum for the left subtree
leaves is at most one with respect to the left tree root. Because all leaves are one deeper
with respect to the original tree than with respect to the subtree, the sum is at
most &lt;span class="math"&gt;\(1/2\)&lt;/span&gt; with respect to the root. Similar logic implies that the sum for leaves 
in the right subtree is at most &lt;span class="math"&gt;\(1/2\)&lt;/span&gt; proving the theorem.&lt;/p&gt;
&lt;p&gt;The equality is true if and only if every internal node is a full node. In other words,
no nodes have one child. Suppose there is a node with one child, and the equality still
holds. Each time we remove two nodes to create a new tree that has a node with no child.
This new tree has the same property has the previous one, and by the statement we proved
above, we should have the same sum as the old, which is one. Eventually, we are left
with two node, one of them is root. Now, we calculate the sum, which gives &lt;span class="math"&gt;\(1/2\)&lt;/span&gt;. This 
is contradiction to the equality.&lt;/p&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;This problem is called 
&lt;a href="https://en.wikipedia.org/wiki/Kraft%E2%80%93McMillan_inequality"&gt;KraftMcMillan inequality&lt;/a&gt;,
which is one of fundamental theorem in Information theory. I find 
&lt;a href="https://www.youtube.com/playlist?list=PLE125425EC837021F"&gt;this youtube playlist about information theory&lt;/a&gt;
is really good as an intro to the field because it doesn't make the material look 
very daunting and super technical,
which some 
&lt;a href="http://circuit.ucsd.edu/~yhk/ece154c-spr16/pdfs/LectureNotes01.pdf"&gt;lecture note&lt;/a&gt;
 manages to achieve.&lt;/p&gt;
&lt;/div&gt;
&lt;h3 id="maw-414"&gt;MAW 4.14&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Prove that the depth of a random binary search tree (depth of the deepest node) is &lt;span class="math"&gt;\(O(\log N)\)&lt;/span&gt;, on average.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;This question can be restated like the following: suppose that we insert &lt;span class="math"&gt;\(n\)&lt;/span&gt; distinct elements into an 
initially empty tree. Assuming that the &lt;span class="math"&gt;\(n!\)&lt;/span&gt; permutations are equally likely to occur, then show that
the average height of the tree is &lt;span class="math"&gt;\(O(\log N)\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;Before we dive into the proof, let's think about how we can construct a random binary search tree.
We construct a tree &lt;span class="math"&gt;\(T\)&lt;/span&gt; by inserting in order randomly selected &lt;span class="math"&gt;\(n\)&lt;/span&gt; distinct elements into an 
initially empty tree. Here the actual values of the elements do not matter. What matters is the position
of the inserted element in the &lt;span class="math"&gt;\(n\)&lt;/span&gt; elements. Thus, we construct a random binary search tree as the following:&lt;/p&gt;
&lt;p&gt;An element &lt;span class="math"&gt;\(i\)&lt;/span&gt; from the &lt;span class="math"&gt;\(n\)&lt;/span&gt; elements is selected uniformly ar random and is inserted to the empty tree. Then all 
the other elements are inserted. Here all the elements greater than &lt;span class="math"&gt;\(i\)&lt;/span&gt; go into the right subtree of &lt;span class="math"&gt;\(i\)&lt;/span&gt;
and all the elements smaller than &lt;span class="math"&gt;\(i\)&lt;/span&gt; go into the left subtree. Thus, the height of the tree constructed
is one plus the larger of the height of the left subtree and the height of the right subtree.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Proof:&lt;/strong&gt;
Following our construction process above, if we randomly choose the &lt;span class="math"&gt;\(i^{th}\)&lt;/span&gt; key, the left
subtree has &lt;span class="math"&gt;\(i-1\)&lt;/span&gt; elements and the right subtree has &lt;span class="math"&gt;\(n-i\)&lt;/span&gt; elements. Let &lt;span class="math"&gt;\(h_{n}\)&lt;/span&gt; be the
height of a randomly built binary search tree on &lt;span class="math"&gt;\(n\)&lt;/span&gt; keys. Then we have&lt;/p&gt;
&lt;div class="math"&gt;$$
\begin{equation} 
h_{n} = 1 + max(h_{i-1}, h_{n-i}) \label{eqn:1}
\end{equation}
$$&lt;/div&gt;
&lt;p&gt;Now, let's define &lt;span class="math"&gt;\(Y_{n} = 2^{h_n}\)&lt;/span&gt;. If we can show 
that &lt;span class="math"&gt;\(E[Y_n]\)&lt;/span&gt; is polynomial in &lt;span class="math"&gt;\(n\)&lt;/span&gt;, we then have &lt;span class="math"&gt;\(E[h_n] = O(\log n)\)&lt;/span&gt;. Again, &lt;span class="math"&gt;\(Y_n\)&lt;/span&gt; 
depends on &lt;span class="math"&gt;\(i\)&lt;/span&gt; not &lt;span class="math"&gt;\(n\)&lt;/span&gt;. Let's represent \ref{eqn:1} in terms of &lt;span class="math"&gt;\(Y_n\)&lt;/span&gt;:&lt;/p&gt;
&lt;div class="math"&gt;$$
\begin{eqnarray*}
h_{n} &amp;amp;=&amp;amp; 1 + max(h_{i-1}, h_{n-i}) \\
2^{h_n} &amp;amp;=&amp;amp; 2^{1 + max(h_{i-1}, h_{n-i})} \\
        &amp;amp;=&amp;amp; 2 \cdot 2^{max(h_{i-1}, h_{n-i})} \\
        &amp;amp;=&amp;amp; 2 \cdot max(2^{h_{i-1}}, 2^{h_{n-i}}) \\
Y_n     &amp;amp;=&amp;amp; 2 \cdot max(Y_{i-1}, Y_{n-i}) 
\end{eqnarray*}
$$&lt;/div&gt;
&lt;p&gt;Now, let's calculate &lt;span class="math"&gt;\(E[Y_n]\)&lt;/span&gt;. Here, &lt;span class="math"&gt;\(I=i\)&lt;/span&gt; means we pick &lt;span class="math"&gt;\(i_{th}\)&lt;/span&gt; element as our 
first element inserting into the empty tree.Since, we pick the first insertion element equally
likely, then &lt;span class="math"&gt;\(P(I=i) = \frac{1}{n}\)&lt;/span&gt;.&lt;/p&gt;
&lt;div class="math"&gt;$$
\begin{eqnarray*}
E[Y_n] &amp;amp;=&amp;amp; \sum_{i=1}^n E[Y_n|I=i]P(I=i) \\
       &amp;amp;=&amp;amp; \sum_{i=1}^n E[Y_n|I=i]\frac{1}{n} \\
       &amp;amp;=&amp;amp; \frac{2}{n}\sum_{i=1}^n E[max(Y_{i-1},Y_{n-i})] \\
       &amp;amp;\le&amp;amp; \frac{2}{n}\sum_{i=1}^n (E[Y_{i-1}] + E[Y_{n-i}])
\end{eqnarray*}
$$&lt;/div&gt;
&lt;p&gt;Now we expand the last summation as&lt;/p&gt;
&lt;div class="math"&gt;$$
\begin{equation*}
(E[Y_0] + E[Y_{n-1}]) + \dots + (E[Y_{n-1}] + E[Y_0]) = 2\sum_{i=0}^{n-1}E[Y_i]
\end{equation*}
$$&lt;/div&gt;
&lt;p&gt;Thus, we have&lt;/p&gt;
&lt;div class="math"&gt;$$
\begin{equation*}
E[Y_n] \le \frac{4}{n}\sum_{i=0}^{n-1}E[Y_i]
\end{equation*}
$$&lt;/div&gt;
&lt;p&gt;Then, we will show that for all integers &lt;span class="math"&gt;\(n&amp;gt;0\)&lt;/span&gt;, &lt;/p&gt;
&lt;div class="math"&gt;$$
\begin{eqnarray*}
E[Y_n] &amp;amp;\le&amp;amp; \frac{1}{4}\dbinom{n+3}{3} \\
       &amp;amp;=&amp;amp; \frac{1}{4}\cdot\frac{(n+3)(n+2)(n+1)}{6} \\ 
       &amp;amp;=&amp;amp; O(n^3)
\end{eqnarray*}
$$&lt;/div&gt;
&lt;p&gt;Then, we use &lt;em&gt;Jensen's inequality&lt;/em&gt;, which states that &lt;span class="math"&gt;\(f(E[X]) \le E[f(X)]\)&lt;/span&gt; provided
the expectations exist and are finite, and f(x) is convex. Let this &lt;span class="math"&gt;\(X\)&lt;/span&gt; be &lt;span class="math"&gt;\(h_n\)&lt;/span&gt; and
&lt;span class="math"&gt;\(f(x) = 2^x\)&lt;/span&gt;, then &lt;span class="math"&gt;\(E[f(X)] = E[Y_n]\)&lt;/span&gt;. So, we have&lt;/p&gt;
&lt;div class="math"&gt;$$
\begin{equation*}
2^{E[h_n]} \le \frac{1}{4}\dbinom{n+3}{3} = O(n^3)
\end{equation*}
$$&lt;/div&gt;
&lt;p&gt;By taking the log of both sides, we have &lt;span class="math"&gt;\(E[h_n] = O(\log n)\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Remarks:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Let's first prove &lt;span class="math"&gt;\(\sum_{i=0}^{n-1}\dbinom{i+3}{3} = \dbinom{n+3}{4}\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Proof:&lt;/strong&gt; Use &lt;em&gt;Pascal's identity:&lt;/em&gt; &lt;span class="math"&gt;\(\dbinom{n}{k} = \dbinom{n-1}{k-1} + \dbinom{n-1}{k}\)&lt;/span&gt;
Also using the simple identity &lt;span class="math"&gt;\(\dbinom{4}{4} = 1 = \dbinom{3}{3}\)&lt;/span&gt;. We have:&lt;/p&gt;
&lt;div class="math"&gt;$$
\begin{eqnarray*}
\dbinom{n+3}{4} &amp;amp;=&amp;amp; \dbinom{n+2}{3} + \dbinom{n+2}{4} \\
                &amp;amp;=&amp;amp; \dbinom{n+2}{3} + \dbinom{n+1}{3} + \dbinom{n+1}{4} \\
                &amp;amp;=&amp;amp; \dbinom{n+2}{3} + \dbinom{n+!}{3} + \dbinom{n}{3} + \dbinom{n}{4} \\
                &amp;amp;\vdots&amp;amp; \\
                &amp;amp;=&amp;amp; \dbinom{n+2}{3} + \dbinom{n+!}{3} + \dbinom{n}{3} + \dots + \dbinom{4}{3} + \dbinom{4}{4} \\
                &amp;amp;=&amp;amp; \sum_{i=0}^{n-1}\dbinom{i+3}{3}
\end{eqnarray*}
$$&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;Let's prove &lt;span class="math"&gt;\(E[Y_n] \le \frac{1}{4}\dbinom{n+3}{3}\)&lt;/span&gt; by induction.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Proof:&lt;/strong&gt; &lt;em&gt;Base case:&lt;/em&gt; &lt;span class="math"&gt;\(n=1\)&lt;/span&gt;. &lt;/p&gt;
&lt;div class="math"&gt;$$
\begin{equation*}
1 = Y_1 = E[Y_1] \le \frac{1}{4}\dbinom{1+3}{3} = 1.
\end{equation*}
$$&lt;/div&gt;
&lt;p&gt;&lt;em&gt;Inductive hypothesis:&lt;/em&gt; Assume that &lt;span class="math"&gt;\(E[Y_i]\le\frac{1}{4}\dbinom{i+3}{3}\)&lt;/span&gt; for all &lt;span class="math"&gt;\(i&amp;lt;n\)&lt;/span&gt;. Then,&lt;/p&gt;
&lt;div class="math"&gt;$$
\begin{eqnarray*}
E[Y_n] &amp;amp;\le&amp;amp; \frac{4}{n}\sum_{i=0}^{n-1}E[Y_i] \\
       &amp;amp;\le&amp;amp; \frac{1}{4}\dbinom{i+3}{3} \\
       &amp;amp;=&amp;amp;   \frac{1}{n}\sum_{i=0}^{n-1}\dbinom{i+3}{3} \\
       &amp;amp;=&amp;amp;   \frac{1}{n}\dbinom{n+3}{4} \\
       &amp;amp;=&amp;amp;   \frac{1}{n}\frac{(n+3)!}{4!(n-1)!} \\
       &amp;amp;=&amp;amp;   \frac{1}{4}\frac{(n+3)!}{3!n!} \\
       &amp;amp;=&amp;amp;   \frac{1}{4}\dbinom{n+3}{3}
\end{eqnarray*}
$$&lt;/div&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;I 
&lt;a href="https://www.cs.bgu.ac.il/~fds112/wiki.files/P05.pdf"&gt;reference this lecture note&lt;/a&gt;
 when I try to develop the proof. 
Overall, I share the similar proof with this one. However, we have slightly 
difference in terms of how we 
define &lt;span class="math"&gt;\(E[Y_n]\)&lt;/span&gt;. The note defines an indicator random variables 
&lt;span class="math"&gt;\(Z_{n,i} = I\{I=i\}\)&lt;/span&gt;, where &lt;span class="math"&gt;\(I=i\)&lt;/span&gt; means we pick &lt;span class="math"&gt;\(i_{th}\)&lt;/span&gt; element as our 
first element inserting into the empty tree. Since, we pick the first insertion 
element equally likely, then &lt;span class="math"&gt;\(P(I=i) = \frac{1}{n}\)&lt;/span&gt;, and thus, &lt;span class="math"&gt;\(E[Z_{n,i}] = \frac{1}{n}\)&lt;/span&gt; by &lt;span class="math"&gt;\(E[I_A] = P(A)\)&lt;/span&gt;. Then, he defines &lt;span class="math"&gt;\(Y_n = \sum_{i=1}^nZ_{n,i} \cdot (2 \cdot max(Y_{i-1}, Y_{n-i}))\)&lt;/span&gt; because only one &lt;span class="math"&gt;\(Z_{n,i}\)&lt;/span&gt; can be &lt;span class="math"&gt;\(1\)&lt;/span&gt; and all others are &lt;span class="math"&gt;\(0\)&lt;/span&gt;. It seems right but when he calculates the &lt;span class="math"&gt;\(E[Y_n]\)&lt;/span&gt;, he states that
&lt;span class="math"&gt;\(Z_{n,i}\)&lt;/span&gt; is independent of &lt;span class="math"&gt;\(Y_{i-1}\)&lt;/span&gt; and &lt;span class="math"&gt;\(Y_{n-i}\)&lt;/span&gt;. However, I don't think so as 
the height of the tree &lt;span class="math"&gt;\(h_n\)&lt;/span&gt;, which &lt;span class="math"&gt;\(Y_n\)&lt;/span&gt; is constructed from 
depends on which element we pick first. I tend to think about &lt;span class="math"&gt;\(E[Y_n]\)&lt;/span&gt; as 
expectation of the conditional expectation.&lt;/p&gt;
&lt;/div&gt;
&lt;h3 id="maw-415"&gt;MAW 4.15&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;a. Give a precise expression for the minimum number of nodes in an AVL tree of height &lt;span class="math"&gt;\(H\)&lt;/span&gt;.
b. What is the minimum number of nodes in an AVL tree of height 15? &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The minimum number of nodes in an AVL tree of height &lt;span class="math"&gt;\(H\)&lt;/span&gt;, &lt;span class="math"&gt;\(S(H) = S(H-1) + S(H-2) + 1 \quad (H \ge 2)\)&lt;/span&gt; with &lt;span class="math"&gt;\(S(0) = 1\)&lt;/span&gt; and &lt;span class="math"&gt;\(S(1) = 2\)&lt;/span&gt;.
It's a linear nonhomogeneous recurrence relation with constant coefficients. Let's first find 
out the general solution for corresponding homogeneous recurrence relation &lt;span class="math"&gt;\(S(H) = S(H-1) + S(H-2)\)&lt;/span&gt; first.
The characteristic equation is &lt;span class="math"&gt;\(x^2 - x - 1 = 0\)&lt;/span&gt; and the roots are &lt;span class="math"&gt;\(\frac{1+\sqrt 5}{2}\)&lt;/span&gt; and &lt;span class="math"&gt;\(\frac{1-\sqrt 5}{2}\)&lt;/span&gt;.
So, we have &lt;span class="math"&gt;\(S(H) = c_1\Big(\frac{1+\sqrt 5}{2}\Big)^H + c_2\Big(\frac{1-\sqrt 5}{2}\Big)^H\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;Now, for a particular solution to the recurrence relation, let's guess &lt;span class="math"&gt;\(S(H) = r \quad \text{for some constant } r\)&lt;/span&gt;.
This solution has to satisfy the recurrence relation as well. Thus, &lt;/p&gt;
&lt;div class="math"&gt;$$
\begin{equation*}
r = r + r + 1
\end{equation*}
$$&lt;/div&gt;
&lt;p&gt;So, we have &lt;span class="math"&gt;\(r = -1\)&lt;/span&gt;. Thus, &lt;span class="math"&gt;\(S(H) = c_1\Big(\frac{1+\sqrt 5}{2}\Big)^H + c_2\Big(\frac{1-\sqrt 5}{2}\Big)^H - 1\)&lt;/span&gt;. We plugin
the initial condition to our general solution to solve for &lt;span class="math"&gt;\(c_1\)&lt;/span&gt; and &lt;span class="math"&gt;\(c_2\)&lt;/span&gt;. We get &lt;span class="math"&gt;\(c_1 = 1 + \frac{2}{\sqrt 5}\)&lt;/span&gt;
and &lt;span class="math"&gt;\(c_2 = 1 - \frac{2}{\sqrt 5}\)&lt;/span&gt;. Thus, we have &lt;/p&gt;
&lt;div class="math"&gt;$$
\begin{equation}
S(H) = \Big(1 + \frac{2}{\sqrt 5}\Big)\Big(\frac{1+\sqrt 5}{2}\Big)^H + \Big(1 - \frac{2}{\sqrt 5}\Big)\Big(\frac{1-\sqrt 5}{2}\Big)^H - 1 \label{eqn:2}
\end{equation}
$$&lt;/div&gt;
&lt;p&gt;Now, let &lt;span class="math"&gt;\(H = 15\)&lt;/span&gt; and we have &lt;span class="math"&gt;\(S(15) = 2583\)&lt;/span&gt;.&lt;/p&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;Initial condition is for the general solution for the recurrence relation, not 
the homogeneous part. Thus, we cannot use the initial condition immediately when 
we have our homogeneous part done.We need to wait until the whole solution 
(homogeneous part + particular part).&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Remarks:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;With \ref{eqn:2}, we can actually get the bound of the height of an AVL tree. &lt;/p&gt;
&lt;p&gt;By \ref{eqn:2}, we see that &lt;span class="math"&gt;\(S(H) \ge \Big(\frac{1+\sqrt 5}{2}\Big)^H\)&lt;/span&gt;. Suppose we have &lt;span class="math"&gt;\(N\)&lt;/span&gt; nodes in an AVL 
tree of height &lt;span class="math"&gt;\(H\)&lt;/span&gt;. Then &lt;span class="math"&gt;\(N \ge S(H) \ge \Big(\frac{1+\sqrt 5}{2}\Big)^H\)&lt;/span&gt;. Let &lt;span class="math"&gt;\(\phi = \frac{1+\sqrt 5}{2}\)&lt;/span&gt;, then
we have &lt;span class="math"&gt;\(\log _\phi N \ge H\)&lt;/span&gt;, which is &lt;span class="math"&gt;\(H \le 1.44\log _2 N = O(\log N)\)&lt;/span&gt;.&lt;/p&gt;
&lt;h3 id="maw-416"&gt;MAW 4.16&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Show the result of inserting 2,1,4,5,9,3,6,7 into an initially empty AVL tree.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href="https://github.com/xxks-kkk/Code-for-blog/blob/master/2017/graphviz-drawings/maw-4-16.gv"&gt;
&lt;img src="/images/maw-4-16.png" alt="maw-4-16" style="width: 700px;"/&gt;
&lt;/a&gt;&lt;/p&gt;
&lt;!--[![maw-4-16](/images/maw-4-16.png)](https://github.com/xxks-kkk/Code-for-blog/blob/master/2017/graphviz-drawings/maw-4-16.gv)--&gt;

&lt;h3 id="maw-417"&gt;MAW 4.17&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Keys &lt;span class="math"&gt;\(1, 2, \dots, 2^k-1\)&lt;/span&gt; are inserted in order into an initially empty AVL tree. Prove that the resulting tree
is perfectly balanced &lt;sup id="fnref:1"&gt;&lt;a class="footnote-ref" href="#fn:1" rel="footnote"&gt;1&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Proof:&lt;/strong&gt;
Let's use induction on &lt;span class="math"&gt;\(k\)&lt;/span&gt; to prove the following statement:&lt;/p&gt;
&lt;p&gt;The result of inserting any increasing sequence of &lt;span class="math"&gt;\(2^k - 1\)&lt;/span&gt; numbers into an 
  initially empty AVL tree results in a perfectly balanced tree of height 
  &lt;span class="math"&gt;\(k-1\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Base case:&lt;/em&gt; &lt;span class="math"&gt;\(k = 1\)&lt;/span&gt;. Tree has only one node. This is clearly perfectly balanced.
&lt;em&gt;Inductive hypothesis:&lt;/em&gt; Assume hypothesis is true for &lt;span class="math"&gt;\(k = 1, 2, \dots, h\)&lt;/span&gt;. We want to prove that it is true for &lt;span class="math"&gt;\(k = h + 1\)&lt;/span&gt;, i.e., 
for sequence &lt;span class="math"&gt;\(1, 2, \dots, 2^{h+1}-1\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;After the first &lt;span class="math"&gt;\(2^h - 1\)&lt;/span&gt; insertions, by the induction hypothesis, the tree is perfectly balanced, with height &lt;span class="math"&gt;\(h-1\)&lt;/span&gt;. &lt;span class="math"&gt;\(2^{h-1}\)&lt;/span&gt; is at the root
(can be observed for &lt;span class="math"&gt;\(1 \ge k \le 3\)&lt;/span&gt; situation, where the roots are &lt;span class="math"&gt;\(1\)&lt;/span&gt;, &lt;span class="math"&gt;\(2\)&lt;/span&gt;, &lt;span class="math"&gt;\(4\)&lt;/span&gt; respectively). The left subtree is a perfectly balanced
tree of height &lt;span class="math"&gt;\(h-2\)&lt;/span&gt;, and the right subtree is a perfectly balanced tree containing the numbers &lt;span class="math"&gt;\(2^{h-1}+1\)&lt;/span&gt; through &lt;span class="math"&gt;\(2^h-1\)&lt;/span&gt;, also of height &lt;span class="math"&gt;\(h-2\)&lt;/span&gt;.
See the following picture:&lt;/p&gt;
&lt;p&gt;&lt;img src="/images/maw-4-17-1.PNG" alt="maw-4-17-1" style="height: 400px;"/&gt;&lt;/p&gt;
&lt;p&gt;Each of the next &lt;span class="math"&gt;\(2^{h-1}\)&lt;/span&gt; insertions (&lt;span class="math"&gt;\(2^h\)&lt;/span&gt; through &lt;span class="math"&gt;\(2^h + 2^{h-1} - 1\)&lt;/span&gt;) are inserted into the 
right subtree, and the entire sequence of numbers in the right subtree (now &lt;span class="math"&gt;\(2^{h-1}+1\)&lt;/span&gt; through &lt;span class="math"&gt;\(2^h + 2^{h-1}-1\)&lt;/span&gt;)
were inserted in order and are a sequence of &lt;span class="math"&gt;\(2^h - 1\)&lt;/span&gt; nodes (i.e. &lt;span class="math"&gt;\(2^h + 2^{h-1}-1 - (2^{h-1}+1) + 1 = 2^h -1\)&lt;/span&gt;).
By induction hypothesis, they form a perfectly balanced tree of height &lt;span class="math"&gt;\(h-1\)&lt;/span&gt;. See the following picture:&lt;/p&gt;
&lt;p&gt;&lt;img src="/images/maw-4-17-2.PNG" alt="maw-4-17-2" style="height: 400px;"/&gt;&lt;/p&gt;
&lt;p&gt;The next insertion, of the number &lt;span class="math"&gt;\(2^h + 2^{h-1}\)&lt;/span&gt;, imbalances the tree at the root because now the height of the right subtree
is &lt;span class="math"&gt;\(h\)&lt;/span&gt; and the height of the left subtree is &lt;span class="math"&gt;\(h-2\)&lt;/span&gt;. Now, we do a single rotation and form a tree with root &lt;span class="math"&gt;\(2^h\)&lt;/span&gt;, and 
a perfectly balanced left subtree of height &lt;span class="math"&gt;\(h-1\)&lt;/span&gt;. The right subtree consists of a perfectly balanced tree 
(of height &lt;span class="math"&gt;\(h-2\)&lt;/span&gt;), with the new node: &lt;span class="math"&gt;\(2^h + 2^{h-1}\)&lt;/span&gt;. See the following picture:&lt;/p&gt;
&lt;p&gt;&lt;img src="/images/maw-4-17-3.PNG" alt="maw-4-17-3" style="height: 400px;"/&gt;&lt;/p&gt;
&lt;p&gt;Thus, the right subtree is as if the numbers &lt;span class="math"&gt;\(2^h+1, \dots, 2^h + 2^{h-1}\)&lt;/span&gt; had been 
inserted in order. We subsequently insert the numbers &lt;span class="math"&gt;\(2^h + 2^{h-1} + 1\)&lt;/span&gt; through
&lt;span class="math"&gt;\(2^{h+1} - 1\)&lt;/span&gt; nodes. In other words, we form the right subtree by inserting the 
numbers &lt;span class="math"&gt;\(2^{h} + 1, \dots, 2^{h+1} - 1\)&lt;/span&gt;, which have &lt;span class="math"&gt;\(2^{h} - 1\)&lt;/span&gt; numbers. Then, by
the inductive hypothesis, these &lt;span class="math"&gt;\(2^{h} - 1\)&lt;/span&gt; insertions form a perfectly balanced
subtree of height &lt;span class="math"&gt;\(h-1\)&lt;/span&gt;. See the following picture:&lt;/p&gt;
&lt;p&gt;&lt;img src="/images/maw-4-17-4.PNG" alt="maw-4-17-4" style="height: 400px;"/&gt;&lt;/p&gt;
&lt;p&gt;Since the left and right subtrees are perfectly balanced (height &lt;span class="math"&gt;\(h-1\)&lt;/span&gt;), the whole
tree is perfectly balanced.&lt;/p&gt;
&lt;h3 id="maw-423"&gt;MAW 4.23&lt;/h3&gt;
&lt;p&gt;&lt;img src="/images/maw-4-23.JPG" alt="maw-4-23" style="width: 700px;"/&gt;&lt;/p&gt;
&lt;h3 id="maw-424"&gt;MAW 4.24&lt;/h3&gt;
&lt;p&gt;&lt;img src="/images/maw-4-24.PNG" alt="maw-4-24" style="width: 700px;"/&gt;&lt;/p&gt;
&lt;h3 id="maw-425"&gt;MAW 4.25&lt;/h3&gt;
&lt;p&gt;This problem is solved through brute-force calculation. You can reference the example
from figure 4.46 to figure 4.55. I calculate for internal path length of the 
tree and &lt;code&gt;find(1)&lt;/code&gt;, &lt;code&gt;find(2)&lt;/code&gt;. The answer is slightly off than the solution manual.
May need to double check.&lt;/p&gt;
&lt;p&gt;&lt;img src="/images/maw-4-26.JPG" alt="maw-4-26" style="width: 700px; height: 400px;"/&gt;&lt;/p&gt;
&lt;h3 id="maw-426"&gt;MAW 4.26&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;a. Show that if all nodes in a splay tree are accessed in sequential order, 
the resulting tree consists of a chain of left children.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Proof:&lt;/strong&gt;
Let's prove by induction. Let &lt;span class="math"&gt;\(N\)&lt;/span&gt; denote the number of nodes in a splay tree.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Base case:&lt;/em&gt; When &lt;span class="math"&gt;\(N = 1\)&lt;/span&gt;, the claim holds.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Inductive hypothesis:&lt;/em&gt; all nodes &lt;span class="math"&gt;\(1, \dots, N\)&lt;/span&gt; in a splay tree are accessed in sequential
order, the resulting tree consists of a chain of left children. We want to show that 
this holds for &lt;span class="math"&gt;\(N+1\)&lt;/span&gt;. Once we access first &lt;span class="math"&gt;\(N\)&lt;/span&gt; nodes, there are only one
position for &lt;span class="math"&gt;\(N+1\)&lt;/span&gt; node: the right child of the root. The rest of positions are impossible because if the 
&lt;span class="math"&gt;\(N+1\)&lt;/span&gt; node is the right child of any node between the left most node and the root of the resulting tree,
then by BST, &lt;span class="math"&gt;\(N+1\)&lt;/span&gt; node's value is smaller than root's value and bigger than left most node's value.
This violates the induction hypothesis because we are no longer access a splay tree in sequential order.
Now we simply swap the right child of the root with root and we get a chain of left children. &lt;/p&gt;
&lt;h3 id="maw-443"&gt;MAW 4.43&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;a. Show that via AVL single rotations, any binary search tree &lt;span class="math"&gt;\(T_1\)&lt;/span&gt; can be transformed into another
search tree &lt;span class="math"&gt;\(T_2\)&lt;/span&gt; (with the same keys).
b. Give an algorithm to perform this transformation using &lt;span class="math"&gt;\(O(N\log N)\)&lt;/span&gt; rotations on average.
c. Show that this transformation can be done with &lt;span class="math"&gt;\(O(N)\)&lt;/span&gt; rotations, worst-case.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Let's first work through an example shown in the picture below. We transform the tree in the top-left 
of the picture to the tree in the top-right of the picture through several steps linked by single arrows.&lt;/p&gt;
&lt;p&gt;&lt;img src="/images/maw-4-43.jpg" alt="maw-4-43" style="width: 700px;"/&gt;&lt;/p&gt;
&lt;p&gt;As you can see, the strategy here is that we do preorder processing. We compare the root &lt;span class="math"&gt;\(T_1\)&lt;/span&gt; with the root
&lt;span class="math"&gt;\(T_2\)&lt;/span&gt;. If they are equal, then we move on to the left and right subtrees of &lt;span class="math"&gt;\(T_1\)&lt;/span&gt; and do the processing 
recursively. However, if they are not equal, we find the &lt;span class="math"&gt;\(T_2\)&lt;/span&gt;'s root value &lt;span class="math"&gt;\(x\)&lt;/span&gt; in &lt;span class="math"&gt;\(T_1\)&lt;/span&gt; and rotate it to the
root of &lt;span class="math"&gt;\(T_1\)&lt;/span&gt;. Then, we do the recursive processing for the left and right subtrees of &lt;span class="math"&gt;\(T_1\)&lt;/span&gt;. This algorithm
takes &lt;span class="math"&gt;\(O(N\log N)\)&lt;/span&gt; on average because find &lt;span class="math"&gt;\(x\)&lt;/span&gt; takes &lt;span class="math"&gt;\(O(\log N)\)&lt;/span&gt; time and AVL rotations also take &lt;span class="math"&gt;\(O(\log N)\)&lt;/span&gt; time. 
Since we could do &lt;span class="math"&gt;\(N\)&lt;/span&gt; rotations, then the result follows. However, a BST can be degenerated and in that case, we have 
&lt;span class="math"&gt;\(O(N)\)&lt;/span&gt; worst-case. &lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;The solution and corresponding figures are majorly taken from 
&lt;a href="https://cseweb.ucsd.edu/classes/su05/cse100/cse100hw1.pdf"&gt;this link&lt;/a&gt;
with minor wording tweak to allow easy understanding for myself.&amp;#160;&lt;a class="footnote-backref" href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['CommonHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' }, Macros: {} }," +
        "    jax: ['input/TeX','input/MathML','output/CommonHTML']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Zeyuan Hu</dc:creator><pubDate>Thu, 26 Jan 2017 17:41:00 +0800</pubDate><guid isPermaLink="false">tag:zhu45.org,2017-01-26:posts/2017/Jan/26/maw-chapter-4-tree-writing-questions/</guid><category>trees</category><category>proof</category><category>math</category><category>maw</category></item><item><title>Tree Terminology</title><link>http://zhu45.org/posts/2017/Jan/24/tree-terminology/</link><description>&lt;div class="section" id="terminology"&gt;
&lt;h2&gt;Terminology&lt;/h2&gt;
&lt;p&gt;Like &amp;quot;list&amp;quot; in Chapter 3, &amp;quot;Trees&amp;quot; is another type of abstraction.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;tree&lt;/strong&gt;, &lt;strong&gt;root&lt;/strong&gt;, &lt;strong&gt;edge&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;We can define a tree recursively. A tree is a collection of nodes. The collection
can be empty; otherwise, a tree consists of a distinguish node &lt;em&gt;r&lt;/em&gt;, called the
&lt;em&gt;root&lt;/em&gt;, and zero or more nonempty (sub)tress &lt;span class="math"&gt;\(T_1\)&lt;/span&gt;, &lt;span class="math"&gt;\(T_2\)&lt;/span&gt;, ..., &lt;span class="math"&gt;\(T_k\)&lt;/span&gt;,
each of whose roots are connected by a directed &lt;em&gt;edge&lt;/em&gt; from &lt;em&gt;r&lt;/em&gt;.&lt;/p&gt;
&lt;img alt="" src="/images/subtree.PNG" /&gt;
&lt;p&gt;&lt;strong&gt;child&lt;/strong&gt;, &lt;strong&gt;parent&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The root of each subtree is said to be a &lt;em&gt;child&lt;/em&gt; of &lt;em&gt;r&lt;/em&gt;, and &lt;em&gt;r&lt;/em&gt; is the &lt;em&gt;parent&lt;/em&gt;
of each subtree root.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;leaves&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Nodes with no children are known as &lt;em&gt;leaves&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;siblings&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Nodes with the same parent are &lt;em&gt;siblings&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;path&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A &lt;em&gt;path&lt;/em&gt; from node &lt;span class="math"&gt;\(n_1\)&lt;/span&gt; to &lt;span class="math"&gt;\(n_k\)&lt;/span&gt; is defined as a sequence of nodes
&lt;span class="math"&gt;\(n_1\)&lt;/span&gt;, &lt;span class="math"&gt;\(n_2\)&lt;/span&gt;, ..., &lt;span class="math"&gt;\(n_k\)&lt;/span&gt; such that &lt;span class="math"&gt;\(n_i\)&lt;/span&gt; is the parent of
&lt;span class="math"&gt;\(n_{i+1}\)&lt;/span&gt; for &lt;span class="math"&gt;\(1&amp;lt;= i &amp;lt; k\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;length&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The &lt;em&gt;length&lt;/em&gt; of this path is the number of edges on the path, namely &lt;span class="math"&gt;\(k-1\)&lt;/span&gt;.&lt;/p&gt;
&lt;div class="admonition note"&gt;
&lt;p class="first admonition-title"&gt;Note&lt;/p&gt;
&lt;ul class="last simple"&gt;
&lt;li&gt;There is a path of length zero from every node to itself.&lt;/li&gt;
&lt;li&gt;Notice that in a tree there is exactly one path from the root to each node.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;depth&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;For any node &lt;span class="math"&gt;\(n_i\)&lt;/span&gt;, the &lt;em&gt;depth&lt;/em&gt; of &lt;span class="math"&gt;\(n_i\)&lt;/span&gt;, is the length of the unique
path from the root to &lt;span class="math"&gt;\(n_i\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;internal path length&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The sum of the depths of all nodes in a tree is known as the &lt;em&gt;internal path length&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;height&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The &lt;em&gt;height&lt;/em&gt; of &lt;span class="math"&gt;\(n_i\)&lt;/span&gt; is the length of the longest path from &lt;span class="math"&gt;\(n_i\)&lt;/span&gt; to
a leaf.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ancestor&lt;/strong&gt;, &lt;strong&gt;descendant&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;If there is a path from &lt;span class="math"&gt;\(n_1\)&lt;/span&gt; to &lt;span class="math"&gt;\(n_2\)&lt;/span&gt;, then &lt;span class="math"&gt;\(n_1\)&lt;/span&gt; is an &lt;em&gt;ancestor&lt;/em&gt;
of &lt;span class="math"&gt;\(n_2\)&lt;/span&gt; and &lt;span class="math"&gt;\(n_2\)&lt;/span&gt; is a &lt;em&gt;descendant&lt;/em&gt; of &lt;span class="math"&gt;\(n_1\)&lt;/span&gt;. If &lt;span class="math"&gt;\(n_1 \neq n_2\)&lt;/span&gt;,
then &lt;span class="math"&gt;\(n_1\)&lt;/span&gt; is a &lt;em&gt;proper ancestor&lt;/em&gt; of &lt;span class="math"&gt;\(n_2\)&lt;/span&gt; and &lt;span class="math"&gt;\(n_2\)&lt;/span&gt; is a &lt;em&gt;proper descendant&lt;/em&gt; of &lt;span class="math"&gt;\(n_1\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;internal node&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;An &lt;em&gt;internal node&lt;/em&gt;  is a node with at least one child. In other words, internal nodes are nodes other than leaves.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;degree&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The total number of children of a node is called as &lt;em&gt;degree&lt;/em&gt; of that node. The highest
degree of a node among all the nodes in a tree is called as &lt;em&gt;degree of tree&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;level&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The root node is said to be at &lt;em&gt;level 0&lt;/em&gt; and the children of root node are at &lt;em&gt;level 1&lt;/em&gt;
and the children of the nodes which are at &lt;em&gt;level 1&lt;/em&gt; will be at &lt;em&gt;level 2&lt;/em&gt; and so on ...
In other words, in a tree each step from top to bottom is called as a &lt;em&gt;level&lt;/em&gt; and the &lt;em&gt;level&lt;/em&gt;
count starts with '0' and incremented by one at each level (step).&lt;/p&gt;
&lt;img alt="" src="/images/tree-level.PNG" /&gt;
&lt;p&gt;&lt;strong&gt;predecessor / successor&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;If &lt;span class="math"&gt;\(X\)&lt;/span&gt; has two children, its predecessor is the maximum value in its left subtree
and its successor the minimum value in its right subtree. It makes sense if we do in-order
traversal of the tree.&lt;/p&gt;
&lt;img src="/images/pred-succ.PNG" alt="predecessor-successor" style="width: 700px;"/&gt;&lt;/div&gt;
&lt;div class="section" id="some-properties"&gt;
&lt;h2&gt;Some properties&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;A tree is a collection of N nodes, one of which is the root, and N-1 edges.
(since each edge connects some node to its parent, and every node except
the root has one parent.)&lt;/li&gt;
&lt;li&gt;The root is at depth 0.&lt;/li&gt;
&lt;li&gt;All leaves are at height 0.&lt;/li&gt;
&lt;li&gt;The height of a tree is equal to the height of the root.&lt;/li&gt;
&lt;li&gt;The depth of a tree is equal to the depth of the deepest leaf; this is always
equal to the height of the tree.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="example"&gt;
&lt;h2&gt;Example&lt;/h2&gt;
&lt;p&gt;Let's work through MAW 4.1, 4.2, and 4.3 to get the tree terminology clear.&lt;/p&gt;
&lt;a class="reference external image-reference" href="https://github.com/xxks-kkk/Code-for-blog/blob/master/2017/graphviz-drawings/tree-terminology.gv"&gt;&lt;img alt="" src="/images/tree-terminology.png" /&gt;&lt;/a&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&amp;quot;A&amp;quot; is the &lt;em&gt;root&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&amp;quot;G&amp;quot;, &amp;quot;H&amp;quot;, &amp;quot;I&amp;quot;, &amp;quot;L&amp;quot;, &amp;quot;M&amp;quot;, &amp;quot;K&amp;quot; are the &lt;em&gt;leaves&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&amp;quot;A&amp;quot;:&lt;ul&gt;
&lt;li&gt;&lt;em&gt;children&lt;/em&gt;: &amp;quot;B&amp;quot;, &amp;quot;C&amp;quot;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;depth&lt;/em&gt;: 0&lt;/li&gt;
&lt;li&gt;&lt;em&gt;height&lt;/em&gt;: 4&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&amp;quot;B&amp;quot;:&lt;ul&gt;
&lt;li&gt;&lt;em&gt;parent&lt;/em&gt;: &amp;quot;A&amp;quot;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;children&lt;/em&gt;: &amp;quot;D&amp;quot;, &amp;quot;E&amp;quot;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;siblings&lt;/em&gt;: &amp;quot;C&amp;quot;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;depth&lt;/em&gt;: 1&lt;/li&gt;
&lt;li&gt;&lt;em&gt;height&lt;/em&gt;: 3&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;The depth of the tree is 4&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- `Tree - Terminology &lt;http://btechsmartclass.com/DS/U3_T1.html&gt;`_ --&gt;
&lt;/div&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['CommonHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' }, Macros: {} }," +
        "    jax: ['input/TeX','input/MathML','output/CommonHTML']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Zeyuan Hu</dc:creator><pubDate>Tue, 24 Jan 2017 20:23:00 +0800</pubDate><guid isPermaLink="false">tag:zhu45.org,2017-01-24:posts/2017/Jan/24/tree-terminology/</guid><category>trees</category><category>maw</category></item><item><title>MAW: Chapter 3 Reflection</title><link>http://zhu45.org/posts/2017/Jan/23/maw-chapter-3-reflection/</link><description>&lt;p&gt;I finally finish Chapter 3: List, Stacks, and Queues with almost all the problems
solved. It's time to do some summary and reflection.&lt;/p&gt;
&lt;div class="section" id="reflection"&gt;
&lt;h2&gt;Reflection&lt;/h2&gt;
&lt;p&gt;One important philosophy in this chapter is the
separation between the interface exposed to the user and the implementation details behind the scene.
The interface exposed to the user is the Abstract Data Types (ADTs). In this chapter,
the interface in this chapter is &amp;quot;List&amp;quot;. However, there are multiple implementations can meet the
requirement of the interface, which are &amp;quot;Array&amp;quot; and &amp;quot;Linked Lists&amp;quot;. We can further
categorize &amp;quot;List&amp;quot; interface into different subcategories &amp;quot;Stack&amp;quot;, &amp;quot;Queue&amp;quot;, &amp;quot;Deque&amp;quot;.
In other words, even we talk about &amp;quot;Stack&amp;quot; ADT, &amp;quot;Queue&amp;quot; ADT, and &amp;quot;Deque&amp;quot; ADT, they are
all essentially the &amp;quot;List&amp;quot; but with some restrictions in terms of list operations.
Here is a picture that helps us to understand this concept better:&lt;/p&gt;
&lt;img alt="" src="/images/maw-chap3.PNG" /&gt;
&lt;p&gt;In terms of actual implementation, we can get a sense of what's the basic structure that a data structure
should have. Take a linked list implementation of a queue as an example. The key characteristics
of a queue is that it should have a &lt;span class="math"&gt;\(O(1)\)&lt;/span&gt; operation on both enqueue and dequeue. This leads us to
the pointer to pointing both the front and rear of the list. Thus, our queue &amp;quot;queue.h&amp;quot; and &amp;quot;queue.c&amp;quot;
look like respectively:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;QueueRecord&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;QueueCDT&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;QueueRecord&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;PtrToNode&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;QueueCDT&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;QueueADT&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;QueueRecord&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;ET&lt;/span&gt; &lt;span class="n"&gt;Element&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;PtrToNode&lt;/span&gt; &lt;span class="n"&gt;Next&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;QueueCDT&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;PtrToNode&lt;/span&gt; &lt;span class="n"&gt;Front&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;PtrToNode&lt;/span&gt; &lt;span class="n"&gt;Rear&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Here, our queue pointed by &lt;tt class="docutils literal"&gt;QueueADT&lt;/tt&gt; is defined by two pointers: &lt;tt class="docutils literal"&gt;Front&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;Rear&lt;/tt&gt;.
Then, Those two pointers are pointing to our actual &lt;tt class="docutils literal"&gt;QueueRecord&lt;/tt&gt;, which how we form our linked list implementation.
So, when we implement a data structure, we can take a top-down view by first thinking about
what characterizes our data structure. That's the very important first step we take. Then, we can think
follow the flow naturally by defining what are the required elements to implement those characteristics.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="chapter-structure"&gt;
&lt;h2&gt;Chapter Structure&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Linked List&lt;/strong&gt;&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Singly Linked List&lt;/li&gt;
&lt;li&gt;Doubly Linked List&lt;/li&gt;
&lt;li&gt;Circular Linked List&lt;/li&gt;
&lt;li&gt;Applications:&lt;ul&gt;
&lt;li&gt;Polynomial ADT&lt;/li&gt;
&lt;li&gt;Raxi Sort&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Stacks&lt;/strong&gt;&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Linked List implementation&lt;/li&gt;
&lt;li&gt;Array implementation&lt;/li&gt;
&lt;li&gt;Applications:&lt;ul&gt;
&lt;li&gt;Balancing Symbols&lt;/li&gt;
&lt;li&gt;Postfix Expression (Postfix expression evaluation; Infix to Postfix Conversion)&lt;/li&gt;
&lt;li&gt;Function Call Stack&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Queue&lt;/strong&gt;&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Array implementation&lt;/li&gt;
&lt;li&gt;Linked List implementation&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="notable-questions"&gt;
&lt;h2&gt;Notable Questions&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p class="first"&gt;3.4, 3.5&lt;/p&gt;
&lt;p&gt;implement set operations using &amp;quot;List&amp;quot; interface. Especialy the union one
provides insights on how we can implement addition of polynomials (3.6)
and integer addition (3.9)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;3.6, 3.7, 3.8, 3.9&lt;/p&gt;
&lt;p&gt;a set of problems relating to Polynomial ADT&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;3.10, 3.24&lt;/p&gt;
&lt;p&gt;problems to practice recurrence relation. Josephus problem is particular
interesting because it's a good combination of mathematics, algorithm (dynamic programming)
and data structures.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;3.12, 3.21, 3.23&lt;/p&gt;
&lt;p&gt;commonly-seen interview questions&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;3.13&lt;/p&gt;
&lt;p&gt;require us to actually implement a radix sort in a real problem.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;3.18&lt;/p&gt;
&lt;p&gt;balancing symbols using Stack. A really cool problem that the end-product
is a tool that you can use in your daily work.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;3.19, 3.20&lt;/p&gt;
&lt;p&gt;Postfix, Infix related problems. Learn about &amp;quot;shunting yard&amp;quot; algorithm
and how left associate operators (i.e +, -) is different from
right associate operators (i.e ^) in terms of implementation.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;3.25, 3.26&lt;/p&gt;
&lt;p&gt;Implement Queue and its variation, Deque, using different data structures.
In particular, circular array implementation.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="left-out"&gt;
&lt;h2&gt;Left Out&lt;/h2&gt;
&lt;p&gt;Some material I left out when I work through this chapter:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;function calls as an example of stack (this part is going to be covered from computer system point of view
in the coming posts).&lt;/li&gt;
&lt;li&gt;cursor implementation of linked list (this part is not on the top priority for now).&lt;/li&gt;
&lt;li&gt;3.7.c, 3.14, 3.16, 3.18.a, 3.22.b&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['CommonHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' }, Macros: {} }," +
        "    jax: ['input/TeX','input/MathML','output/CommonHTML']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Zeyuan Hu</dc:creator><pubDate>Mon, 23 Jan 2017 10:45:00 +0800</pubDate><guid isPermaLink="false">tag:zhu45.org,2017-01-23:posts/2017/Jan/23/maw-chapter-3-reflection/</guid><category>meta</category><category>maw</category></item><item><title>Num of function calls in recursive Fibonacci routine</title><link>http://zhu45.org/posts/2017/Jan/22/num-of-function-calls-in-recursive-fibonacci-routine/</link><description>&lt;p&gt;This is MAW 3.24: &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;If the recursive rotuine in Section 2.4 used to computeFibonacci numbers is run for N = 50, is stack space likely to run out?Why or why not?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;long&lt;/span&gt;
&lt;span class="nf"&gt;Fib&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="k"&gt;else&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;Fib&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;Fib&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Let's first do an empirical experimentation. By running &lt;a href="https://github.com/xxks-kkk/Code-for-blog/blob/master/2017/numCalls/numCalls.c"&gt;our test program numCalls&lt;/a&gt;
and we can get the following output:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    i               Fib(i)          numCalls
    i = 0           1               1
    i = 1           1               1
    i = 2           2               3
    i = 3           3               5
    i = 4           5               9
    i = 5           8               15
    i = 6           13              25
    i = 7           21              41
    i = 8           34              67
    i = 9           55              109
    i = 10          89              177
    i = 11          144             287
    i = 12          233             465
    i = 13          377             753
    i = 14          610             1219
    i = 15          987             1973
    i = 16          1597            3193
    i = 17          2584            5167
    i = 18          4181            8361
    i = 19          6765            13529
    ... snip ...
    i = 50          20365011074     40730022147
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;We know that the Fibonacci numbers are defined by the following recurrence relation:&lt;/p&gt;
&lt;div class="math"&gt;$$
\begin{equation}
F(n) = F(n-1) + F(n-2), \text{ for }n = 2, 3, ... \label{eq:1}
\end{equation}
$$&lt;/div&gt;
&lt;p&gt;We define &lt;span class="math"&gt;\(F(0) = F(1) = 1\)&lt;/span&gt;. Now, we want to find out the number of recursive calls made to calculate &lt;span class="math"&gt;\(F(n)\)&lt;/span&gt;. We use &lt;span class="math"&gt;\(G(n)\)&lt;/span&gt; to denote the number of calls made by the recursive program in calculating &lt;span class="math"&gt;\(F(n)\)&lt;/span&gt;. Let's examine the output above. We see that &lt;span class="math"&gt;\(G(0) = G(1) = 1\)&lt;/span&gt; and to compute &lt;span class="math"&gt;\(G(n)\)&lt;/span&gt; for arbitrary &lt;span class="math"&gt;\(n\)&lt;/span&gt;, we'll make an initial call, and then &lt;span class="math"&gt;\(G(n-1)\)&lt;/span&gt; calls to calculate &lt;span class="math"&gt;\(F(n-1)\)&lt;/span&gt; and &lt;span class="math"&gt;\(G(n-2)\)&lt;/span&gt; calls to calculate &lt;span class="math"&gt;\(F(n-2)\)&lt;/span&gt;. Thus, we have the following recurrence relation for &lt;span class="math"&gt;\(G(n)\)&lt;/span&gt;:
&lt;/p&gt;
&lt;div class="math"&gt;$$
\begin{equation}
G(n) = G(n-1) + G(n-2) + 1 \label{eq:2}
\end{equation}
$$&lt;/div&gt;
&lt;p&gt;
Let's solve this recurrence relation by establish the relationship between &lt;span class="math"&gt;\(F(n)\)&lt;/span&gt; and &lt;span class="math"&gt;\(G(n)\)&lt;/span&gt; and then, we can get the closed form based upon the closed form of &lt;span class="math"&gt;\(F(n)\)&lt;/span&gt;. &lt;/p&gt;
&lt;p&gt;Let's suppose that &lt;span class="math"&gt;\(G(n)\)&lt;/span&gt; depends on &lt;span class="math"&gt;\(F(n)\)&lt;/span&gt; in some way. In other words, &lt;span class="math"&gt;\(G(n)\)&lt;/span&gt; is a function of &lt;span class="math"&gt;\(F(n)\)&lt;/span&gt;. Let's try linear form first:
&lt;/p&gt;
&lt;div class="math"&gt;$$
\begin{equation}
G(n) = a F(n) + b \text{ where a, b are unknown constants}  \label {eq:3}
\end{equation}
$$&lt;/div&gt;
&lt;p&gt;
Since we know that &lt;span class="math"&gt;\(G(0) = G(1) = 1\)&lt;/span&gt; and &lt;span class="math"&gt;\(F(0) = F(1) = 1\)&lt;/span&gt;, then \ref{eq:3} becomes &lt;/p&gt;
&lt;div class="math"&gt;$$
\begin{eqnarray*}
G(1)  &amp;amp; = &amp;amp; a F(1) + b \\
1 &amp;amp; = &amp;amp; a + b
\end{eqnarray*}
$$&lt;/div&gt;
&lt;p&gt;Now let's plugin \ref{eq:3} into \ref{eq:2} and using the \ref{eq:1} and we have:&lt;/p&gt;
&lt;div class="math"&gt;$$
\begin{eqnarray*}
G(n) &amp;amp; = &amp;amp; G(n-1) + G(n-2) + 1 \\
a F(n) + b &amp;amp; = &amp;amp; G(n-1) + G(n-2) + 1 \\
a (F(n-1) + F(n-2)) + b &amp;amp; = &amp;amp; G(n-1) + G(n-2) + 1 \\
a (F(n-1) + F(n-2)) + b &amp;amp; = &amp;amp; a F(n-1) + b + a F(n-2)) + b + 1 \\
b &amp;amp; = &amp;amp; -1
\end{eqnarray*}
$$&lt;/div&gt;
&lt;p&gt;Now, our \ref{eq:3} becomes &lt;span class="math"&gt;\(G(n) = 2F(n) - 1\)&lt;/span&gt;. That is, the number of function calls
to calculate a Fibonacci number &lt;span class="math"&gt;\(F(n)\)&lt;/span&gt; is &lt;span class="math"&gt;\(2F(n) - 1\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;Then the question asks about "is the stack space likely to run out?". This actually confuses
me because it seems like the author tries to indicate that there is a relationship between
the number of recursive calls and the actual space the program is going to take in call stack.
I have no clue so far. But, maybe we can find out the space of our &lt;code&gt;Fib&lt;/code&gt; routine
is going to take in call stack and how large the system call stack and we can compare the two
to get some insights.&lt;/p&gt;
&lt;p&gt;We can use &lt;code&gt;ulimit -a&lt;/code&gt; or &lt;code&gt;ulimit -s&lt;/code&gt; to find out the size of stack that system allows:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ &lt;span class="nb"&gt;ulimit&lt;/span&gt; -a
... snip ...
stack size              &lt;span class="o"&gt;(&lt;/span&gt;kbytes, -s&lt;span class="o"&gt;)&lt;/span&gt; 10240
... snip ...
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;As you can see, the default stack size is &lt;code&gt;10 MB&lt;/code&gt;. Let's see how large space our &lt;code&gt;Fib&lt;/code&gt;
is going to use on stack: as of &lt;code&gt;gcc 4.6&lt;/code&gt;, there is an option &lt;code&gt;-fstack-usage&lt;/code&gt; to allow
us check the function max amount of stack use. &lt;a href="https://gcc.gnu.org/onlinedocs/gnat_ugn/Static-Stack-Usage-Analysis.html&amp;gt;"&gt;Read more info here&lt;/a&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;numCalls.c:17:1:Fib     48      static
numCalls.c:27:1:main    64      static
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;As you can see, &lt;code&gt;Fib&lt;/code&gt; only uses &lt;code&gt;48 bytes&lt;/code&gt; and it's quite unlikely to drain out our stack space. 
But, of course, the runing time is another thing. I mean it's going to be very slow to get the output
for &lt;span class="math"&gt;\(N = 50\)&lt;/span&gt;.&lt;/p&gt;
&lt;h2 id="future-work"&gt;Future work&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="http://vulms.vu.edu.pk/Courses/CS201/Downloads/p60-robertson.pdf"&gt;This paper&lt;/a&gt; mentions that 
  \ref{eq:1} and \ref{eq:2} with their initial conditions respectively form second-order 
  Discrete Dynamical System (DDS). This offers some more mathematical insights. This actually reminds
  me equation 1.11 in &lt;em&gt;Concrete Mathematics: A Foundation for Computer Science&lt;/em&gt; working on 
  a generalized Josephus problem recurrence relation with a system of three equations and three unknown
  constant coefficients. In fact, this way of solving problem seems anywhere like differential equations,
  calculating moments in statistics, and so on. Quite interesting.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Lots of things can be said about call stack. In addition, "determine the amount of stack a program uses" is an interesting
  question that I may dig in the future.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['CommonHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' }, Macros: {} }," +
        "    jax: ['input/TeX','input/MathML','output/CommonHTML']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Zeyuan Hu</dc:creator><pubDate>Sun, 22 Jan 2017 23:12:00 +0800</pubDate><guid isPermaLink="false">tag:zhu45.org,2017-01-22:posts/2017/Jan/22/num-of-function-calls-in-recursive-fibonacci-routine/</guid><category>math</category><category>call-stack</category><category>recursion</category><category>maw</category></item><item><title>Typecasting in C</title><link>http://zhu45.org/posts/2017/Jan/19/typecasting-in-c/</link><description>&lt;p&gt;This post covers the typecasting in C with the aim to get a clear understanding
of the most commonly-seen C manipulation. This writeup is adapted from
&amp;quot;Hacking - the Art of Exploitation&amp;quot;.&lt;/p&gt;
&lt;div class="section" id="tl-dr"&gt;
&lt;h2&gt;TL;DR&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Typecasting change a variable into a different type just for that operation.&lt;/li&gt;
&lt;li&gt;Pointer type determines the size of the data it points to. In other words, when you
do pointer arithemetic (i.e &lt;tt class="docutils literal"&gt;+&lt;/tt&gt;), the number of bytes change (i.e increase) in terms of memory
address is determined by the pointer type.&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;void&lt;/tt&gt; pointer is a generic pointer and we need to cast them to the proper data type in order to
de-reference it.&lt;/li&gt;
&lt;li&gt;Pointer is merely a memory address. With typecasting, any type with enough size to hold
the memory address can work like a pointer.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="details"&gt;
&lt;h2&gt;Details&lt;/h2&gt;
&lt;p&gt;Typecasting is simply a way to temporarily change a variable's data type,
despite how it was originally define. When a variable is typecast into a different type,
the compiler is basically told to treat that variable as if it were the new data type,
but &lt;em&gt;only for that operation&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Typecasting is mostly used with pointers. Before we jump into typecasting, let's take a look
why we need to define type for pointer (pointer is just a memory address). One reason for this
is to try to limit programming errors. An integer pointer should only point to integer data, while
a character pointer should only point to character data. Another reason is for pointer arithmetic.
An integer is four bytes in size, while a character only takes up a single byte.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;char_array&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;a&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;b&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;c&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;d&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;e&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;int_array&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;

  &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;char_pointer&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;int_pointer&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="n"&gt;char_pointer&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;char_array&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;int_pointer&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;int_array&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;[integer pointer] points to %p, which contains the integer %d&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;int_pointer&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;int_pointer&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;

  &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;[char pointer] points to %p, which contains the char &amp;#39;%c&amp;#39;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;char_pointer&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;char_pointer&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The program itself is pretty straightforward. Here is the output:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
[integer pointer] points to 0x7ffd90db45a4, which contains the integer 1
[integer pointer] points to 0x7ffd90db45a8, which contains the integer 2
[integer pointer] points to 0x7ffd90db45ac, which contains the integer 3
[integer pointer] points to 0x7ffd90db45b0, which contains the integer 4
[integer pointer] points to 0x7ffd90db45b4, which contains the integer 5
[char pointer] points to 0x7ffd90db45c1, which contains the char 'a'
[char pointer] points to 0x7ffd90db45c2, which contains the char 'b'
[char pointer] points to 0x7ffd90db45c3, which contains the char 'c'
[char pointer] points to 0x7ffd90db45c4, which contains the char 'd'
[char pointer] points to 0x7ffd90db45c5, which contains the char 'e'
&lt;/pre&gt;
&lt;p&gt;Even though the same value of 1 is added to &lt;tt class="docutils literal"&gt;int_pointer&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;char_pointer&lt;/tt&gt;
in their respective loops, the compiler increments the pointer's addresses by different
amounts. Since a char is only 1 byte, the pointer to the next char would naturally also be 1 byte over.
But since an integer is 4 bytes, a pointer to the next integer has to be 4 bytes over.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;char_array&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;a&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;b&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;c&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;d&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;e&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;int_array&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;

  &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;char_pointer&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;int_pointer&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="c1"&gt;// The char_pointer and int_pointer now point to incompatible data types.&lt;/span&gt;
  &lt;span class="n"&gt;char_pointer&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;int_array&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;int_pointer&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;char_array&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;[integer pointer] points to %p, which contains the integer %c&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;int_pointer&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;int_pointer&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;

  &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;[char pointer] points to %p, which contains the char &amp;#39;%d&amp;#39;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;char_pointer&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;char_pointer&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The output is:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ gcc pointer_types2.c
pointer_types2.c: In function main:
pointer_types2.c:13: warning: assignment from incompatible pointer type
pointer_types2.c:14: warning: assignment from incompatible pointer type
&lt;/pre&gt;
&lt;p&gt;Here, the compiler and the programmer are the only ones that care about a pointer's type.
In the compiled code, a pointer is nothing more than a memory address, so the compiler
will still compile the code if a pointer points to an incompatible data type - it simply warns us
to anticipate unexpected results.:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
[integer pointer] points to 0x7ffe2d481324, which contains the integer a
[integer pointer] points to 0x7ffe2d481328, which contains the integer e
[integer pointer] points to 0x7ffe2d48132c, which contains the integer 
[integer pointer] points to 0x7ffe2d481330, which contains the integer
[integer pointer] points to 0x7ffe2d481334, which contains the integer
[char pointer] points to 0x7ffe2d481301, which contains the char '1'
[char pointer] points to 0x7ffe2d481302, which contains the char '0'
[char pointer] points to 0x7ffe2d481303, which contains the char '0'
[char pointer] points to 0x7ffe2d481304, which contains the char '0'
[char pointer] points to 0x7ffe2d481305, which contains the char '2'
&lt;/pre&gt;
&lt;p&gt;Even though &lt;tt class="docutils literal"&gt;int_pointer&lt;/tt&gt; points to character data that only contains 5 bytes of data, it is still
typed as an integer. This means that adding 1 to the pointer will increment the address by 4 each time.
Similarly, the &lt;tt class="docutils literal"&gt;char_pointer&lt;/tt&gt;'s address is only incremented by 1 each time, stepping through the 20 bytes
of integer data, one byte at a time. So, we need to make sure that pointer type is correct. This is the place where
we need typecasting.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;char_array&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;a&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;b&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;c&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;d&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;e&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;int_array&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;

  &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;char_pointer&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;int_pointer&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="n"&gt;char_pointer&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;int_array&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;int_pointer&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;char_array&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;[integer  pointer] points to %p, which contains the integer %c&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;int_pointer&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;int_pointer&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;int_pointer&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)((&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;int_pointer&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;

  &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;[char pointer] points to %p, which contains the char &amp;#39;%d&amp;#39;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;char_pointer&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;char_pointer&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;char_pointer&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)((&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;char_pointer&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Typecasting is just a way to change the type of a variable on the fly. In the above code, when the pointers
are initially set, the data is typecast into the pointer's data type. This will prevent the C compiler from complaining
about the conflicting data types; however, any pointer arithmetic will still be incorrect (because typecasting is just
for that one operation). To fix that, when 1 is added to the pointers, they must first be typecast into the correct data type
so the address is incremented by the correct amount. Then this pointer needs to be typecast back into the pointer's data type
once again. It works but in a not beautiful way.:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
[integer pointer] points to 0x7ffd484ac470, which contains the integer a
[integer pointer] points to 0x7ffd484ac471, which contains the integer b
[integer pointer] points to 0x7ffd484ac472, which contains the integer c
[integer pointer] points to 0x7ffd484ac473, which contains the integer d
[integer pointer] points to 0x7ffd484ac474, which contains the integer e
[char pointer] points to 0x7ffd484ac450, which contains the char '1'
[char pointer] points to 0x7ffd484ac454, which contains the char '2'
[char pointer] points to 0x7ffd484ac458, which contains the char '3'
[char pointer] points to 0x7ffd484ac45c, which contains the char '4'
[char pointer] points to 0x7ffd484ac460, which contains the char '5'
&lt;/pre&gt;
&lt;p&gt;Sometimes, we probably want to use a generic, typeless pointer. In C, a void pointer is a typeless pointer, defined by the &lt;tt class="docutils literal"&gt;void&lt;/tt&gt; keyword.
Here are two things we need to note:&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;pointers cannot be de-referenced unless they have a type. In order to retrieve the value stored in the pointer's memory address, the
compiler must first know what type of data it is.&lt;/li&gt;
&lt;li&gt;void pointers must also be typecast before doing pointer arithmetic, which indicates that a void pointer's main purpose is to simply hold a
memory address.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;Let's rewrite our program.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;char_array&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;a&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;b&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;c&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;d&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;e&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;int_array&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;

  &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;void_pointer&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="n"&gt;void_pointer&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;char_array&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;[char pointer] points to %p, which contains the char %c&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;void_pointer&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;void_pointer&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
    &lt;span class="n"&gt;void_pointer&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)((&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;void_pointer&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;

  &lt;span class="n"&gt;void_pointer&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;int_array&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;[integer pointer] points to %p, which contains the integer %d&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;void_pointer&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;void_pointer&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
    &lt;span class="n"&gt;void_pointer&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)((&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;void_pointer&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The output is:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
[char pointer] points to 0x7fff06cf8de0, which contains the char a
[char pointer] points to 0x7fff06cf8de1, which contains the char b
[char pointer] points to 0x7fff06cf8de2, which contains the char c
[char pointer] points to 0x7fff06cf8de3, which contains the char d
[char pointer] points to 0x7fff06cf8de4, which contains the char e
[integer pointer] points to 0x7fff06cf8dc0, which contains the integer 1
[integer pointer] points to 0x7fff06cf8dc4, which contains the integer 2
[integer pointer] points to 0x7fff06cf8dc8, which contains the integer 3
[integer pointer] points to 0x7fff06cf8dcc, which contains the integer 4
[integer pointer] points to 0x7fff06cf8dd0, which contains the integer 5
&lt;/pre&gt;
&lt;p&gt;The void pointer is really just holding the memory addresses, while the hard-coded typecasting
is telling the compiler to use the proper types whenever the pointer is used. Since the type is
taken care of by the typecasts, the void pointer is truly nothin more than a memory address.
With the data types defined by typecasting, anything that is big enough to hold a four-byte or eight-byte value can
work the same way as a void pointer.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;char_array&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;a&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;b&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;c&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;d&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;e&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;int_array&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;

  &lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;hacky_nonpointer&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="n"&gt;hacky_nonpointer&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;char_array&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;[hacky_nonpointer] points to %p, which contains the char %c&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;hacky_nonpointer&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;hacky_nonpointer&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
    &lt;span class="n"&gt;hacky_nonpointer&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;hacky_nonpointer&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;

  &lt;span class="n"&gt;hacky_nonpointer&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;int_array&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;[hacky_nonpointer] points to %p, which contains the integer %d&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;hacky_nonpointer&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;hacky_nonpointer&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
    &lt;span class="n"&gt;hacky_nonpointer&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;hacky_nonpointer&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note that I use &lt;tt class="docutils literal"&gt;unsigned long int&lt;/tt&gt; because I'm on a 64-bit system. &lt;tt class="docutils literal"&gt;unsigned int&lt;/tt&gt; is enough for 32-bit system.:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
[hacky_nonpointer] points to 0x7fff3e378360, which contains the char a
[hacky_nonpointer] points to 0x7fff3e378361, which contains the char b
[hacky_nonpointer] points to 0x7fff3e378362, which contains the char c
[hacky_nonpointer] points to 0x7fff3e378363, which contains the char d
[hacky_nonpointer] points to 0x7fff3e378364, which contains the char e
[hacky_nonpointer] points to 0x7fff3e378340, which contains the integer 1
[hacky_nonpointer] points to 0x7fff3e378344, which contains the integer 2
[hacky_nonpointer] points to 0x7fff3e378348, which contains the integer 3
[hacky_nonpointer] points to 0x7fff3e37834c, which contains the integer 4
[hacky_nonpointer] points to 0x7fff3e378350, which contains the integer 5
&lt;/pre&gt;
&lt;p&gt;The important thing to remember about variables in C is that the compiler is the
only thing that care about a variable's type. In the end, after the program has been compiled,
the variables are nothing more than memory addresses. This means that variables of one type can easily be coerced into
behaving like another type by telling the compiler to typecast them into the desired type.&lt;/p&gt;
&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Zeyuan Hu</dc:creator><pubDate>Thu, 19 Jan 2017 00:53:00 +0800</pubDate><guid isPermaLink="false">tag:zhu45.org,2017-01-19:posts/2017/Jan/19/typecasting-in-c/</guid><category>c</category><category>pointer</category></item><item><title>Difference between i++ and ++i</title><link>http://zhu45.org/posts/2017/Jan/11/difference-between-i-and-i/</link><description>&lt;p&gt;I'm starting to read through &lt;a class="reference external" href="https://www.amazon.com/Hacking-Art-Exploitation-Jon-Erickson/dp/1593271441"&gt;Hacking: The Art of Exploitation&lt;/a&gt; on
my four hours daily commute to work in order to get myself more comfortable working with C. I resolve a puzzle I have about C, as shown in the title.&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;i++&lt;/tt&gt; means increment the value of &lt;tt class="docutils literal"&gt;i&lt;/tt&gt; by &lt;tt class="docutils literal"&gt;1&lt;/tt&gt; &lt;em&gt;after&lt;/em&gt; evaluating the arithmetic operation.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;b&lt;/tt&gt; will contain &lt;tt class="docutils literal"&gt;30&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;a&lt;/tt&gt; will contain &lt;tt class="docutils literal"&gt;6&lt;/tt&gt;, since the shorthand of &lt;tt class="docutils literal"&gt;b = a++ * 6&lt;/tt&gt;;
is the equivalent to the following statements:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;++i&lt;/tt&gt; means increment the value of &lt;tt class="docutils literal"&gt;i&lt;/tt&gt; by &lt;tt class="docutils literal"&gt;1&lt;/tt&gt; &lt;em&gt;before&lt;/em&gt; evaluating the arithmetic operation.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;b&lt;/tt&gt; will contain &lt;tt class="docutils literal"&gt;36&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;a&lt;/tt&gt; wil contain &lt;tt class="docutils literal"&gt;6&lt;/tt&gt;, since the shorthand of &lt;tt class="docutils literal"&gt;b = ++a * 6&lt;/tt&gt;; is the
equivalent to the following statement:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In fact, the two principles mentioned above apply more than &amp;quot;evaluating the arithmetic operation&amp;quot;.
For example, in the stack &lt;tt class="docutils literal"&gt;push&lt;/tt&gt; operation:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cm"&gt;/* Push an element on the Stack&lt;/span&gt;
&lt;span class="cm"&gt; */&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt;
&lt;span class="nf"&gt;push&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ET&lt;/span&gt; &lt;span class="n"&gt;elem&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Stack&lt;/span&gt; &lt;span class="n"&gt;S&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;isFull&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;S&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;resizeStack&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;S&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="n"&gt;S&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Array&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;S&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;TopOfStack&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;elem&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;we can do &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;S-&amp;gt;Array[++S-&amp;gt;TopOfStack]&lt;/span&gt; = elem;&lt;/tt&gt;, which is equivalent with the following, a nice short verison:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;S&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Array&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;S&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;TopOfStack&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;elem&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;S&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;TopOfStack&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;S&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;TopOfStack&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Another example is stack &lt;tt class="docutils literal"&gt;topAndPop&lt;/tt&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cm"&gt;/* Check the top element and pop it out of Stack&lt;/span&gt;
&lt;span class="cm"&gt; */&lt;/span&gt;
&lt;span class="n"&gt;ET&lt;/span&gt;
&lt;span class="nf"&gt;topAndPop&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Stack&lt;/span&gt; &lt;span class="n"&gt;S&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;S&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Array&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;S&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;TopOfStack&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In this case, we essentially do:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;ET&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;S&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Array&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;S&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;TopOfStack&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="n"&gt;S&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;TopOfStack&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;S&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;TopOfStack&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Look how clean I can make my code is if I can understand the difference between &lt;tt class="docutils literal"&gt;++i&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;i++&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;--- 01/19/2017 UPDATE ---&lt;/p&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;++i&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;i++&lt;/tt&gt; is really a powerful technique to shorten the C code. However, it can be error-prune
if we are not careful enough.&lt;/p&gt;
&lt;p&gt;Let's take a look at the following code snippet, which is adapted from the program on K &amp;amp; R p.117.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[])&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;argc&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*++&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;)[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;-&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;*++&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
      &lt;span class="k"&gt;switch&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;x&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
          &lt;span class="n"&gt;printf&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;user invokes the program with -x option&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
          &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;n&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
          &lt;span class="n"&gt;printf&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;user invokes the program with -n option&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
          &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;default&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
          &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;illegal option %c&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
          &lt;span class="n"&gt;argc&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
          &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
      &lt;span class="p"&gt;}&lt;/span&gt;
   &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;argc&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
     &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Usage: find -x pattern&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This program itself is straightforward. Let's take a look at &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;(*++argv)[0]&lt;/span&gt;&lt;/tt&gt; to see what it means.
Since &lt;tt class="docutils literal"&gt;argv&lt;/tt&gt; is a pointer to the beginning of the array of argument strings, incrementing it by
&lt;tt class="docutils literal"&gt;1&lt;/tt&gt; (i.e. &lt;tt class="docutils literal"&gt;++argv&lt;/tt&gt;) makes it point at the original &lt;tt class="docutils literal"&gt;argv[1]&lt;/tt&gt; instead of &lt;tt class="docutils literal"&gt;argv[0]&lt;/tt&gt;. Then we
dereference it to get the value of the argument string that we are currently looking at (i.e
&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;*++argv&lt;/span&gt;&lt;/tt&gt;). Now, we get its first character by adding &lt;tt class="docutils literal"&gt;[0]&lt;/tt&gt;. So, we have &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;(*++argv)[0]&lt;/span&gt;&lt;/tt&gt;.
For example, we run our program with &lt;tt class="docutils literal"&gt;a.out &lt;span class="pre"&gt;-x&lt;/span&gt; &lt;span class="pre"&gt;-n&lt;/span&gt; pattern&lt;/tt&gt;. Then our &lt;tt class="docutils literal"&gt;argv&lt;/tt&gt; looks like
&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;{&amp;quot;-x&amp;quot;,&lt;/span&gt; &lt;span class="pre"&gt;&amp;quot;-n&amp;quot;,&lt;/span&gt; &amp;quot;pattern&amp;quot;}&lt;/tt&gt;. Then &lt;tt class="docutils literal"&gt;argv[0]&lt;/tt&gt; is &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;&amp;quot;-x&amp;quot;&lt;/span&gt;&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;argv[1]&lt;/tt&gt; is &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;&amp;quot;-n&amp;quot;&lt;/span&gt;&lt;/tt&gt;, and so on.&lt;/p&gt;
&lt;p&gt;The reason we need parenthesis in &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;(*++argv)[0]&lt;/span&gt;&lt;/tt&gt; can be seen in the next line &lt;tt class="docutils literal"&gt;c = &lt;span class="pre"&gt;*++argv[0]&lt;/span&gt;&lt;/tt&gt;.
Since &lt;tt class="docutils literal"&gt;[]&lt;/tt&gt; binds tighter than &lt;tt class="docutils literal"&gt;*&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;++&lt;/tt&gt;, then &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;*++argv[0]&lt;/span&gt;&lt;/tt&gt; is equivalent with
&lt;tt class="docutils literal"&gt;c = &lt;span class="pre"&gt;*++(argv[0])&lt;/span&gt;&lt;/tt&gt;. &lt;tt class="docutils literal"&gt;argv[0]&lt;/tt&gt; points to the first char of the argument string that &lt;tt class="docutils literal"&gt;argv&lt;/tt&gt; pointing
at. Then we increment and dereference &lt;tt class="docutils literal"&gt;argv[0]&lt;/tt&gt; to get the next character in the argument string.
For instance, suppose &lt;tt class="docutils literal"&gt;argv&lt;/tt&gt; pointing at &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-x&lt;/span&gt;&lt;/tt&gt;. Then &lt;tt class="docutils literal"&gt;argv[0]&lt;/tt&gt; pointing at &lt;tt class="docutils literal"&gt;-&lt;/tt&gt; and we increment and
dereference &lt;tt class="docutils literal"&gt;argv[0]&lt;/tt&gt; to get &lt;tt class="docutils literal"&gt;x&lt;/tt&gt; and assign to &lt;tt class="docutils literal"&gt;c&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;We can see that the level of precedence of operators is crtical in this case. This can be seen from table on
p.53. in K &amp;amp; R:&lt;/p&gt;
&lt;img alt="" src="/images/precedence-operators-c.PNG" /&gt;
&lt;p&gt;Let's see another example from K &amp;amp; R p. 105.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;strcpy&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;\0&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In this case, the value of &lt;tt class="docutils literal"&gt;*t++&lt;/tt&gt; is the character that &lt;tt class="docutils literal"&gt;t&lt;/tt&gt; pointed to before &lt;tt class="docutils literal"&gt;t&lt;/tt&gt; was incremented; the
postfix &lt;tt class="docutils literal"&gt;++&lt;/tt&gt; doesn't change &lt;tt class="docutils literal"&gt;t&lt;/tt&gt; until after this character has been fetched. This makes sense if we
consider it from precedence of the operators' view. &lt;tt class="docutils literal"&gt;*&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;++&lt;/tt&gt; have the same precedence in our table. Thus,
we evaluate the expression in ordinary order: from left to right. We first evaluate &lt;tt class="docutils literal"&gt;*s&lt;/tt&gt; then we increment &lt;tt class="docutils literal"&gt;s&lt;/tt&gt;.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Zeyuan Hu</dc:creator><pubDate>Wed, 11 Jan 2017 22:39:00 +0800</pubDate><guid isPermaLink="false">tag:zhu45.org,2017-01-11:posts/2017/Jan/11/difference-between-i-and-i/</guid><category>c</category></item><item><title>Modify array inside function in C</title><link>http://zhu45.org/posts/2017/Jan/08/modify-array-inside-function-in-c/</link><description>&lt;p&gt;In this post, I want to write down the lesson learned
about modifying array inside a function in C with an example
from MAW 3.15.a:&lt;/p&gt;
&lt;blockquote&gt;
Write an array implementation of self-adjusting lists.
A self-adjusting list is like a regular list, except that
all insertions are performed at the front, and when an element
is accessed by a Find, it is moved to the front of the list
without changing the relative order of the other items.&lt;/blockquote&gt;
&lt;p&gt;In general, there are two cases when we need to use functions to work with array. Let's
examine accordingly.&lt;/p&gt;
&lt;div class="section" id="modify-the-array-content"&gt;
&lt;h2&gt;Modify the array content&lt;/h2&gt;
&lt;p&gt;Let's take a look at the following sample function first:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;change&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;array address inside function: %p&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt; &lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;and in our test function we do:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;test_change&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;

  &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Before:&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="n"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;before change, test address: %p&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="n"&gt;change&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;After:&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="n"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;after change, test address: %p&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The output looks something like:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
Before:1 2 3
before change, test address: 0x7fffffffe050
array address inside function: 0x7fffffffe050
After:5 5 5
after change, test address: 0x7fffffffe050
&lt;/pre&gt;
&lt;p&gt;Let's examine our &lt;tt class="docutils literal"&gt;change&lt;/tt&gt; function under gdb.:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
p array
$1 = (int *) 0x7fffffffe050
&lt;/pre&gt;
&lt;p&gt;shows us that actually &lt;tt class="docutils literal"&gt;array&lt;/tt&gt; is a pointer to int with the address &lt;tt class="docutils literal"&gt;0x7fffffffe050&lt;/tt&gt;.:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
(gdb) p *0x7fffffffe050
$3 = 1
&lt;/pre&gt;
&lt;p&gt;If we take a look at what value hold the address, we can see that it's &lt;tt class="docutils literal"&gt;1&lt;/tt&gt;, which is the first element of
our &lt;tt class="docutils literal"&gt;int test[3]&lt;/tt&gt; array. This leads to our very first important observation:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;When pass an array to a function, it will decay to a pointer pointing to the first element of the array.
In other words, we can do &lt;tt class="docutils literal"&gt;p *array&lt;/tt&gt; in gdb and get &lt;tt class="docutils literal"&gt;1&lt;/tt&gt; as well.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Since the size of int under my system is 4 bytes (check by &lt;tt class="docutils literal"&gt;p sizeof(int)&lt;/tt&gt; in gdb), and let's examine the four conseuctive
bytes with starting address &lt;tt class="docutils literal"&gt;0x7fffffffe050&lt;/tt&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
(gdb) x/4bx array
0x7fffffffe050: 0x01    0x00    0x00    0x00
&lt;/pre&gt;
&lt;p&gt;As you can see, this is integer &lt;tt class="docutils literal"&gt;1&lt;/tt&gt;. Now, let's start with the first iteration of the loop in &lt;tt class="docutils literal"&gt;change&lt;/tt&gt;. Once we finish the
iteration, &lt;tt class="docutils literal"&gt;i&lt;/tt&gt; becomes &lt;tt class="docutils literal"&gt;1&lt;/tt&gt; and let's see what change to our &lt;tt class="docutils literal"&gt;array&lt;/tt&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
(gdb) p array[0]
$12 = 5

(gdb) p array
$13 = (int *) 0x7fffffffe050

(gdb) p *0x7fffffffe050
$10 = 5

(gdb) x/4bx array
0x7fffffffe050: 0x05    0x00    0x00    0x00
&lt;/pre&gt;
&lt;p&gt;We can see that the first element of our &lt;tt class="docutils literal"&gt;test&lt;/tt&gt; array becomes &lt;tt class="docutils literal"&gt;5&lt;/tt&gt; and the starting address of our
&lt;tt class="docutils literal"&gt;array&lt;/tt&gt; is still &lt;tt class="docutils literal"&gt;0x7fffffffe050&lt;/tt&gt;. In other words, the only thing changed is the value that
address &lt;tt class="docutils literal"&gt;0x7fffffffe050&lt;/tt&gt; holds. In addition, if you take a look at the array address output, you can see
that before the function call, during the function call, and after the function call, the array address
doesn't change at all: &lt;tt class="docutils literal"&gt;0x7fffffffe050&lt;/tt&gt;. This leads to our second observation:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p class="first"&gt;We can change the &lt;strong&gt;contents&lt;/strong&gt; of array in the caller function (i.e. &lt;tt class="docutils literal"&gt;test_change()&lt;/tt&gt;) through callee function (i.e. &lt;tt class="docutils literal"&gt;change&lt;/tt&gt;)
by passing the the value of array to the function (i.e. &lt;tt class="docutils literal"&gt;int *array&lt;/tt&gt;). This modification can be effective in the
caller function without any &lt;tt class="docutils literal"&gt;return&lt;/tt&gt; statement.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;However, doing so, we doesn't change the address of the array. It seems that array is a local variable inside both caller function
and callee function. Its address is copied and passed from &lt;tt class="docutils literal"&gt;test_change&lt;/tt&gt; to &lt;tt class="docutils literal"&gt;change&lt;/tt&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
Inside change:

                 +---+---+--+
array -----&amp;gt;  -&amp;gt; | 1 | 2 | 3|
             /-&amp;gt; +---+---+--+
test --------
&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Let's verify above observation with another function &lt;tt class="docutils literal"&gt;change2&lt;/tt&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;change2&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;array address inside function: %p&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
  &lt;span class="n"&gt;array&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;With the similar test program &lt;tt class="docutils literal"&gt;test_change2()&lt;/tt&gt; we get the following output:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
TEST: change2
Before:1 2 3
before change, test address: 0x7ffda5b41bc0
array address inside function: 0x7ffda5b41bc0
After:1 2 3
after change, test address: 0x7ffda5b41bc0
&lt;/pre&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;change2&lt;/tt&gt; is very tempting because we assign &lt;tt class="docutils literal"&gt;array&lt;/tt&gt; points to &lt;tt class="docutils literal"&gt;tmp&lt;/tt&gt;, which let &lt;tt class="docutils literal"&gt;test&lt;/tt&gt; inside &lt;tt class="docutils literal"&gt;test_change2&lt;/tt&gt; points to &lt;tt class="docutils literal"&gt;tmp&lt;/tt&gt; as well. However, this is wrong and
the output confirms our observation above: array is local variable to the caller function and callee function, and when we pass a array into a function, the address is
passed (copied) from caller to callee. After that, address inside callee can reassign and will have no effect on the array (address) in caller. In other words, even though
the address inside &lt;tt class="docutils literal"&gt;change2&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;test_change2&lt;/tt&gt; are the same, but they are independent with each other:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
after change2:

                 +---+---+--+
test  ---------&amp;gt; | 1 | 2 | 3|
                 +---+---+--+

                 +---+---+--+
tmp   -----&amp;gt;  -&amp;gt; | 5 | 5 | 5|
             /-&amp;gt; +---+---+--+
array -------
&lt;/pre&gt;
&lt;p&gt;What if we want to modify &lt;tt class="docutils literal"&gt;test&lt;/tt&gt; itself inside &lt;tt class="docutils literal"&gt;test_change2&lt;/tt&gt; beyond the content of the array. What if we want to resize the array to make it hold more values?&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="modify-the-array-itself"&gt;
&lt;h2&gt;Modify the array itself&lt;/h2&gt;
&lt;p&gt;Before we start to answer the above question. Let me clear out an important concept: &amp;quot;array on stack&amp;quot; and &amp;quot;array on heap&amp;quot;.&lt;/p&gt;
&lt;p&gt;&amp;quot;array on Stack&amp;quot; with the declaration looks like &lt;tt class="docutils literal"&gt;int test[3] = {1,2,3}&lt;/tt&gt; in our test routines. The array declared like this stays on the stack and local to the
function calls. &amp;quot;array on heap&amp;quot; is the dynamic array involving &lt;tt class="docutils literal"&gt;malloc&lt;/tt&gt;, which I mention in the &lt;a class="reference external" href="http://zhu45.org/posts/2017/Jan/06/josephus-problem-radix-sort-reflection/"&gt;previous post&lt;/a&gt;. When we talk about
resize the array, we mean the latter case. In other words, we can only change the array itself (number of elements) with dynamically allocated array in the heap.&lt;/p&gt;
&lt;p&gt;Let's take a look at &lt;tt class="docutils literal"&gt;change3&lt;/tt&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;
&lt;span class="nf"&gt;change3&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;tmp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;calloc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="n"&gt;free&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;and our corresponding test routine &lt;tt class="docutils literal"&gt;test_change3()&lt;/tt&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;test_change3&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;TEST: change3&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;test&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;calloc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
  &lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Before:&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="n"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;before change, test address: %p&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="n"&gt;change3&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;After:&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="n"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;after change, test address: %p&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The first task is to understand &lt;tt class="docutils literal"&gt;int **array&lt;/tt&gt;. There is a template sentence when comes to C type declaration: &amp;quot;&amp;lt;VariableName&amp;gt; is ... &amp;lt;typeName&amp;gt;&amp;quot;. In our case,
The template sentence becomes &amp;quot;array is ... int&amp;quot;. Now let's work out the &amp;quot;...&amp;quot; with &amp;quot;right-left&amp;quot; rule:&lt;/p&gt;
&lt;blockquote&gt;
&amp;quot;go right when you can, go left when you must&amp;quot;&lt;/blockquote&gt;
&lt;p&gt;In our case, we start with &amp;quot;array&amp;quot; and go right, and nothing left with declaraiton. So, we must go left. the first symbol is &lt;tt class="docutils literal"&gt;*&lt;/tt&gt;, which reads as &amp;quot;pointer to&amp;quot;.
So now our template sentence becomes &amp;quot;array is pointer to ... int&amp;quot;. Great! Let's continue to go left, we see another &lt;tt class="docutils literal"&gt;*&lt;/tt&gt;, which makes our sentence becomes
&amp;quot;array is pointer to pointer to ... int&amp;quot;. Then we meet &lt;tt class="docutils literal"&gt;int&lt;/tt&gt;, which means all the symbol in the declaration is consumed and our sentence is complete:
&amp;quot;array is pointer to pointer to int&amp;quot;. This means &lt;tt class="docutils literal"&gt;array&lt;/tt&gt; variable itself is a pointer containing an address of a pointer, which holds an address of a int.&lt;/p&gt;
&lt;p&gt;Let's see if this is true with gdb.:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
(gdb) p array
$1 = (int **) 0x7fffffffe070

(gdb) p/a *0x7fffffffe070
$8 = 0x601010

(gdb) p *0x601010
$7 = 1

(gdb) p *array
$2 = (int *) 0x601010

(gdb) p **array
$3 = 1
&lt;/pre&gt;
&lt;p&gt;The address holds by &lt;tt class="docutils literal"&gt;array&lt;/tt&gt; is &lt;tt class="docutils literal"&gt;0x7fffffffe070&lt;/tt&gt;. We further examine the value holds by &lt;tt class="docutils literal"&gt;0x7fffffffe070&lt;/tt&gt; and by our assumption, it should be another address
and it is: &lt;tt class="docutils literal"&gt;0x601010&lt;/tt&gt;. Then, we check the value hold by that address, which is expected &lt;tt class="docutils literal"&gt;1&lt;/tt&gt; the first element of our &lt;tt class="docutils literal"&gt;test&lt;/tt&gt; array.&lt;/p&gt;
&lt;p&gt;Our goal is to let &lt;tt class="docutils literal"&gt;test&lt;/tt&gt; array in &lt;tt class="docutils literal"&gt;test_change3()&lt;/tt&gt; be &lt;tt class="docutils literal"&gt;5,5,5&lt;/tt&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
Before change3

                 +---+---+--+
test  ---------&amp;gt; | 1 | 2 | 3|
                 +---+---+--+

                 +---+---+--+
tmp   ---------&amp;gt; | 5 | 5 | 5|
                 +---+---+--+


After change3

                       +---+---+--+
tmp   ---------------&amp;gt; | 5 | 5 | 5|
                   /-&amp;gt; +---+---+--+
test(array) -------
&lt;/pre&gt;
&lt;p&gt;From the picture we can see that we want to modify &lt;tt class="docutils literal"&gt;array&lt;/tt&gt; inside &lt;tt class="docutils literal"&gt;change3&lt;/tt&gt; pointing to &lt;tt class="docutils literal"&gt;5,5,5&lt;/tt&gt; and this change will persist to the &lt;tt class="docutils literal"&gt;test&lt;/tt&gt; array in our caller function.
In other words, we want both &lt;tt class="docutils literal"&gt;test&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;array&lt;/tt&gt; no longer independent but want them &amp;quot;tie up&amp;quot; as the same pointer with different names. How do we do that?&lt;/p&gt;
&lt;p&gt;The solution is given by &lt;tt class="docutils literal"&gt;change3&lt;/tt&gt; but we really need to think about why it makes sense. Firstly, we want to use gdb to examine the address
of key variables:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
(gdb) p array
$4 = (int **) 0x7fffffffe070
(gdb) p *array
$5 = (int *) 0x601010
(gdb) p (*array)+1
$14 = (int *) 0x601014
(gdb) p (*array)+2
$15 = (int *) 0x601018
(gdb) p *(*array)
$18 = 1
(gdb) p *(*array)+1
$16 = 2
(gdb) p *(*array)+2
$17 = 3

(gdb) p tmp
$7 = (int *) 0x601030
(gdb) p tmp+1
$8 = (int *) 0x601034
(gdb) p tmp+2
$9 = (int *) 0x601038
(gdb) p *tmp
$10 = 5
(gdb) p *(tmp+1)
$11 = 5
(gdb) p *(tmp+2)
$12 = 5
&lt;/pre&gt;
&lt;p&gt;We first print out the &lt;tt class="docutils literal"&gt;array&lt;/tt&gt; address of each element and we print out the &lt;tt class="docutils literal"&gt;tmp&lt;/tt&gt; address of each element.
With the information above, let's compose our conceptual picture:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
Before *array = tmp;

   4 bytes                                         4 bytes
+-----------+-----------+----------+------------+-----------+----------+--------+-------+----------+------
|  1        | 2         | 3        |   ...      |    5      |     5    |  5     |  ...  | 0x601010 | ...
+-----------+-----------+----------+------------+-----------+----------+--------+-------+----------+------
^           ^           ^                       ^           ^          ^                ^
0x601010   0x601014     0x601018                0x601030    0x601034   0x601048         0x7fffffffe070
                                                tmp                                     array
&lt;/pre&gt;
&lt;p&gt;Now, let's execute &lt;tt class="docutils literal"&gt;*array = tmp&lt;/tt&gt;, we get the following:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
(gdb) p *array
$19 = (int *) 0x601010
(gdb) p *array
$20 = (int *) 0x601030
&lt;/pre&gt;
&lt;p&gt;Now the picture looks like:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
After *array = tmp;

   4 bytes                                         4 bytes
+-----------+-----------+----------+------------+-----------+----------+--------+-------+----------+------
|  1        | 2         | 3        |   ...      |    5      |     5    |  5     |  ...  | 0x601030 | ...
+-----------+-----------+----------+------------+-----------+----------+--------+-------+----------+------
^           ^           ^                       ^           ^          ^                ^
0x601010   0x601014     0x601018               0x601030    0x601034   0x601048        0x7fffffffe070
                                               tmp                                    array
&lt;/pre&gt;
&lt;p&gt;We don't modify the address of the &lt;tt class="docutils literal"&gt;array&lt;/tt&gt; itself (still &lt;tt class="docutils literal"&gt;0x7fffffffe070&lt;/tt&gt;) but the content that stored at &lt;tt class="docutils literal"&gt;0x7fffffffe070&lt;/tt&gt;
which is no longer &lt;tt class="docutils literal"&gt;0x601010&lt;/tt&gt; but &lt;tt class="docutils literal"&gt;0x601030&lt;/tt&gt;, which is the starting address of the &lt;tt class="docutils literal"&gt;tmp&lt;/tt&gt;: &lt;tt class="docutils literal"&gt;5,5,5&lt;/tt&gt;.
This may seem like magic. However, in C, a variable (i.e. &lt;tt class="docutils literal"&gt;test&lt;/tt&gt; in &lt;tt class="docutils literal"&gt;test_change3()&lt;/tt&gt;) is merely a synonym for address.
by invoking &lt;tt class="docutils literal"&gt;change3&lt;/tt&gt; through &lt;tt class="docutils literal"&gt;&amp;amp;test&lt;/tt&gt;, we pass in the address &lt;tt class="docutils literal"&gt;0x601010&lt;/tt&gt; via a carrier &lt;tt class="docutils literal"&gt;0x7fffffffe070&lt;/tt&gt;, and we modify the
address to &lt;tt class="docutils literal"&gt;0x601030&lt;/tt&gt; and send the address back again through carrier.&lt;/p&gt;
&lt;p&gt;With this understanding, we can see why the output looks like:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
TEST: change3
Before:1 2 3
before change, test address: 0x601010
After:5 5 5
after change, test address: 0x601030
&lt;/pre&gt;
&lt;p&gt;Hoepfully, after our examination, we can understand &lt;tt class="docutils literal"&gt;arrayInsert&lt;/tt&gt; for MAW 3.15.a proposed at the beginning of the post:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;
&lt;span class="nf"&gt;arrayInsert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;elem&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;**&lt;/span&gt; &lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;realloc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="p"&gt;)[&lt;/span&gt;&lt;span class="n"&gt;length&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="p"&gt;)[&lt;/span&gt;&lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;elem&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a class="reference external" href="https://github.com/xxks-kkk/Code-for-blog/blob/master/2017/array-to-function/array-to-function.c"&gt;Get the complete source code&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="reference"&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;If you would like to read more about decoding C type declarations. You can read more here:&lt;ul&gt;
&lt;li&gt;&lt;a class="reference external" href="http://unixwiz.net/techtips/reading-cdecl.html"&gt;Reading C type declarations&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://ieng9.ucsd.edu/~cs30x/rt_lt.rule.html"&gt;Right-left rule to understand C type declaration&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Chapter 3 in &amp;quot;Expert C Programming&amp;quot; by Peter Van Der Linden&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;!-- http://stackoverflow.com/questions/34844003/changing-array-inside-function-in-c --&gt;
&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Zeyuan Hu</dc:creator><pubDate>Sun, 08 Jan 2017 09:23:00 +0800</pubDate><guid isPermaLink="false">tag:zhu45.org,2017-01-08:posts/2017/Jan/08/modify-array-inside-function-in-c/</guid><category>c</category></item><item><title>Josephus Problem &amp; Radix Sort Reflection</title><link>http://zhu45.org/posts/2017/Jan/06/josephus-problem-radix-sort-reflection/</link><description>&lt;p&gt;This post is a reflection on the two problems (MAW 3.13 &amp;amp; 3.10) I
have been working on for the past five days.&lt;/p&gt;
&lt;div class="section" id="dynamic-arrays-in-c"&gt;
&lt;h2&gt;Dynamic arrays in C&lt;/h2&gt;
&lt;p&gt;One of the ways I try out to solve &lt;a class="reference external" href="http://zhu45.org/posts/2016/Dec/31/josephus-problem/"&gt;Josephus Problem&lt;/a&gt; is to use circular double linked list, which
is implemented in &lt;a class="reference external" href="https://github.com/xxks-kkk/algo/blob/master/linkedList/josephus/circularLinkedList.c"&gt;ET circularDoubleLinkedListJosephus(ET N, ET M)&lt;/a&gt;,
Inside the function, here is what I try to do initially:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;ET&lt;/span&gt; &lt;span class="n"&gt;people&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;people&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;I try to make an array of consecutive numbers based upon the input &lt;tt class="docutils literal"&gt;N&lt;/tt&gt;. However, this way doesn't work in C because compiler has no clue
the size of array during compilation phase. This is what people called dynamic array in C. The following two pages offer execellent explanations
to dynamic array specific and array in C in general:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.mathcs.emory.edu/~cheung/Courses/255/Syllabus/2-C-adv-data/dyn-array.html"&gt;Dynamic arrays in C&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.cs.swarthmore.edu/~newhall/unixhelp/C_arrays.html"&gt;Arrays in C&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Here is what I've done eventually:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;people&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;calloc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;

&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;people&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;There is one thing to note about &lt;tt class="docutils literal"&gt;calloc&lt;/tt&gt;. It essentially the same as &lt;tt class="docutils literal"&gt;malloc&lt;/tt&gt; in terms of allocating a chunk of
array. However, unlike &lt;tt class="docutils literal"&gt;malloc&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;calloc&lt;/tt&gt; will zero-initlize the chunk, which is quite useful when we work with
array of integers. In other words, &lt;tt class="docutils literal"&gt;people = &lt;span class="pre"&gt;malloc(N*sizeof(int));&lt;/span&gt;&lt;/tt&gt; is perfectly fine in this case but &lt;tt class="docutils literal"&gt;calloc&lt;/tt&gt;
gives an advantage to have more control on array content, especially useful when we debug.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="circularly-linked-lists"&gt;
&lt;h2&gt;Circularly Linked Lists&lt;/h2&gt;
&lt;p&gt;In MAW, author is kind of in-rush when talks about this section. When comes to implementation, how we deal with header node
need to carefully think through. This is what stated in the book:&lt;/p&gt;
&lt;blockquote&gt;
A popular convention is to have the last cell keep a pointer back to the first. This can be done with or without
a header (if the header is present, the last cell points to it) and can also be done with doubly linked lists (the
first cell's previous pointer points to the last cell).&lt;/blockquote&gt;
&lt;p&gt;Here is my circularly double linked list in picture:&lt;/p&gt;
&lt;img alt="" src="/images/circularly-double-linked-list-dummy.PNG" /&gt;
&lt;p&gt;In words, our dummy node's &lt;tt class="docutils literal"&gt;Next&lt;/tt&gt; points to the the first data node and &lt;tt class="docutils literal"&gt;Prev&lt;/tt&gt; points to the last data node.
With this setup, the head of the list can be accessed by &lt;tt class="docutils literal"&gt;dummy.Next&lt;/tt&gt; and tail by &lt;tt class="docutils literal"&gt;dummy.Prev&lt;/tt&gt;. In addition,
there will never be &lt;tt class="docutils literal"&gt;NULL&lt;/tt&gt; pointers in the data structure.&lt;/p&gt;
&lt;!-- http://www.cs.uwm.edu/~cs351/linked-list-variations.pdf --&gt;
&lt;/div&gt;
&lt;div class="section" id="initialize-an-array-of-structs"&gt;
&lt;h2&gt;Initialize an array of structs&lt;/h2&gt;
&lt;p&gt;When implement the radix sort solution, I need to construct an array of buckets,
with each bucket is a single linked list with a dummy node. Here is what I do:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="n"&gt;List&lt;/span&gt;
&lt;span class="nf"&gt;makeEmptyArrayOfNodes&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;numBuckets&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;Pos&lt;/span&gt; &lt;span class="n"&gt;Buckets&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;malloc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;numBuckets&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;

  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;numBuckets&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;Buckets&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;Next&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;

  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;Buckets&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Here are two points worth noting:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p class="first"&gt;&lt;tt class="docutils literal"&gt;Pos&lt;/tt&gt; is &lt;tt class="docutils literal"&gt;struct Node*&lt;/tt&gt; (can be checked by &lt;tt class="docutils literal"&gt;ptype&lt;/tt&gt; in GDB) when we allocate
an array of &lt;tt class="docutils literal"&gt;struct Node&lt;/tt&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;There is difference between &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-&amp;gt;&lt;/span&gt;&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;.&lt;/tt&gt;. In K&amp;amp;R Page 131, it says that:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;If &lt;tt class="docutils literal"&gt;p&lt;/tt&gt; is a &lt;strong&gt;POINTER&lt;/strong&gt; to a structure, then &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;p-&amp;gt;member-of-structure&lt;/span&gt;&lt;/tt&gt;
refers to the particular member.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;and &lt;tt class="docutils literal"&gt;.&lt;/tt&gt; is used to directly access a structure member.
In my case, since &lt;tt class="docutils literal"&gt;Buckets[k]&lt;/tt&gt; with type &lt;tt class="docutils literal"&gt;struct Node&lt;/tt&gt;, then I need to use &lt;tt class="docutils literal"&gt;.&lt;/tt&gt;.
However, if I want to use &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-&amp;gt;&lt;/span&gt;&lt;/tt&gt;, I need to use &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;(&amp;amp;Buckets[k])-&amp;gt;Next&lt;/span&gt;&lt;/tt&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- http://stackoverflow.com/questions/4173518/c-initialize-array-of-structs --&gt;
&lt;/div&gt;
&lt;div class="section" id="for-loop-instead-of-while"&gt;
&lt;h2&gt;For loop instead of while&lt;/h2&gt;
&lt;p&gt;I try to experiment different trick when I work on my algo. Here is what I try: use &lt;tt class="docutils literal"&gt;for&lt;/tt&gt; loop instead
of &lt;tt class="docutils literal"&gt;while&lt;/tt&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;deleteNode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ET&lt;/span&gt; &lt;span class="n"&gt;elem&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;List&lt;/span&gt; &lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;Pos&lt;/span&gt; &lt;span class="n"&gt;dummyL&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Next&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;Pos&lt;/span&gt; &lt;span class="n"&gt;dummyPrev&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(;&lt;/span&gt; &lt;span class="n"&gt;dummyL&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;dummyPrev&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;dummyL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;dummyL&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;dummyL&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Next&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dummyL&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Element&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;elem&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="n"&gt;Pos&lt;/span&gt; &lt;span class="n"&gt;tmp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;dummyL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
      &lt;span class="n"&gt;dummyPrev&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Next&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;dummyL&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Next&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
      &lt;span class="n"&gt;free&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
      &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;!-- https://www.cs.bu.edu/teaching/ --&gt;
&lt;/div&gt;
&lt;div class="section" id="use-system-implementation-if-find-otherwise-use-my-own-version"&gt;
&lt;h2&gt;Use system implementation if find, otherwise use my own version&lt;/h2&gt;
&lt;p&gt;I'm trying to use &lt;tt class="docutils literal"&gt;fls&lt;/tt&gt; inside &lt;a class="reference external" href="https://github.com/xxks-kkk/algo/blob/77a66a5e911252a93e44bfb6d9bc4c62d85cdffc/linkedList/josephus/nonLinkedListSol.c"&gt;int cyclicShiftJosephus(int N, int M)&lt;/a&gt;,
which return the last (most significant) bit set in value and return the index of that bit.
However, not all system has &lt;tt class="docutils literal"&gt;fls&lt;/tt&gt; shipped by default. So, I implement my own version. But, I would prefer
the program to use system version if it can find one. Otherwise, use mine.&lt;/p&gt;
&lt;p&gt;One solution is to use &lt;tt class="docutils literal"&gt;#ifndef&lt;/tt&gt; with the structure looks like&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#ifndef fls&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;fls&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;mask&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="cp"&gt;#endi&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Another solution is to use &lt;a class="reference external" href="https://en.wikipedia.org/wiki/Weak_symbol"&gt;weak symbol&lt;/a&gt;. However, this solution may not be portable.
Then, it looks something like this&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="nf"&gt;__attribute__&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;weak&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="n"&gt;fls&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;mask&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt; &lt;span class="p"&gt;..&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;If system &lt;tt class="docutils literal"&gt;fls&lt;/tt&gt; is defined as strong, my &lt;tt class="docutils literal"&gt;fls&lt;/tt&gt; implementation will be overridden.&lt;/p&gt;
&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Zeyuan Hu</dc:creator><pubDate>Fri, 06 Jan 2017 00:34:00 +0800</pubDate><guid isPermaLink="false">tag:zhu45.org,2017-01-06:posts/2017/Jan/06/josephus-problem-radix-sort-reflection/</guid><category>c</category><category>double-linked-list</category></item><item><title>Josephus Problem</title><link>http://zhu45.org/posts/2016/Dec/31/josephus-problem/</link><description>&lt;h2 id="preface"&gt;Preface&lt;/h2&gt;
&lt;p&gt;This is actually MAW 3.10. I gradually realize how dense MAW is.
In the &lt;a href="http://zhu45.org/posts/2016/Dec/26/reflection-on-integer-arithmetic-package-problem/"&gt;previous problem&lt;/a&gt;,
I write almost 500 lines of code. For this one, the problem is not really diffcult to solve if we implement a program 
that follows the game rule exactly. However, I figure it is a good chance to dig a little deeper to learn somewhat
fully from the question.&lt;/p&gt;
&lt;p&gt;Let's start to dive in.&lt;/p&gt;
&lt;h2 id="overview"&gt;Overview&lt;/h2&gt;
&lt;p&gt;I first describe the &lt;em&gt;Josephus problem&lt;/em&gt; in general. Then, I present a closed form solution to 
solve a special case of the original problem.
Afterwards, I present a recurrence solution to solve the general problem. &lt;/p&gt;
&lt;h2 id="josephus-problem"&gt;Josephus problem&lt;/h2&gt;
&lt;p&gt;The &lt;em&gt;Josephus problem&lt;/em&gt; is the following game: &lt;span class="math"&gt;\(N\)&lt;/span&gt; people, numbered &lt;span class="math"&gt;\(1\)&lt;/span&gt; to &lt;span class="math"&gt;\(N\)&lt;/span&gt;, are
sitting in a circle. Starting at person 1, a hot potato is passed. the &lt;span class="math"&gt;\(M\)&lt;/span&gt;th person 
holding the hot potato is eliminated, the circle closes ranks, and the
game continues with the person who was sitting after the eliminated person picking
up the hot potato. The last remaining person wins. Thus, if &lt;span class="math"&gt;\(M = 1\)&lt;/span&gt; and &lt;span class="math"&gt;\(N = 5\)&lt;/span&gt;, players
are eliminated in order, and player 5 wins. If &lt;span class="math"&gt;\(M = 2\)&lt;/span&gt; and &lt;span class="math"&gt;\(N = 5\)&lt;/span&gt;, the order of elimination
is &lt;span class="math"&gt;\(2\)&lt;/span&gt;,&lt;span class="math"&gt;\(4\)&lt;/span&gt;,&lt;span class="math"&gt;\(1\)&lt;/span&gt;,&lt;span class="math"&gt;\(5\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;You can play with different &lt;span class="math"&gt;\(M\)&lt;/span&gt;, &lt;span class="math"&gt;\(N\)&lt;/span&gt; on this &lt;a href="http://webspace.ship.edu/deensley/mathdl/Joseph.html"&gt;site&lt;/a&gt; to get a better sense of the problem.&lt;/p&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;MAW uses a problem description that is slight different than the problem description usually find online. In the book, he defines &lt;span class="math"&gt;\(M\)&lt;/span&gt; in term of number of passes. However, in our problem description, we use &lt;span class="math"&gt;\(M\)&lt;/span&gt; to indicate the &lt;span class="math"&gt;\(M\)&lt;/span&gt;th person get
eliminated. Here is an example to show the difference.In MAW description, &lt;span class="math"&gt;\(M = 0\)&lt;/span&gt; and &lt;span class="math"&gt;\(N = 5\)&lt;/span&gt;, players are eliminated in 
order. However, in our own intepretation, &lt;span class="math"&gt;\(M\)&lt;/span&gt; should be &lt;span class="math"&gt;\(1\)&lt;/span&gt; in order to achieve the same elimination order. Similarly, in 
the book, &lt;span class="math"&gt;\(M = 1\)&lt;/span&gt; when we have &lt;span class="math"&gt;\(2\)&lt;/span&gt;, &lt;span class="math"&gt;\(4\)&lt;/span&gt;, &lt;span class="math"&gt;\(1\)&lt;/span&gt;, &lt;span class="math"&gt;\(5\)&lt;/span&gt; elimination order for the second example.  Mathematically, 
&lt;span class="math"&gt;\(M_{new} = M_{MAW} + 1\)&lt;/span&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;h2 id="josephus-problem-with-m-2"&gt;Josephus problem with &lt;span class="math"&gt;\(M = 2\)&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;Let's first discuss a special case of the Josephus Problem: &lt;span class="math"&gt;\(M = 2\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;In the following, &lt;span class="math"&gt;\(n\)&lt;/span&gt; denotes the number of 
people in the initial circle, and &lt;span class="math"&gt;\(m\)&lt;/span&gt; denotes the count for each step. In other words, &lt;span class="math"&gt;\(m-1\)&lt;/span&gt; people
are skipped and the &lt;span class="math"&gt;\(m\)&lt;/span&gt;-th is eliminated. The people in the circle are numbered from &lt;span class="math"&gt;\(1\)&lt;/span&gt; to &lt;span class="math"&gt;\(n\)&lt;/span&gt;. Our goal
is to find &lt;span class="math"&gt;\(J(n,m)\)&lt;/span&gt;, which denotes the survivor's number (i.e. &lt;span class="math"&gt;\(J(5,1) = 3\)&lt;/span&gt;). For simplicity, let &lt;span class="math"&gt;\(F(n) = J(n,2)\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://zhu45.org/images/josephus-1.png" /&gt; &lt;/p&gt;
&lt;p&gt;One quick observation is that after the first go-round, we are left with the same problem but for a different
number of people. For instance, when &lt;span class="math"&gt;\(n = 10\)&lt;/span&gt;, after the first go-round, we eliminate &lt;span class="math"&gt;\(2\)&lt;/span&gt;, &lt;span class="math"&gt;\(4\)&lt;/span&gt;, &lt;span class="math"&gt;\(6\)&lt;/span&gt;, &lt;span class="math"&gt;\(8\)&lt;/span&gt;, &lt;span class="math"&gt;\(10\)&lt;/span&gt;
and then we go to the second-round beginning with &lt;span class="math"&gt;\(3\)&lt;/span&gt;, which is the same problem as the original one. 
The only difference is that the person with number &lt;span class="math"&gt;\(3\)&lt;/span&gt; in the first-round now becomes number &lt;span class="math"&gt;\(2\)&lt;/span&gt; in the second-round.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Case 1: When &lt;span class="math"&gt;\(n\)&lt;/span&gt; is even ...&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Let &lt;span class="math"&gt;\(n = 2k\)&lt;/span&gt;. After the first-round we are left with &lt;span class="math"&gt;\(k\)&lt;/span&gt; people, and we try to find out what is &lt;span class="math"&gt;\(F(k)\)&lt;/span&gt;. In addition, by
our observation, the numbering of people is changed. If &lt;span class="math"&gt;\(3\)&lt;/span&gt; is actually the answer (i.e. &lt;span class="math"&gt;\(F(2k) = 3\)&lt;/span&gt;), then in the second-round
the original person with &lt;span class="math"&gt;\(3\)&lt;/span&gt; now becomes &lt;span class="math"&gt;\(2\)&lt;/span&gt; (i.e. &lt;span class="math"&gt;\(F(k) = 2\)&lt;/span&gt;). So, we have&lt;/p&gt;
&lt;div class="math"&gt;$$
\begin{equation}
F(2k) = 2F(k) - 1, \text{ for } k &amp;gt;= 1 \label{eq:1}
\end{equation}
$$&lt;/div&gt;
&lt;p&gt;&lt;em&gt;Case 2: When &lt;span class="math"&gt;\(n\)&lt;/span&gt; is odd ...&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Let &lt;span class="math"&gt;\(n = 2k+1\)&lt;/span&gt;. By the same reasoning as case 1, after the first-round, we still eliminate &lt;span class="math"&gt;\(k\)&lt;/span&gt; people. For instance, when &lt;span class="math"&gt;\(n = 9\)&lt;/span&gt;,
after the first-round, we elminate &lt;span class="math"&gt;\(2\)&lt;/span&gt;, &lt;span class="math"&gt;\(4\)&lt;/span&gt;, &lt;span class="math"&gt;\(6\)&lt;/span&gt;, &lt;span class="math"&gt;\(8\)&lt;/span&gt;, &lt;span class="math"&gt;\(1\)&lt;/span&gt;. In other words, &lt;span class="math"&gt;\(1\)&lt;/span&gt; is eliminate just after person number &lt;span class="math"&gt;\(2k\)&lt;/span&gt;. So, we 
have&lt;/p&gt;
&lt;div class="math"&gt;$$
\begin{equation}
F(2k+1) = 2F(k) + 1, \text{ for } k &amp;gt;= 1\label{eq:2}
\end{equation}
$$&lt;/div&gt;
&lt;p&gt;So now our goal is to solve the recurrence equations \ref{eq:1} and \ref{eq:2} given &lt;span class="math"&gt;\(F(1) = 1\)&lt;/span&gt; to find a closed form. Let's do
this by building a table of small values:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;| n    | 1 | 2   3 | 4   5   6   7 | 8   9   10   11   12   13   14   15 | 16 |
|------|---|-------|---------------|-------------------------------------|----|
| F(n) | 1 | 1   3 | 1   3   5   7 | 1   3   5    7    9    11   13   15 | 1  |
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;We can group the columns by powers of &lt;span class="math"&gt;\(2\)&lt;/span&gt; (marked by vertical lines in the table); Inside each group,
&lt;span class="math"&gt;\(F(n)\)&lt;/span&gt; is always &lt;span class="math"&gt;\(1\)&lt;/span&gt; at the beginning and then it increases by &lt;span class="math"&gt;\(2\)&lt;/span&gt; until the next group, which is 
the next power of &lt;span class="math"&gt;\(2\)&lt;/span&gt;. So, for every number &lt;span class="math"&gt;\(n\)&lt;/span&gt;, there exists an integer &lt;span class="math"&gt;\(a\)&lt;/span&gt; such that &lt;span class="math"&gt;\(2^a &amp;lt;= n &amp;lt; 2^{a+1}\)&lt;/span&gt;.
For some &lt;span class="math"&gt;\(0 &amp;lt;= l &amp;lt;= 2^a\)&lt;/span&gt;, then &lt;span class="math"&gt;\(n = 2^a + l\)&lt;/span&gt;. In other words, &lt;span class="math"&gt;\(2^a\)&lt;/span&gt; is the largest power of 2 not exceeding &lt;span class="math"&gt;\(n\)&lt;/span&gt;
and &lt;span class="math"&gt;\(l\)&lt;/span&gt; is what's left. Then, from the table above, we may have the formula:&lt;/p&gt;
&lt;div class="math"&gt;$$
\begin{equation}
F(n) = F(2^a + l) = 2l + 1 \label{eq:3}
\end{equation}
$$&lt;/div&gt;
&lt;p&gt;Now, let's prove equation \ref{eq:3} by induction on &lt;span class="math"&gt;\(a\)&lt;/span&gt;.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;Base case.&lt;/em&gt; When &lt;span class="math"&gt;\(a = 0\)&lt;/span&gt;, we must have &lt;span class="math"&gt;\(l = 1\)&lt;/span&gt;; thus we have &lt;span class="math"&gt;\(F(1) = 1\)&lt;/span&gt;, which is true.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;Induction.&lt;/em&gt; We use &lt;a href="https://en.wikipedia.org/wiki/Mathematical_induction#Complete_induction"&gt;strong induction&lt;/a&gt; by
assuming that the equation holds for all &lt;span class="math"&gt;\(a\)&lt;/span&gt; up to certain value. Let's consider this value of &lt;span class="math"&gt;\(a\)&lt;/span&gt;. The induction 
steps has two parts, depending on whether &lt;span class="math"&gt;\(n\)&lt;/span&gt; (and thus &lt;span class="math"&gt;\(l\)&lt;/span&gt;) is even or odd.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;If &lt;span class="math"&gt;\(2^a + l = 2k\)&lt;/span&gt;, then&lt;/p&gt;
&lt;p&gt;
&lt;div class="math"&gt;$$
\begin{align*}
F(2^a + l) &amp;amp;= 2F(2^{a-1} + l/2) - 1 &amp;amp;&amp;amp;\text{(by equation 1)} \\
        &amp;amp;= 2(2l/2 + 1) - 1      &amp;amp;&amp;amp;\text{(by induction hypothesis)} \\
        &amp;amp;= 2l + 1
\end{align*}
$$&lt;/div&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;If &lt;span class="math"&gt;\(2^a + l = 2k+1\)&lt;/span&gt;, then&lt;/p&gt;
&lt;p&gt;
&lt;div class="math"&gt;$$
\begin{align*}
F(2^a + l) &amp;amp;= 2F(2^{a-1} + (l-1)/2) + 1 &amp;amp;&amp;amp;\text{(by equation 2)} \\
        &amp;amp;= 2(2(l-1)/2 + 1) + 1      &amp;amp;&amp;amp;\text{(by induction hypothesis)} \\
        &amp;amp;= 2l + 1
\end{align*}
$$&lt;/div&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This completes induction step.&lt;/p&gt;
&lt;p&gt;Let's revisit our closed form solution \ref{eq:3} again. Let's rewrite it into the form:&lt;/p&gt;
&lt;div class="math"&gt;$$F(n) = 2 (n - 2^a) + 1$$&lt;/div&gt;
&lt;p&gt;&lt;span class="math"&gt;\(n - 2^a\)&lt;/span&gt; is the same as zeroing the most significant bit of &lt;span class="math"&gt;\(n\)&lt;/span&gt;. Then, we multiply the result
with &lt;span class="math"&gt;\(2\)&lt;/span&gt;, which is the same as shifting left one place, and adding &lt;span class="math"&gt;\(1\)&lt;/span&gt; is the same as setting the lowest
bit to &lt;span class="math"&gt;\(1\)&lt;/span&gt;. In other words, equation \ref{eq:3} is essentially do a one-bit cyclic shift left. Let's try to write this 
out formally. Let &lt;span class="math"&gt;\(n = (b_ab_{a-1}..b_1b_0)_2\)&lt;/span&gt;, then we have:&lt;/p&gt;
&lt;div class="math"&gt;$$ F(n) = F((b_ab_{a-1}..b_1b_0)_2) = (b_{a-1}...b_1b_0b_a)_2 \text{ and } b_a = 1$$&lt;/div&gt;
&lt;p&gt;For a more rigorous derivation of this cyclic shift property, please reference &lt;em&gt;Concrete Mathematics: A Foundation for Computer Science&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;The way we solve Josephus problem with &lt;span class="math"&gt;\(M = 2\)&lt;/span&gt; is unlikely to be generalized for arbitrary &lt;span class="math"&gt;\(m\)&lt;/span&gt;. Let's take &lt;span class="math"&gt;\(n = 10\)&lt;/span&gt;, &lt;span class="math"&gt;\(m = 2\)&lt;/span&gt; example again. The
reason we can derive the nice recurrence equations \ref{eq:1} and \ref{eq:2} is because our observation. Let's present our
observation is a different way. &lt;span class="math"&gt;\(F(2k)\)&lt;/span&gt; denotes the old numbering before the first-round. &lt;span class="math"&gt;\(F(k)\)&lt;/span&gt; denotes the new numbering 
after the first-round.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;      m = 2               m = 3
+-------+------+    +-------+------+
| F(2k) | F(k) |    | F(2k) | F(k) |
+-------+------+    +-------+------+
| 1     | 1    |    | 1     | 1    |
+-------+------+    +-------+------+
| 3     | 2    |    | 2     | 2    |
+-------+------+    +-------+------+
| 5     | 3    |    | 4     | 3    |
+-------+------+    +-------+------+
| 7     | 4    |    | 5     | 4    |
+-------+------+    +-------+------+
| 9     | 5    |    | 7     | 5    |
+-------+------+    +-------+------+
                    | 8     | 6    |
                    +-------+------+
                    | 10    | 7    |
                    +-------+------+
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;By looking at the table on the left, we can easily see that &lt;span class="math"&gt;\(F(2k) = 2F(k) - 1\)&lt;/span&gt;. 
However, there is no nice clean linear relation that we can get between &lt;span class="math"&gt;\(F(2k)\)&lt;/span&gt; and &lt;span class="math"&gt;\(F(k)\)&lt;/span&gt; 
when &lt;span class="math"&gt;\(n = 10\)&lt;/span&gt;, &lt;span class="math"&gt;\(m = 3\)&lt;/span&gt;.&lt;/p&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;p&gt;Inside &lt;em&gt;Concrete Mathematics: A Foundation for Computer Science&lt;/em&gt;, after talking about the
solution to the Josephus problem, the author shift their focus to solve a generalized
recurrence of \ref{eq:1} and \ref{eq:2}, which is (1.11) in the book. This has nothing to do
with the Josephus problem and I'm guessing the reason why the author want to talk about 
the solution to the generalized recurrence is to illustrate dynamic programming philosophy.&lt;/p&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;h2 id="general-solution"&gt;General solution&lt;/h2&gt;
&lt;p&gt;The big picture here is we need to find out the relative position of the final survivor to the
"first" person during each recursive call and then calculate the actual position for actual &lt;span class="math"&gt;\(n\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;The general solution utilitizes the dynamic programming paradigm by performing the first step
and using the solution of the subproblem we create to solve the initial problem. 
In terms of the solution, there is a difference when we start with the first person as &lt;span class="math"&gt;\(1\)&lt;/span&gt; or &lt;span class="math"&gt;\(0\)&lt;/span&gt;.&lt;/p&gt;
&lt;h3 id="starting-from-1"&gt;Starting from 1&lt;/h3&gt;
&lt;p&gt;The key insight is the following: the result of &lt;span class="math"&gt;\(J(n,m)\)&lt;/span&gt; is best NOT thought of as the &lt;em&gt;number&lt;/em&gt; that is the 
Josephus survivor, but rather as the &lt;em&gt;index&lt;/em&gt; of the number that is the Josephus survivor. &lt;/p&gt;
&lt;p&gt;Let's first take a look an example when &lt;span class="math"&gt;\(n = 6\)&lt;/span&gt; and &lt;span class="math"&gt;\(m = 2\)&lt;/span&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;fig.1

  1 2      1 X      1 X      1 X      1 X      X X
 6   3 -&amp;gt; 6   3 -&amp;gt; 6   3 -&amp;gt; X   3 -&amp;gt; X   X -&amp;gt; X   X
  5 4      5 4      5 X      5 X      5 X      5 X

fig.2

| index | 1 | 2 | 3 | 4 | 5 | 6 |
|-------|---|---|---|---|---|---|
| n = 6 | 1 | 2 | 3 | 4 | 5 | 6 | J(6,2) = 5
| n = 5 | 3 | 4 | 5 | 6 | 1 | 3 | J(5,2) = 3
| n = 4 | 5 | 6 | 1 | 3 | 5 | 6 | J(4,2) = 1
| n = 3 | 1 | 3 | 5 | 1 | 3 | 5 | J(3,2) = 3
| n = 2 | 5 | 1 | 5 | 1 | 5 | 1 | J(2,2) = 1
| n = 1 | 5 | 5 | 5 | 5 | 5 | 5 | J(1,2) = 1

fig.3

| index | 1 | 2 | 3 | 4 | 5 | 6 |
|-------|---|---|---|---|---|---|
| n = 6 | 1 | X | 3 | 4 | 5 | 6 | J(6,2) = 5 = (2-1 + 3) mod 6 + 1
| n = 5 | 3 | X | 5 | 6 | 1 | 3 | J(5,2) = 3 = (2-1 + 1) mod 5 + 1
| n = 4 | 5 | X | 1 | 3 | 5 | X | J(4,2) = 1 = (2-1 + 3) mod 4 + 1
| n = 3 | 1 | X | 5 | 1 | X | 5 | J(3,2) = 3 = (2-1 + 1) mod 3 + 1
| n = 2 | 5 | X | 5 | X | 5 | X | J(2,2) = 1 = (2-1 + 1) mod 2 + 1
| n = 1 | 5 | 5 | 5 | 5 | 5 | 5 | J(1,2) = 1
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;By looking at fig.1, we know that &lt;span class="math"&gt;\(J(6,2) = 5\)&lt;/span&gt;. Now, if we take a look at fig.2, the row with &lt;span class="math"&gt;\(n = 5% shows that $J(5,2) = 3\)&lt;/span&gt;. By the insight,
&lt;span class="math"&gt;\(3\)&lt;/span&gt; here means the &lt;em&gt;index&lt;/em&gt; not the &lt;em&gt;number&lt;/em&gt;. So, our final survivor is &lt;span class="math"&gt;\(5\)&lt;/span&gt;, which is positioned on &lt;span class="math"&gt;\(3\)&lt;/span&gt; in this row.&lt;/p&gt;
&lt;p&gt;Let's generalize the example a little bit. Suppose we want to know &lt;span class="math"&gt;\(J(n,2)\)&lt;/span&gt;. You can imagine 
we have &lt;span class="math"&gt;\(n\)&lt;/span&gt; people lined up like this: &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;1 2 3 4 5 ... n
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The first thing that happens is that person &lt;span class="math"&gt;\(2\)&lt;/span&gt; get eliminated, as shown here:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;1 X 3 4 5 ... n
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Now, we are left with a subproblem of the following form: there are &lt;span class="math"&gt;\(n - 1\)&lt;/span&gt; people remaining, every other
person is going to be eliminated, and the first person who will start to pass potato is person &lt;span class="math"&gt;\(3\)&lt;/span&gt;. In other 
words, the subproblem &lt;span class="math"&gt;\(J(n-1, 2)\)&lt;/span&gt; now looks like:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;3 4 5 ... n 1
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;span class="math"&gt;\(J(n-1, 2)\)&lt;/span&gt; will be the &lt;em&gt;index&lt;/em&gt; of who survives in a line of &lt;span class="math"&gt;\(n - 1\)&lt;/span&gt; of people. Given that we have the &lt;em&gt;index&lt;/em&gt;
of the person who will survive, and we also know who the starting person is, we can determine which person 
will be left. Here's how we'll do it.&lt;/p&gt;
&lt;p&gt;The starting person in this line is the person who comes right after the person who was last executed. This will 
be person &lt;span class="math"&gt;\(3\)&lt;/span&gt;. The 1-indexed position in the ring of &lt;span class="math"&gt;\(n-1\)&lt;/span&gt; people is given by &lt;span class="math"&gt;\(J(n-1, 2)\)&lt;/span&gt;. We can then walk 
forward &lt;span class="math"&gt;\(J(n-1, 2)\)&lt;/span&gt; positions, wrapping around the ring if necessary, to get our final position. In other words, the 
survivor is given by position&lt;/p&gt;
&lt;div class="math"&gt;$$
\begin{equation}
(3 + J(n-1, 2) - 1) \bmod n \label{eq:4}
\end{equation}
$$&lt;/div&gt;
&lt;p&gt;Let's take a look at &lt;span class="math"&gt;\(n = 5\)&lt;/span&gt; in fig.2 again. Now, the starting position is &lt;span class="math"&gt;\(3\)&lt;/span&gt; and we walk forward by &lt;span class="math"&gt;\(J(5,2) - 1\)&lt;/span&gt; steps (i.e. &lt;span class="math"&gt;\(2\)&lt;/span&gt; steps) 
and we get the final survivor, which is &lt;span class="math"&gt;\(5\)&lt;/span&gt;. The reason we doing &lt;span class="math"&gt;\(\bmod n\)&lt;/span&gt; is because we want to keep final survivor within the bounds of the circle.&lt;/p&gt;
&lt;p&gt;However, there is a problem with our equation \ref{eq:4}. If we are indeed using one-indexing, what happens if the final survivor is at position &lt;span class="math"&gt;\(n\)&lt;/span&gt;?
In that case, we would accidentally get back position &lt;span class="math"&gt;\(0\)&lt;/span&gt; as our answer, but we really want position &lt;span class="math"&gt;\(n\)&lt;/span&gt;. For example, suppose &lt;span class="math"&gt;\(J(5,2) = 4\)&lt;/span&gt;. In other words,
the final survivor is &lt;span class="math"&gt;\(6\)&lt;/span&gt;, which is positioned at &lt;span class="math"&gt;\(4\)&lt;/span&gt; when &lt;span class="math"&gt;\(n = 5\)&lt;/span&gt;. Then, to apply equation \ref{eq:4}, we get &lt;span class="math"&gt;\(0\)&lt;/span&gt;, which is not &lt;span class="math"&gt;\(6\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;To fix this issue, we'll use a trick for using mod to wrap around with one-indexing: we'll take the inside quantity (the one-indexed position) and 
subtract one to get the zero-indexed position. We'll mod that quantity by &lt;span class="math"&gt;\(n\)&lt;/span&gt; to get the zero-indexed position wrapped around. Finally, we'll add 
back one to get the one-indexed position, wrapped around. That looks like:&lt;/p&gt;
&lt;div class="math"&gt;$$(3 + J(n-1, 2) - 2) \bmod n + 1$$&lt;/div&gt;
&lt;p&gt;In other words, &lt;span class="math"&gt;\(-2\)&lt;/span&gt; term comes from two independent &lt;span class="math"&gt;\(-1\)&lt;/span&gt;'s: the first &lt;span class="math"&gt;\(-1\)&lt;/span&gt; is because &lt;span class="math"&gt;\(J(n-1, 2)\)&lt;/span&gt; returns a one-indexed index, so to step forward by
the right number of positions we have to take &lt;span class="math"&gt;\(J(n-1,2) - 1\)&lt;/span&gt; steps forward. The second &lt;span class="math"&gt;\(-1\)&lt;/span&gt; comes from the fact that we're using one-indexing rather than
zero-indexing.&lt;/p&gt;
&lt;p&gt;Now, we're finally ready to generalize the solution to arbitrary &lt;span class="math"&gt;\(m\)&lt;/span&gt;, not just &lt;span class="math"&gt;\(m = 2\)&lt;/span&gt;. After person &lt;span class="math"&gt;\(m\)&lt;/span&gt; get eliminated, we have an array like this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;1 2 3 ... m-1 X m+1 ... n
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;We now essentailly need to solve a subproblem where person &lt;span class="math"&gt;\(m+1\)&lt;/span&gt; comes first:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;m+1 m+2 ... n 1 2 ... m-1
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;So we compute &lt;span class="math"&gt;\(J(n-1, m)\)&lt;/span&gt; to get the one-indexed survivor of a ring of &lt;span class="math"&gt;\(n-1\)&lt;/span&gt; people, then shift forward by that many steps:&lt;/p&gt;
&lt;div class="math"&gt;$$(m+1 + J(n-1, m) - 1)$$&lt;/div&gt;
&lt;p&gt;We need to worry about the case where we wrap around, so we need to mod by &lt;span class="math"&gt;\(n\)&lt;/span&gt;:&lt;/p&gt;
&lt;div class="math"&gt;$$(m+1 + J(n-1, m) - 1) \bmod n$$&lt;/div&gt;
&lt;p&gt;However, we're one-indexed, so we need to use the trick of subtracing &lt;span class="math"&gt;\(1\)&lt;/span&gt; from the inside quantity and then adding &lt;span class="math"&gt;\(1\)&lt;/span&gt; at the end:&lt;/p&gt;
&lt;div class="math"&gt;$$(m+1 + J(n-1, m) - 2) \bmod n + 1$$&lt;/div&gt;
&lt;p&gt;which simplifies to:&lt;/p&gt;
&lt;div class="math"&gt;$$(m-1 + J(n-1, m)) \bmod n + 1$$&lt;/div&gt;
&lt;p&gt;Notice that &lt;span class="math"&gt;\(J(1,m) = 1\)&lt;/span&gt;, which indicates that we're one-indexed.&lt;/p&gt;
&lt;h3 id="starting-from-0"&gt;Starting from 0&lt;/h3&gt;
&lt;p&gt;Since we are not in zero-indexed. Our &lt;span class="math"&gt;\(J(6,2)\)&lt;/span&gt; example looks like the following:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;| index | 0 | 1 | 2 | 3 | 4 | 5 |
|-------|---|---|---|---|---|---|
| n = 6 | 1 | 2 | 3 | 4 | 5 | 6 | J(6,2) = 4 = (2 + 2 ) mod 6
| n = 5 | 3 | 4 | 5 | 6 | 1 | 3 | J(5,2) = 2 = (0 + 2 ) mod 5
| n = 4 | 5 | 6 | 1 | 3 | 5 | 6 | J(4,2) = 0 = (2 + 2 ) mod 4
| n = 3 | 1 | 3 | 5 | 1 | 3 | 5 | J(3,2) = 2 = (0 + 2 ) mod 3
| n = 2 | 5 | 1 | 5 | 1 | 5 | 1 | J(2,2) = 0 = (0 + 2 ) mod 2 
| n = 1 | 5 | 5 | 5 | 5 | 5 | 5 | J(1,2) = 0
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Let's apply the same logic from the one-indexed case. After person &lt;span class="math"&gt;\(m-1\)&lt;/span&gt; get eliminated, we have an array like this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;0 1 2 ... m-2 X m ... n-1
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;We now essentailly need to solve a subproblem where person &lt;span class="math"&gt;\(m\)&lt;/span&gt; comes first:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;m m+1 ... n-1 0 1 2 ... m-2
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;So, we compute &lt;span class="math"&gt;\(J(n-1,m)\)&lt;/span&gt; to give us the zero-indexed survivor of a ring of &lt;span class="math"&gt;\(n-1\)&lt;/span&gt; people and we shfit forward by that many steps:&lt;/p&gt;
&lt;div class="math"&gt;$$(m + J(n-1,m))$$&lt;/div&gt;
&lt;p&gt;We take care of wrapping around by mod &lt;span class="math"&gt;\(n\)&lt;/span&gt;:&lt;/p&gt;
&lt;div class="math"&gt;$$(m + J(n-1,m)) \bmod n$$&lt;/div&gt;
&lt;p&gt;Since we are zero-indexed, we are done. If we want to transform our answer to one-indexed, we can do:&lt;/p&gt;
&lt;div class="math"&gt;$$(m + J(n-1,m) \bmod n + 1$$&lt;/div&gt;
&lt;p&gt;Note that &lt;span class="math"&gt;\(J(1,m) = 0\)&lt;/span&gt; in this case, which indicates that we're zero-indexed.&lt;/p&gt;
&lt;!-- ### Implementation --&gt;

&lt;!-- There are many ways to solve this question. --&gt;

&lt;!-- *Brute force* --&gt;

&lt;!-- We can use a cricular double linked list to implement the solution. --&gt;

&lt;!-- *Recurrence* --&gt;

&lt;!-- Use the recurrence relation we just derived. --&gt;

&lt;h2 id="whats-left-out"&gt;What's left out&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://blue.butler.edu/~phenders/InRoads/MathCounts8.pdf"&gt;Equivalence Class Solution&lt;/a&gt; is interesting to check out.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.scribd.com/document/3567390/Rank-Trees"&gt;Rank tree&lt;/a&gt; as a data sturcture is worth to check out to solve this problem. &lt;a href="http://www.imt.ro/romjist/Volum12/Number12_1/pdf/02-MCosulschi.pdf"&gt;This paper&lt;/a&gt; gives a more detailed analysis.&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- ## Reference --&gt;

&lt;!-- - https://en.wikipedia.org/wiki/Josephus_problem --&gt;

&lt;!-- - Graham, R.L.; Knuth, D.E.; Patashnik, O. (1989), Concrete Mathematics: A Foundation for Computer Science, Addison Wesley, p. 8, ISBN 978-0-201-14236-5 --&gt;

&lt;!-- - http://www.cut-the-knot.org/recurrence/r_solution.shtml --&gt;

&lt;!-- - http://www.exploringbinary.com/powers-of-two-in-the-josephus-problem --&gt;

&lt;!-- - http://www.math.northwestern.edu/~mlerma/problem_solving/solutions/josephus.pdf --&gt;

&lt;!-- - http://blue.butler.edu/~phenders/InRoads/MathCounts8.pdf --&gt;

&lt;!-- - http://stackoverflow.com/questions/31775604/explanation-for-recursive-implementation-of-josephus-prob?answertab=active#tab-top --&gt;

&lt;!-- - http://stackoverflow.com/questions/21737771/can-someone-please-explain-the-use-of-modulus-in-this-code?rq=1 --&gt;

&lt;!-- - https://rosettacode.org/wiki/Josephus_problem --&gt;

&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['CommonHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' }, Macros: {} }," +
        "    jax: ['input/TeX','input/MathML','output/CommonHTML']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Zeyuan Hu</dc:creator><pubDate>Sat, 31 Dec 2016 20:24:00 +0800</pubDate><guid isPermaLink="false">tag:zhu45.org,2016-12-31:posts/2016/Dec/31/josephus-problem/</guid><category>recursion</category><category>dynamic-programming</category><category>math</category><category>maw</category></item><item><title>A peek in code optimization</title><link>http://zhu45.org/posts/2016/Dec/28/a-peek-in-code-optimization/</link><description>&lt;p&gt;Quite often, when I take a look at a programming
question solution, I'm amazed by how succint the provided
solution is. However, it is also known that getting an &amp;quot;optimized&amp;quot;
solution is often taking iterative approach. This is something
that I didn't realize until I start to work in the industry.&lt;/p&gt;
&lt;p&gt;This post is mainly a reminder to keep reminding myself about this point:
We don't have to give a perfect solution right away. We can provide a
solution and gradually make it better.&lt;/p&gt;
&lt;p&gt;The example I show here is &lt;tt class="docutils literal"&gt;integerList add(integerList A, integerList B)&lt;/tt&gt;,
which is part of &lt;a class="reference external" href="http://zhu45.org/posts/2016/Dec/26/reflection-on-integer-arithmetic-package-problem/"&gt;MAW 3.9 integer arithmetic package question&lt;/a&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;integerList&lt;/span&gt;
&lt;span class="nf"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;integerList&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;integerList&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;PtrToNode&lt;/span&gt; &lt;span class="n"&gt;dummyA&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;NextDigit&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;PtrToNode&lt;/span&gt; &lt;span class="n"&gt;dummyB&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;NextDigit&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;integerList&lt;/span&gt; &lt;span class="n"&gt;R&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;malloc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
  &lt;span class="n"&gt;PtrToNode&lt;/span&gt; &lt;span class="n"&gt;dummyR&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;R&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;digitSum&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;carry&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dummyA&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;dummyB&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;digitSum&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;dummyA&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Digit&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;dummyB&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Digit&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;carry&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;digitSum&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="n"&gt;addDigit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;digitSum&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;dummyR&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
      &lt;span class="n"&gt;carry&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="n"&gt;carry&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
      &lt;span class="n"&gt;addDigit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;digitSum&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;dummyR&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;dummyA&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;dummyA&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;NextDigit&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;dummyB&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;dummyB&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;NextDigit&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;dummyR&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;dummyR&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;NextDigit&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;

  &lt;span class="c1"&gt;// example case: 342 + 706&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;carry&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;dummyA&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;dummyB&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;addDigit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;carry&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;dummyR&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;dummyR&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;dummyR&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;NextDigit&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;

  &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dummyA&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;addDigit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dummyA&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Digit&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;carry&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;dummyR&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;carry&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;dummyA&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;dummyA&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;NextDigit&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;dummyR&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;dummyR&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;NextDigit&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;

  &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dummyB&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;addDigit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dummyB&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Digit&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;carry&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;dummyR&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;carry&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;dummyB&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;dummyB&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;NextDigit&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;dummyR&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;dummyR&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;NextDigit&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;

  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;R&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The idea for this first iteration solution stems from MAW 3.5
&lt;a class="reference external" href="https://github.com/xxks-kkk/algo/blob/master/linkedList/generic/linkedList.c"&gt;List unionSortedLists(List L, List P)&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
Given two sorted lists, L and P, write a procedure to compute L1 union L2 using
only the basic list operations.&lt;/blockquote&gt;
&lt;p&gt;Since we put the least significant digit as the very first data node and we
put the most significant digit as the last data node, we walk through the list.
If you compare this routine with &lt;tt class="docutils literal"&gt;unionSortedLists&lt;/tt&gt; routine, you can easily
find that both routine structure is composed of three while loops. This makes sense
because &lt;tt class="docutils literal"&gt;union&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;add&lt;/tt&gt; are extremely similar mathematically.&lt;/p&gt;
&lt;p&gt;First we start by adding the unit digit. If both numbers have the same number of digits,
then we are done afte the first while loop. There is a special case where we still have
a carry after we processed all the digits. If number of digits for two numbers are not the same,
then we just move extra digits to the result.&lt;/p&gt;
&lt;p&gt;Let's see how we can optimize this code.&lt;/p&gt;
&lt;p&gt;In the solution, we build the case around the number of digits that operands have.
However, this is necessary because in the case that two numbers have different number of digits,
we can add leading zeros to the beginning of the number with fewer digits. This will make
adding two numbers with different number of digits the same as adding two numbers with the same
number of digits. So, we eliminate the latter two while loops and only need to keep the first while
loop in the original solution.&lt;/p&gt;
&lt;p&gt;Here is the final result.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;integerList&lt;/span&gt;
&lt;span class="nf"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;integerList&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;integerList&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;PtrToNode&lt;/span&gt; &lt;span class="n"&gt;dummyA&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;NextDigit&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;PtrToNode&lt;/span&gt; &lt;span class="n"&gt;dummyB&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;NextDigit&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;integerList&lt;/span&gt; &lt;span class="n"&gt;R&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;makeEmpty&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
  &lt;span class="n"&gt;PtrToNode&lt;/span&gt; &lt;span class="n"&gt;dummyR&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;R&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;digitSum&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;carry&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dummyA&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="n"&gt;dummyB&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dummyA&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;?&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;dummyA&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Digit&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dummyB&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;?&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;dummyB&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Digit&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;digitSum&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;carry&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;carry&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;digitSum&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;addDigit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;digitSum&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;dummyR&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dummyA&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;dummyA&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;dummyA&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;NextDigit&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dummyB&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;dummyB&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;dummyB&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;NextDigit&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;dummyR&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;dummyR&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;NextDigit&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;

  &lt;span class="c1"&gt;// example case: 342 + 706&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;carry&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;addDigit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;carry&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;dummyR&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;dummyR&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;dummyR&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;NextDigit&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;

  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;R&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Zeyuan Hu</dc:creator><pubDate>Wed, 28 Dec 2016 13:21:00 +0800</pubDate><guid isPermaLink="false">tag:zhu45.org,2016-12-28:posts/2016/Dec/28/a-peek-in-code-optimization/</guid><category>singly-linked-list</category><category>software-engineering</category></item><item><title>Reflection on integer arithmetic package problem</title><link>http://zhu45.org/posts/2016/Dec/26/reflection-on-integer-arithmetic-package-problem/</link><description>&lt;p&gt;This weekend, I'm working on MAW 3.9. The single problem results
in almost 500 lines of code. This is quite unexpected. The problem
is stated as the following:&lt;/p&gt;
&lt;blockquote&gt;
Write an arbitrary-precision integer arithmetic package. You should
use a strategy similar to polynomial arithmetic. Compute the distribution
of the digits &lt;span class="math"&gt;\(0\)&lt;/span&gt; to &lt;span class="math"&gt;\(9\)&lt;/span&gt; in &lt;span class="math"&gt;\(2^{4000}\)&lt;/span&gt;.&lt;/blockquote&gt;
&lt;p&gt;This post is the reflection about this problem.&lt;/p&gt;
&lt;div class="section" id="which-way-to-go"&gt;
&lt;h2&gt;Which way to go?&lt;/h2&gt;
&lt;p&gt;Since the problem states &amp;quot;arbitrary-precision&amp;quot; and &amp;quot;use a strategy similar to
polynomial arithmetic&amp;quot;, then I can conclude that linked list is the best data
structure for this problem. However, the question is how we can construct the
linked list to best implement our integer arithmetic operations (i.e. addition,
mulitiplication)?&lt;/p&gt;
&lt;p&gt;We essentially have two options:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;We put the most significant digit as the the very first data node and
we put the least significant digit as the last data node. For example,
for a number &lt;span class="math"&gt;\(123\)&lt;/span&gt;, we will implement it like &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;dummy-&amp;gt;1-&amp;gt;2-&amp;gt;3&lt;/span&gt;&lt;/tt&gt;.&lt;/li&gt;
&lt;li&gt;This is the exactly opposite of the first option. We put the least significant
digit as the very first data node and we put the most significant digit as
the last data node. Again, for &lt;span class="math"&gt;\(123\)&lt;/span&gt;, we will implement is like
&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;dummy-&amp;gt;3-&amp;gt;2-&amp;gt;1&lt;/span&gt;&lt;/tt&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Let's evaluate these two options from two perspective:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;Whether we can easily construct a linked list to represent arbitrary-precision integer?&lt;/li&gt;
&lt;li&gt;Whether the arithmetic operations are essy to implement?&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;From the first perspective, for option one, each time we add a new digit to the most significant position, we insert
a new node at the very beginning of the list (i.e. right after the header node).
On the other hand, for option two, we append a new node
at the very end of the list. Since we design our &lt;tt class="docutils literal"&gt;addDigit&lt;/tt&gt; with an input of a pointer to node (i.e. to specify
where to add node), these two options work equally well.&lt;/p&gt;
&lt;p&gt;From the second perspective, things are different. Take arithmetic addition as an example. When we try to add
two numbers, for option one, we need to walk through the whole list to begin with the very end of the node
because we want to start with unit digit. This makes our routine complex because we need to use a while loop
to walk through the list first. For second option, situation is easier becauuse the number is implemented in the
reverse order in the list. The very first data node is the unit digit and we can directly start with addition
while we move towards the end of the list. If we need to add additional node because of carry (i.e. &lt;span class="math"&gt;\(999 + 1\)&lt;/span&gt;
will be no longer 3-digit but 4-digit number), we can naturally pass the pointer pointing towards the current node to
the &lt;tt class="docutils literal"&gt;addDigit&lt;/tt&gt; function.&lt;/p&gt;
&lt;p&gt;So, we choose option two to implement our integer package.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="memory-leak"&gt;
&lt;h2&gt;Memory leak&lt;/h2&gt;
&lt;p&gt;Memory leak is a very important issue to pay attention to during the testing phase. We use &lt;a class="reference external" href="http://valgrind.org/"&gt;valgrind&lt;/a&gt;
to help us detect if there is any leak in our code. You can reference &lt;a class="reference external" href="http://valgrind.org/docs/manual/quick-start.html#quick-start.intro"&gt;their quick start guide&lt;/a&gt;
and &lt;a class="reference external" href="http://valgrind.org/docs/manual/mc-manual.html#mc-manual.errormsgs"&gt;memory check user manual&lt;/a&gt; for the commands and error shooting.&lt;/p&gt;
&lt;p&gt;Here are the two mistakes I made (You can check out &lt;a class="reference external" href="https://github.com/xxks-kkk/algo/commit/299ebb9a90791612343f194d9eec1ed3909c97b3#diff-5db0d6074a742e1a08d3bb60c69e5a21"&gt;my commit about memory leak debug&lt;/a&gt;):&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;Always &lt;tt class="docutils literal"&gt;free&lt;/tt&gt; the chunk allocated by &lt;tt class="docutils literal"&gt;malloc&lt;/tt&gt; whenever possible.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Take &lt;tt class="docutils literal"&gt;multiply&lt;/tt&gt; function as an example:&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt; &lt;span class="n"&gt;integerList&lt;/span&gt;
 &lt;span class="nf"&gt;multiply&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;integerList&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;integerList&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
 &lt;span class="p"&gt;{&lt;/span&gt;
   &lt;span class="n"&gt;PtrToNode&lt;/span&gt; &lt;span class="n"&gt;dummyA&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;NextDigit&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
   &lt;span class="n"&gt;PtrToNode&lt;/span&gt; &lt;span class="n"&gt;dummyB&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;NextDigit&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

   &lt;span class="n"&gt;integerList&lt;/span&gt; &lt;span class="n"&gt;tmpR&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;makeEmpty&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
   &lt;span class="n"&gt;PtrToNode&lt;/span&gt; &lt;span class="n"&gt;dummyTmpR&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;tmpR&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

   &lt;span class="n"&gt;integerList&lt;/span&gt; &lt;span class="n"&gt;R&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;makeEmpty&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

   &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;product&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;carry&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
   &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;indent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

   &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dummyA&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
   &lt;span class="p"&gt;{&lt;/span&gt;
     &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dummyB&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
     &lt;span class="p"&gt;{&lt;/span&gt;
       &lt;span class="n"&gt;product&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;dummyA&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Digit&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;dummyB&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Digit&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;carry&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
       &lt;span class="n"&gt;carry&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;product&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
       &lt;span class="n"&gt;addDigit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;product&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;dummyTmpR&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
       &lt;span class="n"&gt;dummyTmpR&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;dummyTmpR&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;NextDigit&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
       &lt;span class="n"&gt;dummyB&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;dummyB&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;NextDigit&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
     &lt;span class="p"&gt;}&lt;/span&gt;

     &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;carry&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
     &lt;span class="p"&gt;{&lt;/span&gt;
       &lt;span class="n"&gt;addDigit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;carry&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;dummyTmpR&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
       &lt;span class="n"&gt;dummyTmpR&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;dummyTmpR&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;NextDigit&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
     &lt;span class="p"&gt;}&lt;/span&gt;

     &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;indent&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
     &lt;span class="p"&gt;{&lt;/span&gt;
       &lt;span class="n"&gt;addDigit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;tmpR&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
     &lt;span class="p"&gt;}&lt;/span&gt;

     &lt;span class="n"&gt;integerList&lt;/span&gt; &lt;span class="n"&gt;tmp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;R&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// prevent memory leak&lt;/span&gt;
     &lt;span class="n"&gt;R&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;R&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;tmpR&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
     &lt;span class="n"&gt;deleteAll&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

     &lt;span class="n"&gt;indent&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
     &lt;span class="n"&gt;carry&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
     &lt;span class="n"&gt;deleteIntegerList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tmpR&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
     &lt;span class="n"&gt;dummyTmpR&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;tmpR&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
     &lt;span class="n"&gt;dummyA&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;dummyA&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;NextDigit&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
     &lt;span class="n"&gt;dummyB&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;NextDigit&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
   &lt;span class="p"&gt;}&lt;/span&gt;

   &lt;span class="n"&gt;deleteAll&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tmpR&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
   &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;R&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
 &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;p&gt;We allocate &lt;tt class="docutils literal"&gt;tmpR&lt;/tt&gt; through &lt;tt class="docutils literal"&gt;makeEmpty()&lt;/tt&gt; in Line[7]. If we don't do anything about it
inside the function, then the memory will be lost because we have no way to reference this
chunk of memory outside the function. Local variable &lt;tt class="docutils literal"&gt;tmpR&lt;/tt&gt; is the only reference to the
memory allocated on the heap. However, once the function is done, the local variable is destroyed
from the stack, and thus, we lose our only reference to the memory chunk. So, we need to free it
before we exit the function (Line[49]).&lt;/p&gt;
&lt;ol class="arabic simple" start="2"&gt;
&lt;li&gt;Be careful with a function call inside a function call.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;This type of leak is much more subtle than the first one. Originally instead of&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;integerList&lt;/span&gt; &lt;span class="n"&gt;tmp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;R&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;R&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;R&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;tmpR&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;deleteAll&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;I only have &lt;tt class="docutils literal"&gt;R = add(R, tmpR)&lt;/tt&gt;. This cause the leak because of the following reasoning:
Originally, we have &lt;tt class="docutils literal"&gt;R&lt;/tt&gt; points to a list of nodes. When we do &lt;tt class="docutils literal"&gt;add(R,tmpR)&lt;/tt&gt;, we create
a new list of nodes, which hold our addition result. Then we let &lt;tt class="docutils literal"&gt;R&lt;/tt&gt; points towards this newly-created
list. This makes us lose the list of nodes originally pointed by &lt;tt class="docutils literal"&gt;R&lt;/tt&gt;. That's why we introduce &lt;tt class="docutils literal"&gt;tmp&lt;/tt&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="makeempty"&gt;
&lt;h2&gt;makeEmpty ?&lt;/h2&gt;
&lt;p&gt;Originally, I don't have this &lt;tt class="docutils literal"&gt;makeEmpty&lt;/tt&gt; function:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;integerList&lt;/span&gt;
&lt;span class="nf"&gt;makeEmpty&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;integerList&lt;/span&gt; &lt;span class="n"&gt;R&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;malloc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
  &lt;span class="n"&gt;R&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;NextDigit&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// super important step&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;R&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;If you take a look at this function, it seems to be a wrapper around &lt;tt class="docutils literal"&gt;malloc&lt;/tt&gt; operation, which
seems redundant (we could directly call &lt;tt class="docutils literal"&gt;malloc&lt;/tt&gt; directly in the place that &lt;tt class="docutils literal"&gt;makeEmpty&lt;/tt&gt; appears).
However, the key for this routine is &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;R-&amp;gt;NextDigit&lt;/span&gt; = NULL;&lt;/tt&gt;. This step can be easily omitted. However,
without this step, we don't have fully control on what our newly-allocated empty list (i.e. a list with only
header node) will look like. In other words, our header node will point to somewhere (i.e. &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;R-&amp;gt;NextDigit&lt;/span&gt;&lt;/tt&gt;) randomly without
our key step. This can cause serious trouble for the following routine debug. For example, we could have &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;R-&amp;gt;NextDigit&lt;/span&gt;&lt;/tt&gt;
holds some address value that happens to have a node structure there with a value in it. For instance, &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;dummy-&amp;gt;1&lt;/span&gt;&lt;/tt&gt;.
This can usually happen when you OS try to reuse the memory chunk you previously freed. For example, try the following experiment:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;replace &lt;tt class="docutils literal"&gt;makeEmpty&lt;/tt&gt; on Line[7] &amp;amp; line[10] in &lt;tt class="docutils literal"&gt;multiply&lt;/tt&gt; function&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;multiply&lt;/tt&gt; works fine with &lt;tt class="docutils literal"&gt;test_multiply()&lt;/tt&gt; solely in the test program.&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;multiply&lt;/tt&gt; won't work if we do &lt;tt class="docutils literal"&gt;test_intializeInteger()&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;test_add()&lt;/tt&gt; before &lt;tt class="docutils literal"&gt;test_multiply()&lt;/tt&gt;
because the integer we construct will no longer be &lt;tt class="docutils literal"&gt;342&lt;/tt&gt; in the test case but something like &lt;tt class="docutils literal"&gt;3425&lt;/tt&gt;, where
&lt;tt class="docutils literal"&gt;5&lt;/tt&gt; is some value pointed by &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;R-&amp;gt;NextDigit&lt;/span&gt;&lt;/tt&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;So, always clear out the pointer by setting it to &lt;tt class="docutils literal"&gt;NULL&lt;/tt&gt; whenever we do initialization.&lt;/p&gt;
&lt;/div&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['CommonHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' }, Macros: {} }," +
        "    jax: ['input/TeX','input/MathML','output/CommonHTML']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Zeyuan Hu</dc:creator><pubDate>Mon, 26 Dec 2016 23:03:00 +0800</pubDate><guid isPermaLink="false">tag:zhu45.org,2016-12-26:posts/2016/Dec/26/reflection-on-integer-arithmetic-package-problem/</guid><category>software-engineering</category><category>c</category></item><item><title>A small C trick I learned today</title><link>http://zhu45.org/posts/2016/Dec/24/a-small-c-trick-i-learned-today/</link><description>&lt;p&gt;Today I learned a C trick. Here is my original &lt;tt class="docutils literal"&gt;printList&lt;/tt&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;
&lt;span class="nf"&gt;printList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;List&lt;/span&gt; &lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;Pos&lt;/span&gt; &lt;span class="n"&gt;dummy&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// creates a dummy node to traverse the list&lt;/span&gt;

  &lt;span class="n"&gt;dummy&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Next&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dummy&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;%d-&amp;gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;dummy&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Element&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;dummy&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;dummy&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Next&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It works but there is a small caveat in this routine. This is
part of print out for the &lt;tt class="docutils literal"&gt;linkedListTestMain&lt;/tt&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
TEST: printList
23-&amp;gt;44-&amp;gt;45-&amp;gt;57-&amp;gt;89-&amp;gt;-1-&amp;gt;
&lt;/pre&gt;
&lt;p&gt;As you can see, there is a little &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-&amp;gt;&lt;/span&gt;&lt;/tt&gt; at the end of linked list, which
is not supposed to be there because there is no next element after &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-1&lt;/span&gt;&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;I try to solve this problem but the solution is not succint and I don't want to
do complicated stuff just to remove this &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-&amp;gt;&lt;/span&gt;&lt;/tt&gt;. Howver, I finally get a solution
today that is very clean to eliminate &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-&amp;gt;&lt;/span&gt;&lt;/tt&gt; without adding additional complexity to
the routine.&lt;/p&gt;
&lt;p&gt;In C, we know we can use if-else shorthand likes the following:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dummyA&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;dummyA&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Digit&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;else&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;is equivalent with&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dummyA&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;?&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;dummyA&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Digit&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We can use this shorthand inside our routine &lt;tt class="docutils literal"&gt;printf&lt;/tt&gt; statement to solve our problem:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;
&lt;span class="nf"&gt;printList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;List&lt;/span&gt; &lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;Pos&lt;/span&gt; &lt;span class="n"&gt;dummy&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// creates a dummy node to traverse the list&lt;/span&gt;

  &lt;span class="n"&gt;dummy&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Next&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dummy&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;%d%s&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;dummy&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Element&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dummy&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Next&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;?&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;-&amp;gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
    &lt;span class="n"&gt;dummy&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;dummy&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Next&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;As you can see, inside &lt;tt class="docutils literal"&gt;printf&lt;/tt&gt; statement, we don't printout &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-&amp;gt;&lt;/span&gt;&lt;/tt&gt; by default, we check
if &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;dummy-&amp;gt;Next&lt;/span&gt;&lt;/tt&gt; is &lt;tt class="docutils literal"&gt;NULL&lt;/tt&gt;, then that means we are at the last element of the list, and
we don't append anything (i.e. &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;(&amp;quot;&amp;quot;)&lt;/span&gt;&lt;/tt&gt;). However, if this is not the case, we print &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-&amp;gt;&lt;/span&gt;&lt;/tt&gt;.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Zeyuan Hu</dc:creator><pubDate>Sat, 24 Dec 2016 23:11:00 +0800</pubDate><guid isPermaLink="false">tag:zhu45.org,2016-12-24:posts/2016/Dec/24/a-small-c-trick-i-learned-today/</guid><category>c</category></item><item><title>Print singly linked list in reverse order</title><link>http://zhu45.org/posts/2016/Dec/23/print-singly-linked-list-in-reverse-order/</link><description>&lt;p&gt;Today, during the lunch break, I take a look at the following problem:&lt;/p&gt;
&lt;blockquote&gt;
Print a singly linked list in reverse order.&lt;/blockquote&gt;
&lt;p&gt;This is actually one of the interview questions I got at SAP for ABAP developer position
(luckily, they didn't offer me the position). I didn't get the correct answer at that time
and I think the problem may help me to kill some time during the break.&lt;/p&gt;
&lt;p&gt;The question itself is not hard if you're familar with linked list and recursion philosophy:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt;
&lt;span class="nf"&gt;printListReverseHelper&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;List&lt;/span&gt; &lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;L&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="n"&gt;printListReverseHelper&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Next&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;%d-&amp;gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Element&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;printListReverse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;List&lt;/span&gt; &lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;Pos&lt;/span&gt; &lt;span class="n"&gt;dummyL&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Next&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;printListReverseHelper&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dummyL&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Again, in our implementation of linked list, we use header node. Given the simiplicity of the problem,
I think it is good time to revisit some basic rules in recursion.&lt;/p&gt;
&lt;p&gt;To be honest, recursion always gives me hard time because I always try to mentally expand all the call
stack and then work backwards to see if the recursion function gives what I expect. This is super energy
consuming and error-prone.&lt;/p&gt;
&lt;p&gt;However, things start to get better since I start to read MAW. Here are the four basic rules of recursion
he emphasizes:&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;&lt;em&gt;Base cases.&lt;/em&gt; You must always have some base cases, which can be solved without recursion.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Making progress.&lt;/em&gt; For the cases that are to be solved recursively, the recursive call must always
be to a case that makes progress toward a base case.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Design rule.&lt;/em&gt; Assume that all the recursive calls work.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Compound interest rule.&lt;/em&gt; Never duplicate work by solving the same instance of a problem in separate
recursive calls.&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;Among the four rules, No.3 rule is easily my most faviroite one. It is stated very simple but it has huge
impact on how you think about recursion.&lt;/p&gt;
&lt;p&gt;Let's use first three rules to analyze this problem a little bit.&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;&lt;em&gt;Base cases.&lt;/em&gt; This problem is quite simple. The base case is the case when the list is empty. In this case,
we have nothing to do and simply return.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Making progress.&lt;/em&gt; This is reflected when we call &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;printListReverseHelper(L-&amp;gt;Next)&lt;/span&gt;&lt;/tt&gt;. Each time we make the
recursive call, we pass in &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;L-&amp;gt;Next&lt;/span&gt;&lt;/tt&gt;, which makes the list shorter. This eventually will make the whole list
empty, which is the base case.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Design rule.&lt;/em&gt; I use this rule to design the whole recursion function. Just imagaine a scenario like the following:
Suppose you have a list of &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;1-&amp;gt;2-&amp;gt;3&lt;/span&gt;&lt;/tt&gt;. Then, by the rule, we assume that the number &lt;tt class="docutils literal"&gt;2&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;3&lt;/tt&gt; are already printed
in reverse order. What we left to do is to print out &lt;tt class="docutils literal"&gt;1&lt;/tt&gt; and then we done. We follow this thought process closely
when we actually write the recursion function. After we write out the base case, we first write &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;printListReverseHelper(L-&amp;gt;Next);&lt;/span&gt;&lt;/tt&gt;
This is saying that the rest of list (except the first one) is already printed in reverse order (i.e. &lt;tt class="docutils literal"&gt;2&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;3&lt;/tt&gt; in our case).
Then we write &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;printf(&amp;quot;%d-&amp;gt;&amp;quot;,&lt;/span&gt; &lt;span class="pre"&gt;L-&amp;gt;Element);&lt;/span&gt;&lt;/tt&gt;. This says, ok, since we are only left with the first node, let's print it out and the
job is done (i.e. &lt;tt class="docutils literal"&gt;1&lt;/tt&gt; in our case).&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;See, how simple the recursion can be if we can actually get over psychological obstacle to expand the call stack mentally and directly apply
four rules (especially the third rule) to design our function.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Zeyuan Hu</dc:creator><pubDate>Fri, 23 Dec 2016 00:05:00 +0800</pubDate><guid isPermaLink="false">tag:zhu45.org,2016-12-23:posts/2016/Dec/23/print-singly-linked-list-in-reverse-order/</guid><category>singly-linked-list</category><category>recursion</category></item><item><title>Environment variable substitution using Sed</title><link>http://zhu45.org/posts/2016/Dec/21/environment-variable-substitution-using-sed/</link><description>&lt;p&gt;Suppose we have a text file &lt;tt class="docutils literal"&gt;config.ini&lt;/tt&gt; looks something like this:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
[MSSQLSERVER]
Driver=INSTHOME/foo/foo.so

[SYBASE]
Driver=INSTHOME/bar/bar.so

...
&lt;/pre&gt;
&lt;p&gt;We want to replace all the appearance of &lt;tt class="docutils literal"&gt;INSTHOME&lt;/tt&gt; with the
value we hold in &lt;tt class="docutils literal"&gt;$HOME&lt;/tt&gt;. Here is what I do initially:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sed -i -e &lt;span class="s2"&gt;&amp;quot;s/INSTHOME/&lt;/span&gt;&lt;span class="nv"&gt;$HOME&lt;/span&gt;&lt;span class="s2"&gt;/g&amp;quot;&lt;/span&gt; config.ini
&lt;/pre&gt;&lt;/div&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;s&lt;/tt&gt; is used to replace the found expression &lt;tt class="docutils literal"&gt;INSTHOME&lt;/tt&gt; with &lt;tt class="docutils literal"&gt;$HOME&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;g&lt;/tt&gt; stands for &amp;quot;global&amp;quot;, which means to do this find &amp;amp; replace
for the whole line. If you leave off the &lt;tt class="docutils literal"&gt;g&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;INSTHOME&lt;/tt&gt; appears
twice on the same line, only the first &lt;tt class="docutils literal"&gt;INSTHOME&lt;/tt&gt; is changed to &lt;tt class="docutils literal"&gt;$HOME&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-i&lt;/span&gt;&lt;/tt&gt; is used to edit in place on filename&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-e&lt;/span&gt;&lt;/tt&gt; is to indicate the expression/command to run&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="admonition note"&gt;
&lt;p class="first admonition-title"&gt;Note&lt;/p&gt;
&lt;p class="last"&gt;I use double quotes &lt;tt class="docutils literal"&gt;&amp;quot;&lt;/tt&gt; to expand any variable appeard
inside &lt;tt class="docutils literal"&gt;&amp;quot;&lt;/tt&gt;. In this case, &lt;tt class="docutils literal"&gt;$HOME&lt;/tt&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;However, when I type this in and I got the following error:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
sed: -e expression #1, char 13: unknown option to `s'
&lt;/pre&gt;
&lt;p&gt;Why did this error happen? That confused me for a while. Then, I try to
simulate what the program will do for the above expression:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sed -i -e &lt;span class="s2"&gt;&amp;quot;s/INSTHOME//home/iidev20/g&amp;quot;&lt;/span&gt; config.ini
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Ah! This expansion result doesn't make sense at all because &lt;tt class="docutils literal"&gt;sed&lt;/tt&gt; expression
inside &lt;tt class="docutils literal"&gt;&amp;quot;&lt;/tt&gt; needs to follow:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
&amp;quot;s/[target_expression]/[replace_expression/g&amp;quot;
&lt;/pre&gt;
&lt;p&gt;So, the first thought comes to me is to escape all &lt;tt class="docutils literal"&gt;/&lt;/tt&gt; in the expression:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sed -i -e &lt;span class="s2"&gt;&amp;quot;s/INSTHOME/\/home\/iidev20/g&amp;quot;&lt;/span&gt; config.ini
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This can work but it has two severe drawbacks:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;I'm hardcoding the value. If &lt;tt class="docutils literal"&gt;$HOME&lt;/tt&gt; no longer holds &lt;tt class="docutils literal"&gt;/home/iidev20&lt;/tt&gt;,
then my command breaks again, and this hinders portability.&lt;/li&gt;
&lt;li&gt;The readability of this code is too bad. Probably okay for Perl programmer but
still, not quite friendly.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;To address these two issues, I find the following about &lt;a class="reference external" href="https://www.gnu.org/software/sed/manual/html_node/Addresses.html#Addresses"&gt;GNU sed&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;dl class="docutils"&gt;
&lt;dt&gt;%regexp%&lt;/dt&gt;
&lt;dd&gt;&lt;p class="first"&gt;(The % may be replaced by any other single character.)&lt;/p&gt;
&lt;blockquote class="last"&gt;
This also matches the regular expression regexp, but allows one to use a different delimiter than /. This is particularly useful if the regexp itself contains a lot of slashes, since it avoids the tedious escaping of every /. If regexp itself includes any delimiter characters, each must be escaped by a backslash ().&lt;/blockquote&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/blockquote&gt;
&lt;p&gt;Essentially, we don't have to use &lt;tt class="docutils literal"&gt;/&lt;/tt&gt; as our delimiter for the expression, especially when the pattern itself contains a lot of slashes (i.e. file path in my case).&lt;/p&gt;
&lt;p&gt;so, I decide to use &lt;tt class="docutils literal"&gt;|&lt;/tt&gt; as the delimiter:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sed -i &lt;span class="s2"&gt;&amp;quot;s|INSTHOME|&lt;/span&gt;&lt;span class="nv"&gt;$HOME&lt;/span&gt;&lt;span class="s2"&gt;|g&amp;quot;&lt;/span&gt; config.ini
&lt;/pre&gt;&lt;/div&gt;
&lt;div class="admonition note"&gt;
&lt;p class="first admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;I can also use single quote &lt;tt class="docutils literal"&gt;'&lt;/tt&gt; but the command should be modified like the below
by leaving out to-be-expanded variable name outside of single quotes.&lt;/p&gt;
&lt;div class="last"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sed -i &lt;span class="s1"&gt;&amp;#39;s|INSTHOME|&amp;#39;&lt;/span&gt;&lt;span class="nv"&gt;$HOME&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;|g&amp;#39;&lt;/span&gt; config.ini
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Now, everything works nice and clean.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Zeyuan Hu</dc:creator><pubDate>Wed, 21 Dec 2016 12:07:00 +0800</pubDate><guid isPermaLink="false">tag:zhu45.org,2016-12-21:posts/2016/Dec/21/environment-variable-substitution-using-sed/</guid><category>sed</category><category>shell</category></item><item><title>What's the difference between sourcing a script and executing a script?</title><link>http://zhu45.org/posts/2016/Dec/20/whats-the-difference-between-sourcing-a-script-and-executing-a-script/</link><description>&lt;p&gt;I run across the question in the title when I take a break from the work
today. Then I did a little bit googling, and the explanation is not quite satisfying
to me. So, I decide to answer this question by a simplied example from my work.&lt;/p&gt;
&lt;p&gt;For me, this question appears frequently when you try to install some software.
Some software, like the product I'm working on, depends on a set of environment variables
in order to setup itself properly. Usually, this may inovlve manual editing of the environment
variables in order to make the product work. However, we can do much better.
We can somehow let a setup program to edit the environment variable for the user and finish
the whole product setup process automatically.&lt;/p&gt;
&lt;p&gt;Suppose a software relies on an environment variable &lt;tt class="docutils literal"&gt;TEST_SOURCE&lt;/tt&gt; and
we don't have such an environment variable initially.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="nv"&gt;$TEST_SOURCE&lt;/span&gt;
$
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;If we create a test script &lt;tt class="docutils literal"&gt;test.sh&lt;/tt&gt; like the following:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="ch"&gt;#!/bin/sh&lt;/span&gt;

&lt;span class="nb"&gt;export&lt;/span&gt; &lt;span class="nv"&gt;TEST_SOURCE&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;HELLO
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Then we can have two way to execute this script: either by &lt;tt class="docutils literal"&gt;./test.sh&lt;/tt&gt; or
by &lt;tt class="docutils literal"&gt;source test.sh&lt;/tt&gt; and they two have different outcome:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ ./test.sh
$ &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="nv"&gt;$TEST_SOURCE&lt;/span&gt;
$
$ &lt;span class="nb"&gt;source&lt;/span&gt; test.sh
$ &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="nv"&gt;$TEST_SOURCE&lt;/span&gt;
HELLO
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So, the conclusion is that when we execute in &lt;tt class="docutils literal"&gt;source&lt;/tt&gt;, we actually run program
in the current shell. However, if we execute in &lt;tt class="docutils literal"&gt;./&lt;/tt&gt;, then we run the program
in a separately shell and the execution (i.e. modify environment variable) doesn't
impact our current shell.&lt;/p&gt;
&lt;!-- http://www.theeggeadventure.com/wikimedia/index.php/Interview_Questions --&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Zeyuan Hu</dc:creator><pubDate>Tue, 20 Dec 2016 21:49:00 +0800</pubDate><guid isPermaLink="false">tag:zhu45.org,2016-12-20:posts/2016/Dec/20/whats-the-difference-between-sourcing-a-script-and-executing-a-script/</guid><category>shell</category></item><item><title>Polynomial Multiplication</title><link>http://zhu45.org/posts/2016/Dec/18/polynomial-multiplication/</link><description>&lt;p&gt;I finally got time to continue working through MAW. The problem 3.7 relates to polynomial multiplication.&lt;/p&gt;
&lt;div class="section" id="problem"&gt;
&lt;h2&gt;Problem&lt;/h2&gt;
&lt;p&gt;Write a function to multiply two polynomials, using a linked list implementation. You must make sure that
the output polynomial is sorted by exponent and has at most one term of any power.&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol class="loweralpha simple"&gt;
&lt;li&gt;Give an algorithm to solve this problem in &lt;span class="math"&gt;\(O(M^2N^2)\)&lt;/span&gt; time.&lt;/li&gt;
&lt;li&gt;Write a program to perform the multiplication in &lt;span class="math"&gt;\(O(M^2N)\)&lt;/span&gt; time, where &lt;span class="math"&gt;\(M\)&lt;/span&gt; is the number
of terms in the polynomiial of fewer terms.&lt;/li&gt;
&lt;li&gt;Write a program to perform the multiplication in &lt;span class="math"&gt;\(O(MNlog(MN))\)&lt;/span&gt; time.&lt;/li&gt;
&lt;li&gt;Which time bound above is the best?&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class="section" id="solution"&gt;
&lt;h2&gt;Solution&lt;/h2&gt;
&lt;div class="section" id="question-1"&gt;
&lt;h3&gt;Question 1&lt;/h3&gt;
&lt;p&gt;The first question is quite straightforward. We keep the result in a linked list with
exponent sorted in descending order. Each time a multiply is performed, we search through
the result linkedlist for the term with the same exponent as ours. If so, we simply add
coefficients together. If not, we add our product as a new term.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;Polynomial&lt;/span&gt;
&lt;span class="nf"&gt;multiply1&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Polynomial&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Polynomial&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="n"&gt;Polynomial&lt;/span&gt; &lt;span class="n"&gt;R&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;malloc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;span class="n"&gt;PtrToNode&lt;/span&gt; &lt;span class="n"&gt;dummyRPrev&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;R&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;PtrToNode&lt;/span&gt; &lt;span class="n"&gt;dummyR&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;R&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;PtrToNode&lt;/span&gt; &lt;span class="n"&gt;dummyA&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Next&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;PtrToNode&lt;/span&gt; &lt;span class="n"&gt;dummyB&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Next&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;tmpExponent&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;tmpCoefficient&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dummyA&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dummyB&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="n"&gt;tmpExponent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;dummyA&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;exponent&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;dummyB&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;exponent&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
      &lt;span class="n"&gt;tmpCoefficient&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;dummyA&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;coefficient&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;dummyB&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;coefficient&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

      &lt;span class="c1"&gt;// we go through the output polynomial to see if there is&lt;/span&gt;
      &lt;span class="c1"&gt;// a term with the same exponent as our tmpExponent.&lt;/span&gt;
      &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dummyR&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dummyR&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;exponent&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;tmpExponent&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt;
          &lt;span class="n"&gt;dummyR&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;coefficient&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;dummyR&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;coefficient&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;tmpCoefficient&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
          &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt;
          &lt;span class="n"&gt;dummyRPrev&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;dummyR&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
          &lt;span class="n"&gt;dummyR&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;dummyR&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Next&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
      &lt;span class="p"&gt;}&lt;/span&gt;

      &lt;span class="c1"&gt;// We couldn&amp;#39;t find the term with the same exponent, so we create&lt;/span&gt;
      &lt;span class="c1"&gt;// a new term in our output polynomial.&lt;/span&gt;
      &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dummyR&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;insert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tmpCoefficient&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;tmpExponent&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;dummyRPrev&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
      &lt;span class="p"&gt;}&lt;/span&gt;

      &lt;span class="n"&gt;dummyR&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;R&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
      &lt;span class="n"&gt;dummyB&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;dummyB&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Next&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;dummyB&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Next&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;dummyA&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;dummyA&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Next&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;

  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;R&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The total running time is &lt;span class="math"&gt;\(O(M*N)\)&lt;/span&gt;. We start from the inner most loop. We
go through the result linkedList to search for the duplicate exponent term. The running
time depends on the length of the linkedList. The result linkedList can have at most
&lt;span class="math"&gt;\(M*N\)&lt;/span&gt; terms. Then, for the middle loop, we iterate through &lt;span class="math"&gt;\(N\)&lt;/span&gt; times and
for the outer most loop, we iterate through &lt;span class="math"&gt;\(M\)&lt;/span&gt; times. So, the total running time
is &lt;span class="math"&gt;\(O(M*N*MN) = O(M^2N^2)\)&lt;/span&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="question-2"&gt;
&lt;h3&gt;Question 2&lt;/h3&gt;
&lt;p&gt;We can certainly do better than &lt;span class="math"&gt;\(O(M^2N^2)\)&lt;/span&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;Polynomial&lt;/span&gt;
&lt;span class="nf"&gt;multiply2&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Polynomial&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Polynomial&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;lenA&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;lenB&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;PtrToNode&lt;/span&gt; &lt;span class="n"&gt;dummyA&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Next&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;PtrToNode&lt;/span&gt; &lt;span class="n"&gt;dummyB&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Next&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;Polynomial&lt;/span&gt; &lt;span class="n"&gt;R&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;malloc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
  &lt;span class="n"&gt;PtrToNode&lt;/span&gt; &lt;span class="n"&gt;dummyTmp&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;dummyShort&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;dummyLong&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Long&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;Polynomial&lt;/span&gt; &lt;span class="n"&gt;Tmp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;malloc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;

  &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dummyA&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;lenA&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;dummyA&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;dummyA&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Next&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;

  &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dummyB&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;lenB&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;dummyB&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;dummyB&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Next&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;

  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;lenA&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;lenB&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;dummyShort&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Next&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;dummyLong&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Next&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;Long&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="k"&gt;else&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;dummyShort&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Next&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;dummyLong&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Next&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;Long&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;

  &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dummyShort&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;dummyTmp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Tmp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dummyLong&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;coefficient&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;dummyShort&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;coefficient&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;dummyLong&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;coefficient&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
      &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;exponent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;dummyShort&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;exponent&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;dummyLong&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;exponent&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
      &lt;span class="n"&gt;insert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;coefficient&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;exponent&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;dummyTmp&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
      &lt;span class="n"&gt;dummyTmp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;dummyTmp&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Next&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
      &lt;span class="n"&gt;dummyLong&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;dummyLong&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Next&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;R&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;R&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Tmp&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;dummyLong&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Long&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Next&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;deletePolynomial&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Tmp&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;dummyShort&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;dummyShort&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Next&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;

  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;R&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Suppose polynomials &lt;span class="math"&gt;\(A\)&lt;/span&gt; has &lt;span class="math"&gt;\(M\)&lt;/span&gt; terms, and polynomials
&lt;span class="math"&gt;\(B\)&lt;/span&gt; has &lt;span class="math"&gt;\(N\)&lt;/span&gt; terms. &lt;span class="math"&gt;\(M &amp;lt; N\)&lt;/span&gt;.
Instead of updating the result after each multiply, we multiply one term
from &lt;span class="math"&gt;\(A\)&lt;/span&gt; (the polynomials with fewer terms) by all the terms from
&lt;span class="math"&gt;\(B\)&lt;/span&gt; (the polynomials with more terms). Then we add this with the output
linkedList using &lt;tt class="docutils literal"&gt;Polynomial &lt;span class="pre"&gt;add(...)&lt;/span&gt;&lt;/tt&gt; function I implemented (can be found under
&lt;a class="reference external" href="https://github.com/xxks-kkk/algo/blob/master/linkedList/polynomial/polynomial.c"&gt;polynomial.c&lt;/a&gt;).
The &lt;tt class="docutils literal"&gt;add&lt;/tt&gt; function has a runtime &lt;span class="math"&gt;\(O(max(M,N))\)&lt;/span&gt; and thus we can get our runtime for &lt;tt class="docutils literal"&gt;multiply2&lt;/tt&gt;:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
O(max(N,0)) + O(max(N,N)) + O(max(N,2N)) + ... + O(max(N, N(M-1))) = O(M^2N)
\end{equation*}
&lt;/div&gt;
&lt;p&gt;Also, we calculate the length of &lt;span class="math"&gt;\(A\)&lt;/span&gt; taking &lt;span class="math"&gt;\(O(M)\)&lt;/span&gt;; we calculate the length of &lt;span class="math"&gt;\(B\)&lt;/span&gt;
taking &lt;span class="math"&gt;\(O(N)\)&lt;/span&gt;; and we do &lt;tt class="docutils literal"&gt;deleteList&lt;/tt&gt; during the while loop taking &lt;span class="math"&gt;\(O(MN)\)&lt;/span&gt;. So, the total runtime is:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
O(M^2 N) + O(M) + O(N) + O(MN) = O(M^2 N)
\end{equation*}
&lt;/div&gt;
&lt;div class="admonition note"&gt;
&lt;p class="first admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;For this implementation, I kind of using an interface within the function. The logic
begins with &lt;tt class="docutils literal"&gt;while (dummyShort != NULL)&lt;/tt&gt; are the same for both &lt;span class="math"&gt;\(M&amp;lt;N\)&lt;/span&gt; and &lt;span class="math"&gt;\(M&amp;gt;N\)&lt;/span&gt;.
So, there is potential to write the same logic twice for these two cases respectively. The solution
I use is to provide an interface using &lt;tt class="docutils literal"&gt;dummyLong&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;dummyShort&lt;/tt&gt; variables.&lt;/p&gt;
&lt;p class="last"&gt;Please note we need to multiply one term from the polynomials with fewer terms by all the terms from
the polynomial with more terms. If we do the other way around, the runtime will be &lt;span class="math"&gt;\(O(MN^2)\)&lt;/span&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="question-3-4"&gt;
&lt;h3&gt;Question 3 &amp;amp; 4&lt;/h3&gt;
&lt;p&gt;I haven't coded up for question 3 because I want to wait for finishing sorting chapter. However, I can see how we
can get &lt;span class="math"&gt;\(O(MNlog(MN))\)&lt;/span&gt;. This solution is very similar to Question 1. We first multiply all terms out using
&lt;span class="math"&gt;\(O(MN)\)&lt;/span&gt;. Then, we sort resulting &lt;span class="math"&gt;\(MN\)&lt;/span&gt; terms by exponent. Then, we run through the linked list merging any
summing any terms with the same exponent (which will be contiguous). The sort takes &lt;span class="math"&gt;\(O(MNlog(MN))\)&lt;/span&gt; time.
The multipies and the merging of duplicates can be performed in &lt;span class="math"&gt;\(O(MN)\)&lt;/span&gt; time.
So, we have:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
O(MN) + O(MNlog(MN)) + O(MN) = O(MNlog(MN))
\end{equation*}
&lt;/div&gt;
&lt;p&gt;When we actually compare the runtime of three solutions, we can see 1st one is the worst among the three. However,
for 2nd one and 3rd one, the comparison result depends on the size of &lt;span class="math"&gt;\(M\)&lt;/span&gt; and &lt;span class="math"&gt;\(N\)&lt;/span&gt;. If &lt;span class="math"&gt;\(M\)&lt;/span&gt; and
&lt;span class="math"&gt;\(N\)&lt;/span&gt; are close in size, then &lt;span class="math"&gt;\(O(MNlog(MN))\approx O(MNlog(M^2))=O(MNlog(M))\)&lt;/span&gt;, which is better than &lt;span class="math"&gt;\(O(M^2N)\)&lt;/span&gt;.
However, if &lt;span class="math"&gt;\(M\)&lt;/span&gt; is very small in comparison to &lt;span class="math"&gt;\(N\)&lt;/span&gt;, then &lt;span class="math"&gt;\(M\)&lt;/span&gt; is less than &lt;span class="math"&gt;\(log(MN)\)&lt;/span&gt; and in this case,
2nd one is better than 3rd one.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['CommonHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' }, Macros: {} }," +
        "    jax: ['input/TeX','input/MathML','output/CommonHTML']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Zeyuan Hu</dc:creator><pubDate>Sun, 18 Dec 2016 18:53:00 +0800</pubDate><guid isPermaLink="false">tag:zhu45.org,2016-12-18:posts/2016/Dec/18/polynomial-multiplication/</guid><category>singly-linked-list</category><category>maw</category></item><item><title>Pelican Hack Day</title><link>http://zhu45.org/posts/2016/Dec/17/pelican-hack-day/</link><description>&lt;p&gt;I have been using Sphinx since 2012 and I spend quite a amount of time to customize
my old Sphinx-based websites
(&lt;a class="reference external" href="https://zeyuanhu.wordpress.com/2016/11/24/under-construction-part-12/"&gt;This article revisits all my past website construction effort&lt;/a&gt;).
However, most of the time I'm tweaking the CSS and content organization of the site.
I never get my hands on a serious template customization. The reason is quite simple,
I have limited knowledge how Sphinx interact with Jinja template engine and Jinja
language itself just looks really bizzare to me.&lt;/p&gt;
&lt;p&gt;Now, since I start a new blog, I decide to give Jinja a chance and customize
&lt;a class="reference external" href="/archives/index.html"&gt;my archive page&lt;/a&gt; a little bit.&lt;/p&gt;
&lt;p&gt;Here is what I want my archive page to look like:&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Don't display post content. Only the title itself.&lt;/li&gt;
&lt;li&gt;Display archives by year and archives by tags within the same page at the same time.&lt;/li&gt;
&lt;li&gt;Display the number of posts for each year, and for each tag.&lt;/li&gt;
&lt;li&gt;Show the time only in &amp;quot;month.day.year&amp;quot;. I don't need the hours and minutes.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;div class="section" id="first-iteration"&gt;
&lt;h2&gt;First Iteration&lt;/h2&gt;
&lt;p&gt;If you have read about &lt;a class="reference external" href="http://docs.getpelican.com/en/3.6.3/themes.html#templates-and-variables"&gt;Creating themes section in Pelican doc&lt;/a&gt;,
you will see that we have to work with &lt;tt class="docutils literal"&gt;archives.html&lt;/tt&gt;. Pelican will use the layout
specified in this file to generate our archive page.&lt;/p&gt;
&lt;p&gt;For the first iteration, my &lt;tt class="docutils literal"&gt;archives.html&lt;/tt&gt; looks something like this&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt; {% extends &amp;quot;base.html&amp;quot; %}
 {% block content %}
 &amp;lt;section id=&amp;quot;content&amp;quot; class=&amp;quot;body&amp;quot;&amp;gt;
 &amp;lt;h1&amp;gt;Archives for {{ SITENAME }}&amp;lt;/h1&amp;gt;

 {# based on http://stackoverflow.com/questions/12764291/jinja2-group-by-month-year #}

 {% for year, year_group in dates|groupby(&amp;#39;date.year&amp;#39;)|reverse %}
 {% for month, month_group in year_group|groupby(&amp;#39;date.month&amp;#39;)|reverse %}
     &amp;lt;h4 class=&amp;quot;date&amp;quot;&amp;gt;{{ (month_group|first).date|strftime(&amp;#39;%b %Y&amp;#39;) }}&amp;lt;/h4&amp;gt;
     &amp;lt;div class=&amp;quot;post archives&amp;quot;&amp;gt;
     &amp;lt;ul&amp;gt;
         {% for article in month_group %}
             &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;{{ SITEURL }}/{{ article.url }}&amp;quot;&amp;gt;{{ article.title }}&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
         {% endfor %}
     &amp;lt;/ul&amp;gt;
     &amp;lt;/div&amp;gt;
 {% endfor %}
 {% endfor %}
 &amp;lt;/section&amp;gt;
 {% endblock %}
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;p&gt;Let's first take a look at what archive page we can get from this code.&lt;/p&gt;
&lt;img alt="pelican-hack-1 result" src="/images/pelican-hack-1.png" /&gt;
&lt;p&gt;Line[1],[2] illustrates how usually template file get organized. Usually, we create
a basic html file that specifies the layout of our site, which is &lt;tt class="docutils literal"&gt;base.html&lt;/tt&gt; in my case.
Then, we want to extends this basic html to tailor to different needs. Inside &lt;tt class="docutils literal"&gt;base.html&lt;/tt&gt;,
we will place a placeholder, which will be replaced by the content of each child html page:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
{% block content %}
{% endblock %}
&lt;/pre&gt;
&lt;p&gt;In my case, I extends &lt;tt class="docutils literal"&gt;base.html&lt;/tt&gt; to make an archive page. The content enclosed between
&lt;tt class="docutils literal"&gt;{% block content %}&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;{% endblock %}&lt;/tt&gt; will replace the placeholder inside &lt;tt class="docutils literal"&gt;base.html&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;Line[4] &lt;tt class="docutils literal"&gt;{{ SITENAME }}&lt;/tt&gt; is very similar to shell expansion. We will expand the variable &lt;tt class="docutils literal"&gt;SITENAME&lt;/tt&gt;
with its content. &lt;tt class="docutils literal"&gt;SITENAME&lt;/tt&gt; is the same variable we specify in &lt;tt class="docutils literal"&gt;pelicanconf.py&lt;/tt&gt; and the expanded
result will be the value we assign to &lt;tt class="docutils literal"&gt;SITENAME&lt;/tt&gt; variable in config file. In my case, the expansion
result will be &amp;quot;Tech Stuff&amp;quot;.&lt;/p&gt;
&lt;p&gt;Starts from Line[8], things start to get interesting:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
{% for year, year_group in dates|groupby('date.year')|reverse %}
...
{% endfor %}
&lt;/pre&gt;
&lt;p&gt;Jinja itself is based on Python. So, we can borrow some knowledge from our Python realm. As you can tell,
&lt;tt class="docutils literal"&gt;{% for ... %} ... {% endfor %}&lt;/tt&gt; is what for loop looks like in Jinja.&lt;/p&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;dates&lt;/tt&gt; itself is a list of articles ordered by date, with each element is an &lt;em&gt;article&lt;/em&gt; object. Here is what
&lt;tt class="docutils literal"&gt;dates&lt;/tt&gt; looks like in my mind:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
dates = [ article1, article2, article2, ... ]
&lt;/pre&gt;
&lt;p&gt;and each &lt;em&gt;article&lt;/em&gt; looks like:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
article = [ title, summary, author, date, ... ]
&lt;/pre&gt;
&lt;p&gt;Let's put the following code in our &lt;tt class="docutils literal"&gt;archives.html&lt;/tt&gt; to better understand the structure of &lt;tt class="docutils literal"&gt;dates&lt;/tt&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
{% for year in dates %}
&amp;lt;h1&amp;gt;{{ year }}&amp;lt;/h4&amp;gt;
{% endfor %}
&lt;/pre&gt;
&lt;p&gt;The output looks like:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
/Users/zeyuan/Documents/projects/linuxjedi.co.uk/content/blog/2016/12/17/pelican-hack.rst
/Users/zeyuan/Documents/projects/linuxjedi.co.uk/content/blog/2016/12/16/portability.rst
/Users/zeyuan/Documents/projects/linuxjedi.co.uk/content/blog/2016/12/03/maw-003.rst
/Users/zeyuan/Documents/projects/linuxjedi.co.uk/content/blog/2016/11/28/maw-002.rst
...
&lt;/pre&gt;
&lt;div class="admonition note"&gt;
&lt;p class="first admonition-title"&gt;Note&lt;/p&gt;
&lt;p class="last"&gt;I would highly recommend to read through the
&lt;a class="reference external" href="http://docs.getpelican.com/en/3.6.3/themes.html#templates-and-variables"&gt;Creating themes section in Pelican doc&lt;/a&gt; page,
they describe those objects in word.&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;groupby&lt;/tt&gt; is a &lt;a class="reference external" href="http://jinja.pocoo.org/docs/dev/templates/"&gt;Jinja filter which can group a sequence of objects by a common attribute&lt;/a&gt;
In our case, we want to group the info based on year. In other words, &lt;em&gt;article&lt;/em&gt; with the same year should be in the same group.
Let's experiment with the following code:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
{% for year, year_group in dates|groupby('date.year') %}
    &amp;lt;h1&amp;gt;{{ year }} {{ year_group }}&amp;lt;/h4&amp;gt;
{% endfor %}
&lt;/pre&gt;
&lt;p&gt;The output looks like:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
2015 []
2016 [, , , , , , ]
&lt;/pre&gt;
&lt;p&gt;Then, we apply &lt;tt class="docutils literal"&gt;reverse&lt;/tt&gt; filter to make &lt;tt class="docutils literal"&gt;2016&lt;/tt&gt; on top of &lt;tt class="docutils literal"&gt;2015&lt;/tt&gt;. The reset of the code shouldn't be hard to decode.&lt;/p&gt;
&lt;div class="admonition note"&gt;
&lt;p class="first admonition-title"&gt;Note&lt;/p&gt;
&lt;p class="last"&gt;&lt;tt class="docutils literal"&gt;|&lt;/tt&gt; is pipe, which is used to separate filters. It works like pipe in shell.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="count-posts"&gt;
&lt;h2&gt;Count posts&lt;/h2&gt;
&lt;p&gt;This is what my current archive page layout looks like:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
{% extends &amp;quot;base.html&amp;quot; %}
{% block content %}
&amp;lt;section id=&amp;quot;content&amp;quot; class=&amp;quot;body&amp;quot;&amp;gt;
&amp;lt;h1&amp;gt;Archives for {{ SITENAME }}&amp;lt;/h1&amp;gt;

&amp;lt;p&amp;gt;
&amp;lt;h2&amp;gt;Archives by year&amp;lt;/h2&amp;gt;

{% for year, numposts in articles|groupby('date.year') %}
&amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;{{ SITEURL }}/archives/{{ year }}/period_archives.html&amp;quot;&amp;gt;{{ year }} ({{ numposts|count }})&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
{% endfor %}
&amp;lt;/p&amp;gt;

&amp;lt;p&amp;gt;
&amp;lt;h2&amp;gt;Archives by tag&amp;lt;/h2&amp;gt;

{% for tag, articles in tags %}
&amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;{{ SITEURL }}/tag/{{ tag }}.html&amp;quot;&amp;gt;{{ tag }} ({{ articles|count }})&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
{% endfor %}
&amp;lt;/p&amp;gt;
&amp;lt;/section&amp;gt;
{% endblock %}
&lt;/pre&gt;
&lt;p&gt;If you understand previous sections, this code chunk should have no problem to you. I should point out that &lt;tt class="docutils literal"&gt;count&lt;/tt&gt;
is the filter we use to count the number of &lt;em&gt;articles&lt;/em&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="the-rest"&gt;
&lt;h2&gt;The rest&lt;/h2&gt;
&lt;p&gt;For &amp;quot;Archive by year&amp;quot;, I use another template &amp;quot;period_archives.html&amp;quot; to specify the layout. It looks pretty straightforward.
However, there is a problem takes me a while to figure out:&lt;/p&gt;
&lt;blockquote&gt;
When I click on certain year, I jump to the archive page for that year. In that year, I want to have
the page display &amp;quot;Archives for 2016&amp;quot;. &amp;quot;2016&amp;quot; can be replaced based on the year I actually click initially.
This leads to a problem to me: how do I know which year the user click? In other words, how do I pass the information
to &amp;quot;period_archives.html&amp;quot;?&lt;/blockquote&gt;
&lt;p&gt;I couldn't find a nice way to solve this problem. Here is what I do:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
{% for year, null in dates|groupby('date.year') %}
    &amp;lt;h1&amp;gt;Archives for {{ year }}&amp;lt;/h1&amp;gt;
{% endfor %}
&lt;/pre&gt;
&lt;p&gt;Since each articles under a certain year archive should have the same year value, I need to take a look at one of them
to find out the year value and put the value to the heading. However, I don't have to do this trick for tag. I can somehow
magically reference the value:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
&amp;lt;h1&amp;gt;Archives by tag '{{ tag }}'&amp;lt;/h1&amp;gt;
&lt;/pre&gt;
&lt;p&gt;Last point I want to point out is that you can define your own Jinja filter under &lt;tt class="docutils literal"&gt;pelicanconf.py&lt;/tt&gt;.&lt;/p&gt;
&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Zeyuan Hu</dc:creator><pubDate>Sat, 17 Dec 2016 22:44:00 +0800</pubDate><guid isPermaLink="false">tag:zhu45.org,2016-12-17:posts/2016/Dec/17/pelican-hack-day/</guid><category>pelican</category><category>Jinja</category></item><item><title>Lesson Learned: Portability</title><link>http://zhu45.org/posts/2016/Dec/16/lesson-learned-portability/</link><description>&lt;p&gt;Portability is a kind of issue that people always talk about in software engineering field.
I never have been through such problem on my own probably because I don't have to port my
stuff into different platforms. However, this is not the case anymore during the work.&lt;/p&gt;
&lt;p&gt;Recently, I revisit the first task I owned when I joined the team, which is to develop a lightweight
configuration tool to improve product usability. Lightweight is the key of this task as we originally
have a Java-based GUI setup tool involving lots of point &amp;amp; click. This solution is fairly unpopular among
our customers mainly because the program itself takes lots of space for DB2 image and it doesn't fit well
with his peers, which all are scripts that can be executed directly from shell.&lt;/p&gt;
&lt;p&gt;So, in my iteration, I decide to follow the format of majority of utility tools in DB2 image - using scripting language.
The language I choose is, unfortunately, Shell. The whole task goes amazingly well. With the help of my tool, product configuration
time is reduced by 75%. Everyone in my team loves it until someone decides to run it on AIX.&lt;/p&gt;
&lt;p&gt;The environment I develop the tool is SUSE with &lt;tt class="docutils literal"&gt;ksh&lt;/tt&gt; installed. The AIX that my colleague tries to test my tool on also has &lt;tt class="docutils literal"&gt;ksh&lt;/tt&gt; configured
but there are some quirky behavior difference on different platform.&lt;/p&gt;
&lt;p&gt;For instance, when I try to split an array, say &lt;tt class="docutils literal"&gt;tmp2&lt;/tt&gt; with delimiter &lt;tt class="docutils literal"&gt;:&lt;/tt&gt;, the following code works great on SUSE:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
saveIFS=$IFS
IFS=&amp;quot;:&amp;quot;
local tmp2=($tmp) # split tmp with &amp;quot;:&amp;quot; and stored into tmp2 as array
IFS=$saveIFS
&lt;/pre&gt;
&lt;p&gt;However, on AIX, only the following way will work:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
#!/bin/sh
tmp=a:b:c:d
saveIFS=$IFS
IFS=&amp;quot;:&amp;quot;
local tmp2
n=0
for i in $tmp; do tmp2[$n]=$i; ((n=n+1)); done
IFS=$saveIFS
echo ${tmp2[0]}
echo ${tmp2[1]}
echo ${tmp2[2]}
echo ${tmp2[3]}
&lt;/pre&gt;
&lt;p&gt;As you can see, I need a for loop to split the array on AIX.&lt;/p&gt;
&lt;p&gt;For another example, when I try to increment counter inside a loop, on SUSE,
I can do &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;((n++))&lt;/span&gt;&lt;/tt&gt; but on AIX, I need to do &lt;tt class="docutils literal"&gt;((n=n+1))&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;This makes me realize why most of our development scripts (i.e. to help build the source code)
use perl instead of shell. I have to rewrite the whole script in Perl.&lt;/p&gt;
&lt;p&gt;This is a very important lesson for a fresh college graduate by that time.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Zeyuan Hu</dc:creator><pubDate>Fri, 16 Dec 2016 23:20:00 +0800</pubDate><guid isPermaLink="false">tag:zhu45.org,2016-12-16:posts/2016/Dec/16/lesson-learned-portability/</guid><category>software-engineering</category><category>shell</category><category>AIX</category></item><item><title>Reverse Singly Linked List</title><link>http://zhu45.org/posts/2016/Dec/03/reverse-singly-linked-list/</link><description>&lt;div class="section" id="problem"&gt;
&lt;h2&gt;Problem&lt;/h2&gt;
&lt;p&gt;This problem is MAW 3.12:&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol class="loweralpha simple"&gt;
&lt;li&gt;Write a nonrecursive procedure to reverse a singly linked list in O(N) time.&lt;/li&gt;
&lt;li&gt;Write a procedure to reverse a singly linked list in O(N) time using constant
extra space.&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class="section" id="solution"&gt;
&lt;h2&gt;Solution&lt;/h2&gt;
&lt;p&gt;Essentially, this is just one problem: reverse a singly linked list with various
constraints. There are a couple of ways doing so. All of them satisfy 3.12.a and
3.12.b&lt;/p&gt;
&lt;div class="admonition note"&gt;
&lt;p class="first admonition-title"&gt;Note&lt;/p&gt;
&lt;p class="last"&gt;Solution 2 &amp;amp; 3 are probably most people will expect, particularly during an
interview.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="solution-1"&gt;
&lt;h3&gt;Solution 1&lt;/h3&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt; &lt;span class="n"&gt;List&lt;/span&gt;
 &lt;span class="nf"&gt;reverseList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;List&lt;/span&gt; &lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
 &lt;span class="p"&gt;{&lt;/span&gt;
   &lt;span class="n"&gt;Pos&lt;/span&gt; &lt;span class="n"&gt;dummyL&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Next&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
   &lt;span class="n"&gt;List&lt;/span&gt; &lt;span class="n"&gt;R&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;malloc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;

   &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dummyL&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
   &lt;span class="p"&gt;{&lt;/span&gt;
     &lt;span class="n"&gt;Pos&lt;/span&gt; &lt;span class="n"&gt;tmpNode&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;malloc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
     &lt;span class="n"&gt;tmpNode&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Element&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;dummyL&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Element&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
     &lt;span class="n"&gt;tmpNode&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Next&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;R&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Next&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
     &lt;span class="n"&gt;R&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Next&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;tmpNode&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
     &lt;span class="n"&gt;dummyL&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;dummyL&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Next&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
   &lt;span class="p"&gt;}&lt;/span&gt;
   &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;R&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
 &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;p&gt;Solution 1 is pretty straightforward. We first create a new list. Then, we walk
through the original list and insert node we visit at the very beginning of the
new list. Once we finish the traversal of the original list, we return the new list.&lt;/p&gt;
&lt;div class="admonition note"&gt;
&lt;p class="first admonition-title"&gt;Note&lt;/p&gt;
&lt;p class="last"&gt;You can use a stack to reverse the list. This will require O(N) extra space.&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;This solution shows one of the reasons why we use a &lt;em&gt;header&lt;/em&gt; node or &lt;em&gt;dummy&lt;/em&gt; node
in our linked list implementation (instead of just use a pointer directly pointing
towards the first element in the list):&lt;/p&gt;
&lt;blockquote&gt;
Without the dummy node, there is no really obvious way to insert at the
front of the list.&lt;/blockquote&gt;
&lt;p&gt;This can be seen from Line[12]. Also, this routine has a return type &lt;tt class="docutils literal"&gt;List&lt;/tt&gt; instead of
&lt;tt class="docutils literal"&gt;void&lt;/tt&gt;.&lt;/p&gt;
&lt;div class="admonition note"&gt;
&lt;p class="first admonition-title"&gt;Note&lt;/p&gt;
&lt;p class="last"&gt;The definition for using or not using &lt;em&gt;dummy&lt;/em&gt; node is the same. However,
implementation difference can be seen by observing how the program construct
a list: in my case, &lt;a class="reference external" href="http://zhu45.org/posts/2016/Nov/28/printlots/"&gt;initializeList&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;However, this solution wastes a ton of memory space and too many &lt;tt class="docutils literal"&gt;malloc&lt;/tt&gt; operations,
which basically duplicate the data. This is the place where the algorithm can be improved.&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt; &lt;span class="n"&gt;List&lt;/span&gt;
 &lt;span class="nf"&gt;reverseList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;List&lt;/span&gt; &lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
 &lt;span class="p"&gt;{&lt;/span&gt;
   &lt;span class="n"&gt;Pos&lt;/span&gt; &lt;span class="n"&gt;dummyL&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Next&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
   &lt;span class="n"&gt;List&lt;/span&gt; &lt;span class="n"&gt;R&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;malloc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;

   &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dummyL&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
   &lt;span class="p"&gt;{&lt;/span&gt;
     &lt;span class="c1"&gt;// Remove element from old list.&lt;/span&gt;
     &lt;span class="n"&gt;Pos&lt;/span&gt; &lt;span class="n"&gt;tmpNode&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;dummyL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
     &lt;span class="n"&gt;dummyL&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;dummyL&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Next&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

     &lt;span class="c1"&gt;// Insert element in new list.&lt;/span&gt;
     &lt;span class="n"&gt;tmpNode&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Next&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;R&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Next&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
     &lt;span class="n"&gt;R&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Next&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;tmpNode&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
   &lt;span class="p"&gt;}&lt;/span&gt;
   &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;R&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
 &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;div class="admonition note"&gt;
&lt;p class="first admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;This solution has two interesting points:&lt;/p&gt;
&lt;ul class="last simple"&gt;
&lt;li&gt;It's obvious that it's correct: there are no corner cases to worry about
and both two-line operations are familiar to anyone who's manipulated a
linked list.&lt;/li&gt;
&lt;li&gt;It's pretty much identical to the Solution 2 (same number of temporary variables,
same assignments in slightly different order).&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="solution-2"&gt;
&lt;h3&gt;Solution 2&lt;/h3&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt;
 &lt;span class="nf"&gt;reverseListIterative&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;List&lt;/span&gt; &lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
 &lt;span class="p"&gt;{&lt;/span&gt;
   &lt;span class="n"&gt;Pos&lt;/span&gt; &lt;span class="n"&gt;dummyCurrent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Next&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
       &lt;span class="n"&gt;dummyPrev&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
       &lt;span class="n"&gt;dummyNext&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

   &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dummyCurrent&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
   &lt;span class="p"&gt;{&lt;/span&gt;
     &lt;span class="n"&gt;dummyNext&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;dummyCurrent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Next&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
     &lt;span class="n"&gt;dummyCurrent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Next&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;dummyPrev&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
     &lt;span class="n"&gt;dummyPrev&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;dummyCurrent&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
     &lt;span class="n"&gt;dummyCurrent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;dummyNext&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
   &lt;span class="p"&gt;}&lt;/span&gt;
   &lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Next&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;dummyPrev&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
 &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;p&gt;The 2nd solution is an iterative approach. The logic itself is quite straightforward.
But, please always remember we assume &lt;em&gt;dummy&lt;/em&gt; node exists. You can see both from
Line[4] and Line[15].&lt;/p&gt;
&lt;div class="admonition note"&gt;
&lt;p class="first admonition-title"&gt;Note&lt;/p&gt;
&lt;p class="last"&gt;This actually not the solution I come up initially. My initial implementation
works but is not as nice as this one. You can check it out in my
&lt;a class="reference external" href="https://github.com/xxks-kkk/algo/blob/master/linkedList/linkedList.c"&gt;linkedList.c&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="solution-3"&gt;
&lt;h3&gt;Solution 3&lt;/h3&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt; &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="n"&gt;List&lt;/span&gt; &lt;span class="n"&gt;P&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
 &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt;
 &lt;span class="nf"&gt;reverseListRecursiveHelper&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;List&lt;/span&gt; &lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
 &lt;span class="p"&gt;{&lt;/span&gt;
   &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Next&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
   &lt;span class="p"&gt;{&lt;/span&gt;
     &lt;span class="n"&gt;P&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
     &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
   &lt;span class="p"&gt;}&lt;/span&gt;
   &lt;span class="n"&gt;reverseListRecursiveHelper&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Next&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
   &lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Next&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Next&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
   &lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Next&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
 &lt;span class="p"&gt;}&lt;/span&gt;

 &lt;span class="kt"&gt;void&lt;/span&gt;
 &lt;span class="nf"&gt;reverseListRecursive&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;List&lt;/span&gt; &lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
 &lt;span class="p"&gt;{&lt;/span&gt;
   &lt;span class="n"&gt;reverseListRecursiveHelper&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Next&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
   &lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Next&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;P&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
 &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;p&gt;This solution is a recursive solution. This causes me much time to think about
because we have a &lt;em&gt;dummy&lt;/em&gt; node to be taken care of. That's why I use a private
helper function. There is a couple important points to be noticed here:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p class="first"&gt;Use a static List variable &lt;tt class="docutils literal"&gt;P&lt;/tt&gt; is necessary because we need to keep track of
where is our first node after reverse (i.e. the last node in the original list
will become the first node after reversal). This is important because without
&lt;tt class="docutils literal"&gt;P&lt;/tt&gt;, we cannot access the first node because all the links are reversed and
we can no longer traverse the list from our &lt;em&gt;dummy&lt;/em&gt; node.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;Inside &lt;tt class="docutils literal"&gt;reverseListRecursiveHelper&lt;/tt&gt;, I don't have to check if &lt;tt class="docutils literal"&gt;L&lt;/tt&gt; is &lt;tt class="docutils literal"&gt;NULL&lt;/tt&gt;
(You need to do this for no &lt;em&gt;dummy&lt;/em&gt; node implementation style). Essentially, this
is the base case where I got passed in an empty list. Since in our implementation,
&lt;em&gt;dummy&lt;/em&gt; node always exists even when the list is empty (check out &lt;tt class="docutils literal"&gt;deleteList&lt;/tt&gt; routine),
&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;L-&amp;gt;Next&lt;/span&gt;&lt;/tt&gt; is always valid (we don't want to reference &lt;tt class="docutils literal"&gt;L&lt;/tt&gt;, which is &lt;tt class="docutils literal"&gt;NULL&lt;/tt&gt; already).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;We use a private function mainly because we have &lt;em&gt;dummy&lt;/em&gt; node in our implementation.
This is a special case that cannot be handled inside the recusive call. That's
also why the first data node in the original list is passed into the helper function.&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;List&lt;/span&gt; &lt;span class="n"&gt;P&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt;
&lt;span class="nf"&gt;reverseListRecursive&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;List&lt;/span&gt; &lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="c1"&gt;// empty list base case&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Next&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="c1"&gt;// only one node (tail node) base case&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Next&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Next&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;P&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Next&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="n"&gt;reverseListRecursive&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Next&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Next&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Next&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Next&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Next&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Next&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Next&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Next&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Next&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;P&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
 &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;p&gt;The above code shows a perfect example why &lt;em&gt;dummy&lt;/em&gt; node case cannot be handled
in recursive call. This is because, when we do recursion, we always assume
there is &lt;em&gt;dummy&lt;/em&gt; node exists in the sub list we passed in. However, that is not
what our list acutally is. You can see why our recursion assumes the &lt;em&gt;dummy&lt;/em&gt; node exists by
reading Line[6] &amp;amp; Line[11] &amp;amp; Line[16].&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Zeyuan Hu</dc:creator><pubDate>Sat, 03 Dec 2016 20:34:00 +0800</pubDate><guid isPermaLink="false">tag:zhu45.org,2016-12-03:posts/2016/Dec/03/reverse-singly-linked-list/</guid><category>singly-linked-list</category><category>recursion</category><category>maw</category></item><item><title>PrintLots</title><link>http://zhu45.org/posts/2016/Nov/28/printlots/</link><description>&lt;div class="section" id="problem"&gt;
&lt;h2&gt;Problem&lt;/h2&gt;
&lt;p&gt;Today, I finished the problem 3.2. The question is following:&lt;/p&gt;
&lt;blockquote&gt;
You are given a linked list, L, and another linked list, P, containing
integers sorted in ascending order. The operation &lt;tt class="docutils literal"&gt;PrintLots(L,P)&lt;/tt&gt;
will print the elements in L that are in positions specified by P.
For instance, if P = 1,3,4,6, the first, third, fourth, and sixth elements
in L are printed. Write the procedure &lt;tt class="docutils literal"&gt;PrintLots(L,P)&lt;/tt&gt;. You should
use the basic list operations. What is the running time of your procedure?&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class="section" id="solution"&gt;
&lt;h2&gt;Solution&lt;/h2&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt;
 &lt;span class="nf"&gt;printLots&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;List&lt;/span&gt; &lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;List&lt;/span&gt; &lt;span class="n"&gt;P&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
 &lt;span class="p"&gt;{&lt;/span&gt;
   &lt;span class="n"&gt;Pos&lt;/span&gt; &lt;span class="n"&gt;dummyP&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;dummyL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// creates dummy nodes to traverse the list&lt;/span&gt;
   &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;idx&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;outofelement&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

   &lt;span class="n"&gt;dummyP&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;P&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Next&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
   &lt;span class="n"&gt;dummyL&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Next&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

   &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dummyP&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
   &lt;span class="p"&gt;{&lt;/span&gt;
     &lt;span class="n"&gt;idx&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;dummyP&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Element&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
     &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;idx&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
     &lt;span class="p"&gt;{&lt;/span&gt;
       &lt;span class="c1"&gt;// if the idx is larger or equal to where the dummyL currently is&lt;/span&gt;
       &lt;span class="c1"&gt;// we don&amp;#39;t want to reset the dummyL to the very beginning of&lt;/span&gt;
       &lt;span class="c1"&gt;// the list L again to redo the traverse.&lt;/span&gt;
       &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;idx&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
       &lt;span class="p"&gt;{&lt;/span&gt;
         &lt;span class="n"&gt;dummyL&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Next&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
         &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
       &lt;span class="p"&gt;}&lt;/span&gt;
       &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;idx&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
       &lt;span class="p"&gt;{&lt;/span&gt;
         &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dummyL&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Next&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
         &lt;span class="p"&gt;{&lt;/span&gt;
           &lt;span class="n"&gt;dummyL&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;dummyL&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Next&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
         &lt;span class="p"&gt;}&lt;/span&gt;
         &lt;span class="k"&gt;else&lt;/span&gt;
         &lt;span class="p"&gt;{&lt;/span&gt;
           &lt;span class="n"&gt;outofelement&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
           &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
         &lt;span class="p"&gt;}&lt;/span&gt;
       &lt;span class="p"&gt;}&lt;/span&gt;
       &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;outofelement&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
       &lt;span class="p"&gt;{&lt;/span&gt;
         &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;No element in position %d, &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;idx&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
       &lt;span class="p"&gt;}&lt;/span&gt;
       &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
         &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;%d, &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;dummyL&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Element&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
       &lt;span class="p"&gt;}&lt;/span&gt;
     &lt;span class="p"&gt;}&lt;/span&gt;
     &lt;span class="k"&gt;else&lt;/span&gt;
     &lt;span class="p"&gt;{&lt;/span&gt;
       &lt;span class="n"&gt;exit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;EXIT_FAILURE&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
     &lt;span class="p"&gt;}&lt;/span&gt;
     &lt;span class="n"&gt;outofelement&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
     &lt;span class="n"&gt;dummyP&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;dummyP&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Next&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
   &lt;span class="p"&gt;}&lt;/span&gt;
 &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;p&gt;The problem isn't hard to solve. However, to get things right, I need to develop several test cases.
Let's develop a solution that can handle more general situation. In other words, linked list, P, doesn't
necessarily contain integers sorted in ascending order. Here are test cases I developed:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
L: 23, 44, 45, 57, 89, -1

P:  1, 3, 4, 5          &amp;lt;--- normal case
    1, 3, 4, 6          &amp;lt;--- there is no sixth element in L
    1, 3, 4, 6, 7       &amp;lt;--- there is no sixth, seventh element in L
    6, 7, 3, 1          &amp;lt;--- there is no sixth, seventh element in L, but have third, first element
    6, 2, 7, 1          &amp;lt;--- a no element (6th) followed by a existing element (2nd)
   -9, 1, 3, 4          &amp;lt;--- negative integer from P appears at the beginning
    1, 2, 4, -10        &amp;lt;--- negative integer from P appears at the end
&lt;/pre&gt;
&lt;p&gt;The code presented above handles all these different situations. In addition, if the integers presented in P
are actually in ascending order, we want to take advantage of this piece of information. That's why we check
&lt;tt class="docutils literal"&gt;if (idx &amp;lt; i)&lt;/tt&gt;. We don't want to reset the traverse ptr (i.e. &lt;tt class="docutils literal"&gt;dummyL&lt;/tt&gt;) every single time. In other words,
if the number in P is actually ascending, we want to move the traver ptr from its current pos instead of reset.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="c-related"&gt;
&lt;h2&gt;C related&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;When I compose this post, I'm actually thinking of if &lt;tt class="docutils literal"&gt;if (idx &amp;gt;= 0)&lt;/tt&gt; is necessary. In other words, if C
supports the array element access using negative index, then we shouldn't use &lt;tt class="docutils literal"&gt;exit&lt;/tt&gt; to handle.
Luckily, C doesn't support this feature. In fact, C allows you to access the element using negative index,
but that is actually a out of bound access and C won't complain about this. However, whate exactly you get
is random. That is called &amp;quot;undefined behavior&amp;quot;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Zeyuan Hu</dc:creator><pubDate>Mon, 28 Nov 2016 18:20:00 +0800</pubDate><guid isPermaLink="false">tag:zhu45.org,2016-11-28:posts/2016/Nov/28/printlots/</guid><category>c</category><category>singly-linked-list</category><category>maw</category></item><item><title>Automatically publish Tinkerer bld output to GitHub with Travis CI</title><link>http://zhu45.org/posts/2016/Nov/27/automatically-publish-tinkerer-bld-output-to-github-with-travis-ci/</link><description>&lt;div class="section" id="perface"&gt;
&lt;h2&gt;Perface&lt;/h2&gt;
&lt;p&gt;I saw a comment from &lt;a class="reference external" href="https://www.notionsandnotes.org/tech/web-development/pelican-static-blog-setup.html"&gt;a web&lt;/a&gt;
that talks about auto deployment with Travis CI&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;As an aside, you can also use GitHub Pages for hosting, which is free,
and then integrate it with Travis-CI to automatically publish the blog
(basically run pelican to generate the output and push the changes back online)
in order to decouple the actual writing of blog posts from the publishing part.&lt;/p&gt;
&lt;p&gt;The above also has the advantage of enabling a history of changes done
(both for the articles themselves and the output), as well as simplifying things
if you want to have guest posts and so on.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;That's the place where I start to explore Travis CI.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="travis-ci"&gt;
&lt;h2&gt;Travis CI&lt;/h2&gt;
&lt;p&gt;Travis CI part isn't hard to figure out. I referenced the following articles to get
me started with this great tool, particularly with Sphinx-doc:&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/dwyl/learn-travis"&gt;learn-travis&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/sphinx-doc/sphinx/blob/master/.travis.yml"&gt;Sphinx-doc repo .travis.yml&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://coderwall.com/p/wws2uq/have-travis-ci-test-your-sphinx-docs"&gt;Have Travis-CI test your Sphinx docs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;The basic idea of Travis CI is quite simple. Once you commit something, it will
trigger Travis CI to clone your repository, and run the command you specified in
&lt;tt class="docutils literal"&gt;.travis.yml&lt;/tt&gt; and then it will tell you the result of this commit (i.e.
Whether you pass all the test specified in &lt;tt class="docutils literal"&gt;.travis.yml&lt;/tt&gt;)&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="work-with-tinkerer"&gt;
&lt;h2&gt;Work with Tinkerer&lt;/h2&gt;
&lt;div class="admonition note"&gt;
&lt;p class="first admonition-title"&gt;Note&lt;/p&gt;
&lt;p class="last"&gt;Tinkerer is built upon Sphinx-doc. Any Sphinx-doc-ish tool should have similar
setup when work with Travis CI.&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;The setup for me is that I don't use &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;gh-pages&lt;/span&gt;&lt;/tt&gt;. Instead, I directly use &lt;tt class="docutils literal"&gt;master&lt;/tt&gt;
branch as the source for my github page. The reason is that Tinkerer will generate
&lt;tt class="docutils literal"&gt;index.html&lt;/tt&gt; directly inside root directory of the repo, which will redirect the
visit to &lt;tt class="docutils literal"&gt;index.html&lt;/tt&gt; under &lt;tt class="docutils literal"&gt;blog&lt;/tt&gt;. &lt;tt class="docutils literal"&gt;blog&lt;/tt&gt; is the default output directory.&lt;/p&gt;
&lt;p&gt;Here are the tutorials I referenced. However, all of them talk about working with &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;gh-pages&lt;/span&gt;&lt;/tt&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://gist.github.com/domenic/ec8b0fc8ab45f39403dd"&gt;Auto-deploying built products to gh-pages with Travis&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://benlimmer.com/2013/12/26/automatically-publish-javadoc-to-gh-pages-with-travis-ci/"&gt;Automatically Publish Javadoc to GitHub Pages with Travis CI&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;The first link above offers a framework of how you should get everything working and
the second link's bottom script offers some intuition.&lt;/p&gt;
&lt;p&gt;I'm not going to redo the work. I just want to point out something you need to be careful:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;strong&gt;DO NOT use personal token.&lt;/strong&gt; As mentioned by the first link, using a GitHub personal
access token offers the full access to all your git repo. That's a very high risk.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Be Careful with Public/Private.&lt;/strong&gt; You need to use the Travis client to encrypt
the &lt;em&gt;private&lt;/em&gt; ssh key and upload the corresponding &lt;em&gt;public&lt;/em&gt; ssh key to your repository.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Don't put passphrase for your ssh key.&lt;/strong&gt; If you do, Travis CI will ask for the passphrase
during the automation process, which will lead to build hang. If this happens, regenerate
the ssh key.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Be careful only upload your .enc file.&lt;/strong&gt; Don't upload your ssh private key to your repo.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="decode-the-script"&gt;
&lt;h2&gt;Decode the script&lt;/h2&gt;
&lt;div class="section" id="travis-yml"&gt;
&lt;h3&gt;.travis.yml&lt;/h3&gt;
&lt;p&gt;This is my &lt;a class="reference external" href="https://github.com/xxks-kkk/blog/blob/master/.travis.yml"&gt;.travis.yml&lt;/a&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
language: python
python:
  - &amp;quot;2.7&amp;quot;

install:
  - pip install tinkerer
  - pip install sphinxjp.themes.tinkerturquoise

script:
  - tinker -b

env:
  global:
  - ENCRYPTION_LABEL: &amp;quot;8c1ec1f6b778&amp;quot;
  - COMMIT_AUTHOR_EMAIL: &amp;quot;ferrishu3886&amp;#64;gmail.com&amp;quot;

after_success:
  - bash ./deploy.sh

notifications:
  email:
    recipients:
      - ferrishu3886&amp;#64;gmail.com
    on_success: change # option [alway|never|change]
    on_failure: always
&lt;/pre&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;install&lt;/tt&gt; section asks Travis CI to install the necessary packages to build our
doc.&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;script&lt;/tt&gt; section contains our doc build command.&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;env&lt;/tt&gt; section contains environment variables required for our &lt;tt class="docutils literal"&gt;deploy.sh&lt;/tt&gt;. They
are used to authorize a user on Travis CI to make &lt;tt class="docutils literal"&gt;git clone&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;git push&lt;/tt&gt;, etc.&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;after_success&lt;/tt&gt; tells Travis CI what to do once the &lt;tt class="docutils literal"&gt;script&lt;/tt&gt; section is done
successfully.&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;notifications&lt;/tt&gt; customize the email notification.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="deploy-sh"&gt;
&lt;h3&gt;deploy.sh&lt;/h3&gt;
&lt;p&gt;For &lt;a class="reference external" href="https://github.com/xxks-kkk/blog/blob/master/deploy.sh"&gt;deploy.sh&lt;/a&gt; is easy to
understand if you take a look at the Travis CI log for a build.&lt;/p&gt;
&lt;p&gt;Travis CI first perform basic the environment setup. Then, it clones the git repository.
Next, it builds our doc. If the build is success, it executes our &lt;tt class="docutils literal"&gt;deploy.sh&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;Inside &lt;tt class="docutils literal"&gt;deploy.sh&lt;/tt&gt;, the main idea is to first clone the same repo (i.e. &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;travis-dup&lt;/span&gt;&lt;/tt&gt;)
and copy the bld output pages (under &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;/xxks-kkk/blog/blog&lt;/span&gt;&lt;/tt&gt;) to the bld directory
of the same repo we just cloned (i.e. &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;travis-dup/blog&lt;/span&gt;&lt;/tt&gt;). If there is nothing
changed in the bld output pages, we exit. Else, we commit the changes and
use the authencation we just added (i.e. &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;ssh-add&lt;/span&gt; travis&lt;/tt&gt;) and push the change to the repo.&lt;/p&gt;
&lt;p&gt;To keep it simpler, you can imagine Travis CI is a remote server that you can do anything you
want. Thus, we can let bld result to be pushed to our repo by asking user (i.e. travis) from
the remote server to do so.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Zeyuan Hu</dc:creator><pubDate>Sun, 27 Nov 2016 22:00:00 +0800</pubDate><guid isPermaLink="false">tag:zhu45.org,2016-11-27:posts/2016/Nov/27/automatically-publish-tinkerer-bld-output-to-github-with-travis-ci/</guid><category>github</category><category>travis-ci</category></item><item><title>Generate a Linked List from a given array</title><link>http://zhu45.org/posts/2016/Nov/27/generate-a-linked-list-from-a-given-array/</link><description>&lt;div class="section" id="perface"&gt;
&lt;h2&gt;Perface&lt;/h2&gt;
&lt;p&gt;Well, I'm starting to work through
&lt;a class="reference external" href="https://www.amazon.com/Data-Structures-Algorithm-Analysis-2nd/dp/0201498405"&gt;Data Structures and Algorithm Analysis in C (2nd edition)&lt;/a&gt;
(referenced as MAW in the following posts) a couple of months agao to serve several purposes:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;to get enough familarity with C programming language&lt;/li&gt;
&lt;li&gt;to keep my computer science foundation knowledge fresh&lt;/li&gt;
&lt;li&gt;I'm interested in System-level programming and mastering C and C++ is a must.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I work on DB2 codebase but I don't play around the material I mentioned above a lot.
Things can get rusty pretty quickly. So, I need a way to keep fresh.&lt;/p&gt;
&lt;div class="admonition important"&gt;
&lt;p class="first admonition-title"&gt;Important&lt;/p&gt;
&lt;p class="last"&gt;All the source code relates to this book can be found on &lt;a class="reference external" href="https://github.com/xxks-kkk/algo"&gt;my git repo&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="solution"&gt;
&lt;h2&gt;Solution&lt;/h2&gt;
&lt;p&gt;For completeness and readability, here is my basic node declaraiton and definition.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;ET&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// ET shorts for &amp;quot;ElementType&amp;quot;&lt;/span&gt;

&lt;span class="c1"&gt;// we always assume there is a dummy node at the very beginning&lt;/span&gt;
&lt;span class="c1"&gt;// of the list.&lt;/span&gt;
&lt;span class="cp"&gt;#ifndef _LINKED_LIST_H&lt;/span&gt;
&lt;span class="cp"&gt;#define _LINKED_LIST_H&lt;/span&gt;

&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Node&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;PtrToNode&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="n"&gt;PtrToNode&lt;/span&gt; &lt;span class="n"&gt;List&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="n"&gt;PtrToNode&lt;/span&gt; &lt;span class="n"&gt;Pos&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="cp"&gt;#endif&lt;/span&gt;

&lt;span class="c1"&gt;// placed in the implementation file&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Node&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;ET&lt;/span&gt; &lt;span class="n"&gt;Element&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;Pos&lt;/span&gt; &lt;span class="n"&gt;Next&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;When I try to work through the linked list related questions in Chapter 2, the first thing
I need to do is to able to verify my solution. I need to figure out a way to quickly
generate a test linked list. So, that's what &lt;code&gt;List initializeList(ET A[], int arrayLen);&lt;/code&gt; for.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="n"&gt;List&lt;/span&gt;
&lt;span class="nf"&gt;initializeNoHeaderList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ET&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;[],&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;arrayLen&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;Pos&lt;/span&gt; &lt;span class="n"&gt;tmpNode&lt;/span&gt;&lt;span class="p"&gt;;;&lt;/span&gt;

  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arrayLen&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="n"&gt;tmpNode&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;malloc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tmpNode&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;exit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;EXIT_FAILURE&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="n"&gt;tmpNode&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Element&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
  &lt;span class="n"&gt;tmpNode&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Next&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;initializeNoHeaderList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;arrayLen&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;tmpNode&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;List&lt;/span&gt;
&lt;span class="nf"&gt;initializeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ET&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;[],&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;arrayLen&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;Pos&lt;/span&gt; &lt;span class="n"&gt;header&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="n"&gt;header&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;malloc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;header&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;exit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;EXIT_FAILURE&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="n"&gt;header&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Next&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;initializeNoHeaderList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;arrayLen&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;header&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;initializeList&lt;/tt&gt; adds a dummy node and invokes &lt;tt class="docutils literal"&gt;initializeNoHeaderList&lt;/tt&gt; to
actually generate linked list from a given array. Inside &lt;tt class="docutils literal"&gt;initializeNoHeaderList&lt;/tt&gt;,
we use &lt;em&gt;recursion&lt;/em&gt; to generate the list from array.&lt;/p&gt;
&lt;div class="admonition note"&gt;
&lt;p class="first admonition-title"&gt;Note&lt;/p&gt;
&lt;p class="last"&gt;If we actually change &lt;code&gt;tmpNode-&amp;gt;Next = initializeNoHeaderList(A+1, arrayLen-1);&lt;/code&gt;
to &lt;code&gt;tmpNode-&amp;gt;Next = initializeList(A+1, arrayLen-1);&lt;/code&gt;, this can lead to
a list contains nodes alternate between actual data node and the dummy node.
(i.e. &lt;code&gt;ET test_arr[] = {23, 44, 45, 57, 89, -1};&lt;/code&gt; then the generated linked list
will be &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;23-&amp;gt;0-&amp;gt;44-&amp;gt;0-&amp;gt;45-&amp;gt;0-&amp;gt;57-&amp;gt;0-&amp;gt;89-&amp;gt;0-&amp;gt;-1-&amp;gt;0-&amp;gt;&lt;/span&gt;&lt;/tt&gt;)&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="c-related"&gt;
&lt;h2&gt;C related&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p class="first"&gt;During the recursion call in &lt;tt class="docutils literal"&gt;initializeNoHeaderList&lt;/tt&gt;, we need to
pass in the subarray and the updated length. You can do so like I do
&lt;tt class="docutils literal"&gt;A+1&lt;/tt&gt; for the subarray (first element will be the second element of
the original array) and &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;arrayLen-1&lt;/span&gt;&lt;/tt&gt; for the updated length.&lt;/p&gt;
&lt;p&gt;For some reason, &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;arrayLen--&lt;/span&gt;&lt;/tt&gt; doesn't work here. If you do so, it
will lead to infinite recursion call and segmentation fault eventually.&lt;/p&gt;
&lt;div class="admonition note"&gt;
&lt;p class="first admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;when array being passed to a function call, it actually got decayed into a
pointer pointing to the first element of array. So,
&lt;tt class="docutils literal"&gt;initializeNoHeaderList(ET &lt;span class="pre"&gt;A[],&lt;/span&gt; int arrayLen)&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;initializeNoHeaderList(ET *A, int arrayLen)&lt;/tt&gt;
are the same.&lt;/p&gt;
&lt;p class="last"&gt;Since when we pass in an array, essentially we pass in the pointer to the first element.
So, similarly, when we pass in the subarray, we can actually pass in the pointer pointing
to the first element of the subarray, which is the second element of the original array.
So, &lt;tt class="docutils literal"&gt;&amp;amp;A[1]&lt;/tt&gt; (A[1] gives us the element, and we need a pointer, so we use &lt;tt class="docutils literal"&gt;&amp;amp;&lt;/tt&gt;). Since,
&lt;tt class="docutils literal"&gt;array[index]&lt;/tt&gt; is the same as &lt;tt class="docutils literal"&gt;*(array+index)&lt;/tt&gt;, so &lt;tt class="docutils literal"&gt;&amp;amp;A[1]&lt;/tt&gt; is the same as
&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;&amp;amp;*(A+1)&lt;/span&gt;&lt;/tt&gt;, which is &lt;tt class="docutils literal"&gt;A+1&lt;/tt&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;We use &lt;tt class="docutils literal"&gt;static&lt;/tt&gt; for &lt;tt class="docutils literal"&gt;initializeNoHeaderList&lt;/tt&gt; to make the function only visible
to the file we implement it (i.e. &lt;tt class="docutils literal"&gt;main.c&lt;/tt&gt;). This is the way we keep a helper function
private.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Zeyuan Hu</dc:creator><pubDate>Sun, 27 Nov 2016 19:38:00 +0800</pubDate><guid isPermaLink="false">tag:zhu45.org,2016-11-27:posts/2016/Nov/27/generate-a-linked-list-from-a-given-array/</guid><category>c</category><category>singly-linked-list</category><category>maw</category></item><item><title>Hello World</title><link>http://zhu45.org/posts/2016/Nov/23/hello-world/</link><description>&lt;p&gt;This blog will focus entirely on posts that involve either source code or
mathematical expression. If you are looking for my posts about life reflection,
book review, and many other non-technical posts, please check out &lt;a class="reference external" href="https://zeyuanhu.wordpress.com/"&gt;my blog on wordpress&lt;/a&gt;.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Zeyuan Hu</dc:creator><pubDate>Wed, 23 Nov 2016 23:00:00 +0800</pubDate><guid isPermaLink="false">tag:zhu45.org,2016-11-23:posts/2016/Nov/23/hello-world/</guid><category>meta</category></item><item><title>Minimal Emacs Tutorial</title><link>http://zhu45.org/posts/2015/Oct/18/minimal-emacs-tutorial/</link><description>&lt;div class="section" id="learn-about-emacs"&gt;
&lt;h2&gt;Learn about Emacs&lt;/h2&gt;
&lt;p&gt;Here I will cover some basic manipulation with text files using emacs. It should be enough to get started working with
emacs.&lt;/p&gt;
&lt;div class="section" id="terms-in-emacs"&gt;
&lt;h3&gt;Terms in Emacs&lt;/h3&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Region: the highlighted area&lt;/li&gt;
&lt;li&gt;Kill: same as &amp;quot;cut&amp;quot;&lt;/li&gt;
&lt;li&gt;Yank: same as &amp;quot;paste&amp;quot;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="emacs-key-notation"&gt;
&lt;h3&gt;Emacs Key Notation&lt;/h3&gt;
&lt;table border="1" class="docutils"&gt;
&lt;colgroup&gt;
&lt;col width="11%" /&gt;
&lt;col width="89%" /&gt;
&lt;/colgroup&gt;
&lt;thead valign="bottom"&gt;
&lt;tr&gt;&lt;th class="head"&gt;Prefix&lt;/th&gt;
&lt;th class="head"&gt;Meaning&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td&gt;C-&lt;/td&gt;
&lt;td&gt;(press and hold) the &lt;strong&gt;Control&lt;/strong&gt; key&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;M-&lt;/td&gt;
&lt;td&gt;the Meta key (the &lt;strong&gt;Alt&lt;/strong&gt; key, on most keyboards)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;S-&lt;/td&gt;
&lt;td&gt;the &lt;strong&gt;Shift&lt;/strong&gt; key (ie. &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;S-TAB&lt;/span&gt;&lt;/tt&gt; means Shift Tab)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;DEL&lt;/td&gt;
&lt;td&gt;the &lt;strong&gt;Backspace&lt;/strong&gt; key (not the Delete key).&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;RET&lt;/td&gt;
&lt;td&gt;the Return or &lt;strong&gt;Enter&lt;/strong&gt; key&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;SPC&lt;/td&gt;
&lt;td&gt;the &lt;strong&gt;Space bar&lt;/strong&gt; key&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;ESC&lt;/td&gt;
&lt;td&gt;the &lt;strong&gt;Escape&lt;/strong&gt; key&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;TAB&lt;/td&gt;
&lt;td&gt;the &lt;strong&gt;TAB&lt;/strong&gt; key&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;ARR&lt;/td&gt;
&lt;td&gt;the arrow keys&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class="section" id="common-usage"&gt;
&lt;h3&gt;Common Usage&lt;/h3&gt;
&lt;div class="section" id="system-operation"&gt;
&lt;h4&gt;System operation&lt;/h4&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;strong&gt;C-g&lt;/strong&gt; keyboard-quit; cancels anything Emacs is executing. If you press
any key sequence wrongly, &lt;strong&gt;C-g&lt;/strong&gt; to cancel that incorrectly pressed key
sequence and start again.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;C-x C-c&lt;/strong&gt; close emacs&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;C-x b&lt;/strong&gt; Open a promt to enter a buffer name&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;C-h f&lt;/strong&gt; Describe a function (i.e., &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;C-h&lt;/span&gt; f &lt;span class="pre"&gt;electric-indent-mode&lt;/span&gt;&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;C-h&lt;/span&gt; f fboundp&lt;/tt&gt;)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;C-x ARR&lt;/strong&gt; quickly switch between buffers&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="file-editing"&gt;
&lt;h4&gt;File Editing&lt;/h4&gt;
&lt;div class="admonition note"&gt;
&lt;p class="first admonition-title"&gt;Note&lt;/p&gt;
&lt;ul class="last simple"&gt;
&lt;li&gt;You need to set mark before you can use region operation. To know more about
&lt;a class="reference external" href="https://www.cs.colorado.edu/~main/cs1300-old/cs1300/doc/emacs/emacs_13.html"&gt;The Mark and Region&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;To move or copy a region of text in emacs, you must first &amp;quot;mark&amp;quot; it, then kill or copy the marked text, move the cu
rsor to the desired location, and restore the killed or copied text. A region of text is defined by marking one end         of it, then moving the cursor to the other end.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;strong&gt;C-&amp;#64;&lt;/strong&gt; Set the mark here&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;C-SPC&lt;/strong&gt; Set the mark where point is&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;C-x-h&lt;/strong&gt; Select the whole text&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;C-w&lt;/strong&gt; kill the region&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;M-d&lt;/strong&gt; kill forward to the end of the next word (&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;kill-word&lt;/span&gt;&lt;/tt&gt;)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;C-y&lt;/strong&gt; yank the region&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;M-w&lt;/strong&gt; copy the region&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;C-k&lt;/strong&gt; kill the whole line (note you need to put the cursor at the very beginning of the line)&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="admonition note"&gt;
&lt;p class="first admonition-title"&gt;Note&lt;/p&gt;
&lt;p class="last"&gt;To copy text, kill it, yank it back immediately (so it's as if you haven't killed it, except it's now in the kill ring
), move elsewhere and yank it back again.&lt;/p&gt;
&lt;/div&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;strong&gt;C-x C-s&lt;/strong&gt; save file&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;C-x C-v RET&lt;/strong&gt; reload a file (alternative way is &lt;strong&gt;M-x revert-buffer&lt;/strong&gt;)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;C-/&lt;/strong&gt; (&lt;strong&gt;C-x u&lt;/strong&gt;) undo&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;C-r&lt;/strong&gt; invoke backward search (type search word thereafter. Use &lt;strong&gt;C-r&lt;/strong&gt;
to repeatedly travel through the matches backward)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;C-s&lt;/strong&gt; similar to &lt;strong&gt;C-r&lt;/strong&gt; but search forward&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;C-x r t&lt;/strong&gt; insert words to multiple lines highlighted (the same thing you typed will be entered on all the lines you've
selected)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;M-x clipboard-yank&lt;/strong&gt; paste the clipboard text to emacs (useful when using emacs GUI)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;M-x clipboard-kill-region&lt;/strong&gt; paste emacs text to clipboard&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="cursor-movement"&gt;
&lt;h4&gt;Cursor Movement&lt;/h4&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;strong&gt;ESC-&amp;lt;&lt;/strong&gt; go to the beginning of the file&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ESC-a&lt;/strong&gt; go to beginning of the sentence&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ESC-e&lt;/strong&gt; go to end of the sentence&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;C-a&lt;/strong&gt; go to beginning of the line&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;C-e&lt;/strong&gt; go to the end of the line&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;M-x goto-line&lt;/strong&gt; go to the line specified&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;C-e RET&lt;/strong&gt; simulate &lt;tt class="docutils literal"&gt;o&lt;/tt&gt; in vi&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;C-a RET&lt;/strong&gt; simulate &lt;tt class="docutils literal"&gt;O&lt;/tt&gt; in vi&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;C-Up&lt;/strong&gt; go to the cursor location before a chunk of test pasted&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;C-v&lt;/strong&gt; page down&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;M-v&lt;/strong&gt; page up&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="searching-and-replacing"&gt;
&lt;h4&gt;Searching and Replacing&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p class="first"&gt;&lt;strong&gt;ESC-%&lt;/strong&gt; (query-replace) - ask before replacing each OLD STRING with NEW STRING.&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Type &lt;tt class="docutils literal"&gt;y&lt;/tt&gt; to replace this one and go to the next one&lt;/li&gt;
&lt;li&gt;Type &lt;tt class="docutils literal"&gt;n&lt;/tt&gt; to skip to next without replacing&lt;/li&gt;
&lt;li&gt;Type &lt;tt class="docutils literal"&gt;!&lt;/tt&gt; to replace this one and remaining replacements without asking&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.gnu.org/software/emacs/manual/html_node/emacs/Query-Replace.html"&gt;See more options in GNU manual&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;&lt;strong&gt;Esc-x replace-string&lt;/strong&gt; replace all occurrences of OLD STRING with NEW STRING.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;&lt;strong&gt;ESC-x list-matching-lines&lt;/strong&gt; lists all the lines matching your pattern in a separate buffer, along with their numbers. Use &amp;quot;ESC-x goto-line&amp;quot; to go to the occurrence you're interested in.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="manage-split-windows"&gt;
&lt;h4&gt;Manage Split Windows&lt;/h4&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;strong&gt;C-x 2&lt;/strong&gt; split-window-below&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;C-x 3&lt;/strong&gt; split-window-right&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;C-x 1&lt;/strong&gt; delete-other-windows (unsplit all)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;C-x 0&lt;/strong&gt; delete-window  (remove current pane)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;C-x o&lt;/strong&gt; other-window (cycles among the opening buffers)&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="file-management-dired-mode"&gt;
&lt;h4&gt;File Management (dired mode)&lt;/h4&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;strong&gt;M-x dired&lt;/strong&gt; start view directory&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;^&lt;/strong&gt; go to parent dir&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;g&lt;/strong&gt; refresh dir listing&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;q&lt;/strong&gt; Quit dired mode (buffer still exists)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;RET&lt;/strong&gt; Open the file or directory (this will open with another buffer). If you want to stick with one buffer, use &lt;strong&gt;a&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;o&lt;/strong&gt; Open file in another window (move cursor to that window as well)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;C-o&lt;/strong&gt; Open file in another window but stay on dired buffer&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;+&lt;/strong&gt; create new dir&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;C-x C-f&lt;/strong&gt; Create a new file (yes, the command is the same as opening a new file in non-dired mode)&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="other"&gt;
&lt;h4&gt;Other&lt;/h4&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;strong&gt;M-x whitespace-mode&lt;/strong&gt; allows you to explicitly see white-space, tab, newline. Especially useful when work
with python.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;M-x sort-lines&lt;/strong&gt; allows you to sort the marked region alphabetically. Especially useful when work with lots of Java
&lt;tt class="docutils literal"&gt;import&lt;/tt&gt; or C &lt;tt class="docutils literal"&gt;#include&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;C-x l&lt;/strong&gt; count number of the lines for the file; give the current line number; list how many lines left.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="howtos"&gt;
&lt;h3&gt;HowTos&lt;/h3&gt;
&lt;div class="topic"&gt;
&lt;p class="topic-title first"&gt;Parent shell&lt;/p&gt;
&lt;p&gt;When running Emacs in a terminal, you can press &lt;strong&gt;C-z&lt;/strong&gt;, type the shell command and then resume Emacs with &lt;strong&gt;fg&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="topic"&gt;
&lt;p class="topic-title first"&gt;How can I get Emacs to reload all my definitions that I have updated in .emacs without restarting Emacs?&lt;/p&gt;
&lt;p&gt;You can use the command load-file (&lt;strong&gt;M-x load-file&lt;/strong&gt;, then press return twice to accept the default filename, which         is the current file being edited).&lt;/p&gt;
&lt;p&gt;You can also just move the point to the end of any sexp and press &lt;strong&gt;C-x C-e&lt;/strong&gt; to execute just that sexp. Usually it'
s not necessary to reload the whole file if you're just changing a line or two.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;M-x eval-buffer&lt;/strong&gt; immediately evaluates all code in the buffer, its the quickest method, if your &lt;tt class="docutils literal"&gt;.emacs&lt;/tt&gt; is
idempotent.&lt;/p&gt;
&lt;p&gt;You can usually just re-evaluate the changed region. Mark the region of ~/.emacs that you've changed, and then use
&lt;strong&gt;M-x eval-region RET&lt;/strong&gt;. This is often safer than re-evaluating the entire file since it's easy to write a .emacs
file that doesn't work quite right after being loaded twice.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="topic"&gt;
&lt;p class="topic-title first"&gt;Shift multiple lines with TAB&lt;/p&gt;
&lt;p&gt;Select multiply lines, then type &lt;strong&gt;C-u 8 C-x Tab&lt;/strong&gt;, it will indent the region by 8 spaces. &lt;strong&gt;C-u -4 C-x Tab&lt;/strong&gt; will un-indent by 4 spaces.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="topic"&gt;
&lt;p class="topic-title first"&gt;Switch between windows when one windows open with term&lt;/p&gt;
&lt;p&gt;If you open two windows, and one window open a term (ie. &lt;strong&gt;M-x term&lt;/strong&gt;), now you want to switch back to another
window. You may find out &amp;quot;C-x o&amp;quot; may no longer work. In this case, you may want to use &lt;strong&gt;C-c o&lt;/strong&gt; to switch to next
window from term&lt;/p&gt;
&lt;/div&gt;
&lt;div class="topic"&gt;
&lt;p class="topic-title first"&gt;Comment out multiple region&lt;/p&gt;
&lt;p&gt;Comment out multiple lines. Highlight the region and then &lt;strong&gt;M-x comment-region&lt;/strong&gt;. To undo the comment,
&lt;strong&gt;M-x uncomment-region&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="topic"&gt;
&lt;p class="topic-title first"&gt;Error during download request: Not Found&lt;/p&gt;
&lt;p&gt;Happened when you try to install a package (M-x package-install). &lt;strong&gt;M-x package-refresh-contents&lt;/strong&gt; to rescue.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="topic"&gt;
&lt;p class="topic-title first"&gt;Editing multiple lines at the same time&lt;/p&gt;
&lt;p&gt;suppose I have the following chunk of code that I want to edit:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
printf &amp;quot;%s=%s\n&amp;quot; &amp;quot;Database&amp;quot; &amp;quot;bool_db&amp;quot;
printf &amp;quot;%s=%s\n&amp;quot; &amp;quot;Username&amp;quot;  &amp;quot;admin&amp;quot;
printf &amp;quot;%s=%s\n&amp;quot; &amp;quot;Password&amp;quot;  &amp;quot;password&amp;quot;
printf &amp;quot;%s=%s\n&amp;quot; &amp;quot;ReadOnly&amp;quot;  &amp;quot;false&amp;quot;
printf &amp;quot;%s=%s\n&amp;quot; &amp;quot;ShowSystemTables&amp;quot; &amp;quot;false&amp;quot;
printf &amp;quot;%s=%s\n&amp;quot; &amp;quot;LegacySQLTables&amp;quot; &amp;quot;false&amp;quot;
printf &amp;quot;%s=%s\n&amp;quot; &amp;quot;LoginTimeout&amp;quot; &amp;quot;0&amp;quot;
&lt;/pre&gt;
&lt;p&gt;and I want to remove all &lt;tt class="docutils literal"&gt;printf &lt;span class="pre"&gt;&amp;quot;%s=%s\n&amp;quot;&lt;/span&gt;&lt;/tt&gt; in each line. I can do the following:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;Mark the beginning of the region and invoke &lt;strong&gt;M-x rectangle-mark-mode&lt;/strong&gt; (or &lt;strong&gt;C-x SPC&lt;/strong&gt;) and select all the &lt;tt class="docutils literal"&gt;printf &lt;span class="pre"&gt;&amp;quot;%s=%s\n&amp;quot;&lt;/span&gt;&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;Delete them by &lt;strong&gt;M-x kill-region&lt;/strong&gt; (or &lt;strong&gt;C-x r k&lt;/strong&gt;)&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="admonition note"&gt;
&lt;p class="first admonition-title"&gt;Note&lt;/p&gt;
&lt;p class="last"&gt;Instead of delete, you can use &lt;strong&gt;C-x r t string RET&lt;/strong&gt; to replace rectangle contents with &lt;em&gt;string&lt;/em&gt; con each line.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="topic"&gt;
&lt;p class="topic-title first"&gt;Turn on the line number on the left hand side&lt;/p&gt;
&lt;p&gt;I find this is particularly useful when I work with gdb in emacs. It can be done with &lt;strong&gt;M-x linum-mode&lt;/strong&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="resources"&gt;
&lt;h3&gt;Resources&lt;/h3&gt;
&lt;p&gt;Personally reference them a lot. But there are ton online through google.&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://mally.stanford.edu/~sr/computing/emacs.html"&gt;Stanford emacs basics&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://ergoemacs.org/emacs/emacs_find_replace.html"&gt;Xah Emacs Tutorial&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/caiorss/Emacs-Elisp-Programming"&gt;Emacs-Elisp-Programming&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="emacs-configuration"&gt;
&lt;h2&gt;Emacs Configuration&lt;/h2&gt;
&lt;p&gt;This is my &lt;a class="reference external" href="https://github.com/xxks-kkk/emacs-config"&gt;personal emacs configuration&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Zeyuan Hu</dc:creator><pubDate>Tue, 03 Jan 2017 21:45:00 +0800</pubDate><guid isPermaLink="false">tag:zhu45.org,2015-10-18:posts/2015/Oct/18/minimal-emacs-tutorial/</guid><category>emacs</category></item></channel></rss>