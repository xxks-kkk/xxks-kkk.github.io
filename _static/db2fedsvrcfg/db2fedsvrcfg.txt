INVESTIGATION ON db2fedsvrcfg TOOL:

# DOUBTS & CONCLUSION:

	According to knowledge center, "db2fedsvrcfg" asserts only for "optimize performance", and it is really unclear what is the measure for "performance", and how
	to judge whether "performance" is optimized or not? The next step is really need to find out what is relationship between "pushdown" and "performance"? 
	It might be possible that a server attributes set to "Y" or "N" doesn't really affect pushdown. It may affect other parts like query rewrite.
	So, the next step is dig into "analyze" code and figure out logic.
	
	Core logic analysis is done (see 2.4) 
	
	
	[LEGACY, NO LONGER TRUE b/c really no tweak here, copy from predefined test table]
	The concept of ""optimize" lies in "judge_result" function [[00621-00670]] [db2odbct_analyze]: how the number are tweaked?
	
		ie. 
			 case SQLQG_SERVER_CHAR_BLANKPADDED_COMPARISON_OPTION_ID:
			{
				// Check if 'blank-padded comparison' is executed correctly.
				result = check_existance_int(result_list, 56, 1);
				break;
			}
			
		how those "56" "1" are tweaked? The tweak is the product of the table design [db2odbct_common], analyze statement design [db2odbct_statement]. It is still unclear for me now.
		
	[/LEGACY END]
		
	Conclusion:
		I don't feel this is the right tool to allow us to test whether set certain server attributes to allow us to do pushdown. I cannot clear answer what is "optimize performance" in this context. In other words, what is measure for "optimize performance"? Maybe certain server attributes set to "true" directly link with performance? That's just a pure guss and
		I cannot fully answer at this point.

NOTE:
	1. [...] indicates the suggested line number in Source Insight:: Db2 galileo Project that function/class/variables get defined
	2. [[...]] indicates the suggested line number that the function/statement/class/variables get called/executed

# Tools location: 
	
	/vbs/engn/sqqg_odbc/db2fedsvrcfg

# Important files:
	
	/vbs/engn/sqqg_odbc/db2fedsvrcfg/db2odbct_analyze.C         Tuning_Server_Option_Analyzer::analyze
	/vbs/engn/sqqg_odbc/db2fedsvrcfg/inc/db2odbct_statement.h
	/vbs/engn/sqqg_odbc/db2fedsvrcfg/inc/db2odbct_analyze.h
	/vbs/engn/sqqg_odbc/db2fedsvrcfg/inc/db2odbct_common.h

# Links:
	
	db2fedsvrcfg command syntax - ODBC tuning utility
	
	http://www-01.ibm.com/support/knowledgecenter/SSEPGG_10.5.0/com.ibm.swg.im.iis.found.conn.fw.odb.doc/topics/iiynwodb_cftur.html
	
	A nice tutorial on "db2fedsvrcfg" usage provided by Zhitong:
	https://www.ibm.com/developerworks/community/wikis/home?lang=en#!/wiki/We6daffb07c9c_4ed8_b026_fcbaaf2b0ebf/page/Sybase%20IQ%20-%20How%20to%20configure%20access%20to%20Sybase%20IQ%20data%20source%20on%20UNIX%20or%20Linux%20through%20the%20ODBC%20wrapper
	
	Tool purpose and general usage:
	
	http://www-01.ibm.com/support/knowledgecenter/SSEPGG_10.5.0/com.ibm.swg.im.iis.found.conn.fw.odb.doc/topics/iiynwodb_cftut.html
	
	Test table definitions for the ODBC tuning utility (db2fedsvrcfg)
	
	http://www-01.ibm.com/support/knowledgecenter/SSEPGG_10.5.0/com.ibm.swg.im.iis.found.conn.fw.odb.doc/topics/iiynwodb_cftu_table_defs.html?lang=en
	

# Usage guide:
	
	I. connect_to_data_source:
	
		1. get data source info:
		   i.e. mssqlserver:2005cn1a:2005:mssql2005csdl1:j15user1,ZURBIE:j15user1,Regr4evr:mssql2005db1:libdb2mssql3:db2mssql3:mssqlodbc3: 
	
		2. db2 update dbm cfg using federated yes

		3. db2stop; db2start

		4. djrun ddl mssqlserver:2005cn1a > mssqlserver.clp

		5. clean up mssqlserver.clp, and remove redudant info

		6. db2 -tvf mssqlserver.clp
	
	II. run `db2fedsvrcfg -s SERVER1 -m /opt/oemclient/odbc60/64/lib/VMmsss24.so -dsn mssql2005csdl1 -u j15user1 -p j15user1`
	
		
		-- This CLP file was created using "db2fedsvrcfg" Version "10.1.0.5".
		-- Timestamp: 2015/10/20 15:51:06
		-- Server Name: SERVER1
		-- ODBC Driver Manager: /opt/oemclient/odbc60/64/lib/VMmsss24.so
		-- DSN Name: mssql2005csdl1
		-- Remote Database Name:
		-- Remote User Name: j15user1
		-- Remote Table Names: IITEST[#]
		-- Remote Data Source Codepage:
		-- Preparation: YES
		-- Verbose: NO


		-- Generating ALTER SERVER statement...

		-- --------------------------------------------------
		--  ALTER SERVER statements for server "SERVER1"
		-- --------------------------------------------------
		ALTER SERVER "SERVER1" OPTIONS (ADD PUSHDOWN 'Y');

		The db2fedsvrcfg command completed successfully.

	III. Interpretation
	
		mssqlserver performance achieve the maximum only when "PUSHDOWN" set to 'Y'
		In zhitong's tutorial, Sybase need to config 12 server attributes in order to optimize performance
		
# Source code structure:

	. inc/
		.. db2odbct.h
		.. db2odbct_analyze.h
		.. db2odbct_common.h
		.. db2odbct_connection.h
		.. db2odbct_driver.h
		.. db2odbct_elements.h 
		.. db2odbct_error.h
		.. db2odbct_logger.h
		.. db2odbct_operation.h
		.. db2odbct_statement.h
		.. db2odbct_string.h 
		.. db2odbct_utils.h 
		.. db2odbct2.h 
	
	. db2fedsvrcfg.C 
	. db2odbct.C
	. db2odbct_analyze.C 
	. db2odbct_connection.C 
	. db2odbct_driver.C 
	. db2odbct_elements.C
	. db2odbct_error.C 
	. db2odbct_logger.C
	. db2odbct_operation.C 
	. db2odbct_statement.C
	. db2odbct_string.C
	. db2odbct_utils.C 
	. db2odbct2.C 
	
# Main source code structure relationship:

	
	
# Source code detailed analyze & note:

	## db2fedsvrcfg.C
	
		1. Include Main routine
		2. int LoadTuningLibrary (bool lib32In64bit) [01237] [[00192]]
			2.1 key function, acutally LOAD the tuning libray - Load the db2odbct library
		3. // Get a list of the optimized server options. [[00237]]
		   rc = fp_get_optimized_server_options(params, &server_option_list);
		
			[QUESTION]
				what is "fp_get_optimized_server_options"? 
				what does "Hook_FuncType_get_optimized_server_options fp_get_optimized_server_options" do? [00117]
	
	## db2odbct.C
	
		1. Interface functions for the ODBC tuning
		2. int get_optimized_server_options(INPUT_PARMS a_input_params,
											Tuning_Server_Option_List **a_server_option_list) [00072]
			2.1 Get a set of server option info objects with optimized server option values
			
				2.1.1 This function:
						(1) connects to the given ODBC data source
						(2) prepares database objects like tables for the analysis
						(3) validates the database objects
						(4) analyze the data source's capabilities
						(5) cleans up the database objects
						(6) disconnects from the data source
						
				2.1.2 [IN] a_input_params:
							command parameter information
					  [OUT]a_server_option_list:
							list of server option info
							
				2.1.3 Dependencies:
						(1) build_server_option_list [[00189]], prepare_data_source [[00242]]
						(2) build_testing_table_list [[00195]]
						(4) analyze_data_source [[00275]]
						(5) cleanup_data_source [[00328]]
						
			2.2 Important calling flow:
				
				2.2.1 rc = build_server_option_list(&a_server_option_list); [[00189]] (create a list of server options)
					
				2.2.2 rc = build_testing_table_list(&table_list,
													a_input_params.tablename_prefix,
													a_input_params.tablename_suffix); [[00195]]
													(create a list of testing tables)
					
				2.2.3 Tuning_Driver *driver = new Tuning_Driver(a_input_params.drivername, &rc);
						  [[00203]] (load the ODBC driver manager)
						  
							2.2.3.1 "Tuning_Driver" is defined in "db2odbct_driver.C" [00049]
					
				2.2.4 rc = driver->initialize(); [[209]] (Initialize the ODBC application env)
					
				2.2.5 Tuning_Connection *connection = new Tuning_Connection(
                                            driver, 
                                            a_input_params.dsnname, 
                                            a_input_params.dbname, 
                                            a_input_params.userid, 
                                            a_input_params.password,
                                            a_input_params.codepage,
                                            &rc); [[215]] (Establish a connection to an ODBC data source)
							2.2.5.1 "Tuning_connection" is defined in "db2odbct_connection" [00058]
							
				2.2.6 rc = prepare_data_source(connection, table_list); [[00242]] (Preparation)
					
	[IMPORTANT] 2.2.7 rc = analyze_data_source(connection, *a_server_option_list, table_list, true); [[00275]] (Analysis)
					
							2.2.7.1 "true" above is used when "if (a_input_params.mode & TUNING_SKIP_PREPARE)" [[00273]]
							
							2.2.7.2 "analyze_data_source" is defined in "db2odbct2.C" [00617]
							
							[TODO]
								(1) Further investigate what exactly is "mode"?
								
				2.2.8 rc2 = cleanup_data_source(connection,table_list) [[00328]] (cleanup)
					
							2.2.8.1 "cleanup_data_source" is defined in "db2odbct2.C" [00738]
							
				2.2.9 rc2 = connection->disconnect(); [[00344]] (Disconnect)
			
			2.3 rc = build_server_option_list(&a_server_option_list); [[00189]]
			
	## db2odbct2.C
	
		1. Interface functions for the ODBC tuning
		2. int build_server_option_list(Tuning_Server_Option_List ***a_server_option_list) [00052]
		
			2.1 The function builds a list of server option info objects, which is to be passed to the caller side
			2.2 "Tuning_Server_Option_List" [[00060]], "Tuning_Server_Option_Info" [[00061]] are defined in "db2odbct_elements"
			2.3 "svropts" [[00066]] is defined in "db2odbct_elements"
			
		3. int build_testing_table_list(Tuning_Table_List **a_table_list, 
                             const char *a_tablename_prefix,
                             const char *a_tablename_suffix) [00102]
							 
			3.1 "Tuning_Table_List" "Tuning_Table_Info" are defined in "db2odbct_elements"
			3.2 a_tablename_prefix ie "DEFAULT_TABLENAME_PREFIX" [[00128]] is defined in "db2odbct_elements"
			3.3 "testing_tables" [[00139]] is defined in "db2odbct_common" 
			
		4. int prepare_data_source(Tuning_Connection *a_conn, Tuning_Table_List *a_table_list) [00230]
		
			4.1 "Tuning_DDL_Operation" "Tuning_IUD_Operation" are defined in "db2odbct_operation"
			4.2 "Tuning_CREATE_Stmt_Generator" is defined in "db2odbct_statement"
			
		5. int analyze_data_source( Tuning_Connection         *a_conn,
                         Tuning_Server_Option_List *a_svropt_list,
                         Tuning_Table_List         *a_table_list,
                         bool                       a_validation_needed ) [00617] 
						 
			5.1 Analyze the data source's capabilities. Test the data source's capabilities by issuing
				one or more queries to it and determine the optimized value for each server options.
			5.2 "Tuning_Server_Option_Analyzer" is defined in "db2odbct_analyze"
[IMPORTANT] 5.3 rc = analyzer->analyze(option) [[00673]] (Analysis for each server option)
			
	## db2odbct_analyze.C
	
		1. Methods for server option analyzer class
		2. int Tuning_Server_Option_Analyzer::analyze(Tuning_Server_Option_Info *a_option) [00087]
		
			2.2 Important variables: [[00092 - 00099]]
			
					int                 rc                 = RC_OK;
					int                 option_id          = 0;
					int                 base_option_id     = SERVER_OPTION_ID_UNKNOWN;
					bool                judge              = false;
					bool                analysis_completed = false;
					TString             optimized_value    = "";
					Tuning_Result_List *result_list        = NULL;
					Tuning_Server_Option_Info *base_option = NULL;

			2.1 enum Status {Tuning_None, Tuning_Success, Tuning_Failure}; [db2odbct_elements 00357] [[00102]]
			
			2.2 set the default option value for the original optimized one [[000108]]
				optimized_value = TString((const char*)a_option->get_default_value());
				
				get_default_value() [000406] [db2odbct_elements]
					return ((const char*)m_default_value);
				
				TString m_default_value [00387] [db2odbct_elements]
				
				default value is empty, will be set to "Y" or "N" ie [[00188-00192]]
				
			2.3 set base_option_id [[00113-00126]]
			
				i.e. base_option_id = SQLQG_SERVER_ORDER_BY_OPTION_ID;
				
				In db2odbct_common.h [00197-00210]
				
				///////////////////////////////////////////////////////////////////////
				//            Option: DB2_ORDER_BY (internal)
				//       Description: Specifies whether the data source supports
				//                    ORDER BY clause.
				// Optional/Required: Optional
				//     Default value: 'N'
				//      Valid values: 'Y', 'N'
				// Extracted/verified by: Relational_Server class.
				//         Stored on: Server_Attributes object.
				//////////////////////////////////////////////////////////////////////
				#define SQLQG_SERVER_ORDER_BY_OPTION_ID  1
				#define SQLQG_ORDER_BY_SERVER_OPTION                 \
						"DB2_ORDER_BY"
				#define SQLQG_ORDER_BY_DEFAULT  "N"
				
				base_option_id purpose:
				
					base_option = m_svropt_list->get_server_option_by_id(base_option_id); [[00132]]
					
					Instead of directly dealing with server option, author adds one more layer to server option:
					base_option_id. This allows us to quickly locate server option through their corresponding
					base_option_id
					
						get_server_option_by_id [00290] [db2odbct_elements.C]
						
							Tuning_Server_Option_Info *option = m_first_option;

							for ( ;
								option !=NULL && option->is_same_id(id) == false; 
								option = get_next_server_option(option)) {}
						
								Indication: Tuning_Server_Option_List uses a linked list data structure
							
								"option" analysis: [00360] [db2odbct_elements.h]
									Tuning_Server_Option_Info(const int   a_option_id,
														const char *a_option_name, 
														const char *a_default_value,
														Action      a_action = sqlqg_Add);
									Indication:
											Tuning_Server_Option_Info contains option id , option name, its default value, and Action
											
											[QUESTION] 
												enum Action {sqlqg_None, sqlqg_Add, sqlqg_Set, sqlqg_Drop}; [00356] [db2odbct_elements.h]
												What does Action do?
				
				Relationship between base_option_id & option_id [[00113-00126]] 
				
					ie. if (option_id == SQLQG_SERVER_MAX_GB_SIZE_OPTION_ID) 
						{
							base_option_id = SQLQG_SERVER_GROUP_BY_OPTION_ID;
						}
						
					essentially, server option with "option_id" has dependency upon "base_option_id", then
					tool will analyze server option with "base_option_id" first, then server option with "option_id"
					If server option with "base_option" doesn't work, then there is no need to analyze server option w/
					"option_id" that depends on "base_option_id". 
					These can be confirmed by comments [00134-00135] [00144-00145]
					
					[QUESTION]
						code [[00131 - 00160]] is unclear to me. comment [00128-00129] claims that "If this server option has
						a base option, we use the outcome of the analysis for more intelligent analysis."
						
						Not sure how he achieve this point?
			
			2.4 [IMPORTANT ANALYZE CALLING FLOW] [[starts 00163]] <key to expand its capabilities>
				
				Logic structure:
				
				1. 
				include: 
					case SQLQG_SERVER_VARCHAR_BLANKPADDED_COMPARISON_OPTION_ID:
					case SQLQG_SERVER_CHAR_BLANKPADDED_COMPARISON_OPTION_ID:
				
				ie 	case SQLQG_SERVER_CHAR_BLANKPADDED_COMPARISON_OPTION_ID:
				
					1. Construct Tuning_ANALYZE_Stmt_Generator
							Tuning_ANALYZE_Stmt_Generator *generator = 
								new Tuning_ANALYZE_Stmt_Generator(m_connection, m_table_list, option_id);
								
					2. Analyze SQL statement generate
							TString stmt = generator->generate(); [detail see db2odbct_statement]
							
					3. Create Operation
							Tuning_Query_Operation *operation = m_connection->create_query_operation((const char*)stmt);

					4. Issue the analyze statement
							rc = operation->query();
							
					5. Retrieve result for judgement
							 rc = operation->fetch(&result_list);
			
					6. [IMPORTANT] Judge result
							judge = judge_result(a_option, result_list);
							
					7. Based upon "judge" valeSet optimized value
						
							I. (rc == RC_OK) && (result_list != NULL)
								if (judge == true)
								{
									optimized_value = "Y";
									analysis_completed = true;
								}
								if (judge == false)
								{
									optimized_value = "N";
									analysis_completed = true;
								}
							
							II. (rc == RC_NO_DATA_FOUND)
							
								<No data returned is assumed as the data source did not process
								 the WHERE clause portion with blank padded comparison>
								 optimized_value = "N"
								 
				2. 
				include: 
					case SQLQG_SERVER_COLFUNC_EXPR_OPTION_ID:
					case SQLQG_SERVER_FUNCTION_IN_COUNT_OPTION_ID:
					case SQLQG_SERVER_COUNT_NON_DISTINCT_OPTION_ID:
					case SQLQG_SERVER_OUTER_JOINS_OPTION_ID:
					case SQLQG_SERVER_NESTED_TAB_EXPR_OPTION_ID:
					case SQLQG_SERVER_ORDER_BY_OPTION_ID:
					case SQLQG_SERVER_SELECT_DISTINCT_OPTION_ID:
					case SQLQG_SERVER_COLFUNC_DISTINCT_OPTION_ID:
					case SQLQG_SERVER_GROUP_BY_OPTION_ID:
					case SQLQG_SERVER_BASIC_PRED_RHS_SCALAR_SQ_OPTION_ID:
					case SQLQG_SERVER_UNION_ALL_OPTION_ID:
					case SQLQG_SERVER_COLFUNC_OPTION_ID:
					case SQLQG_SERVER_EXISTS_PRED_OPTION_ID:
							
				ie case SQLQG_SERVER_EXISTS_PRED_OPTION_ID:
					
					step 1-4 are same
							
					5. if (rc == RC_OK)
						optimized_value = "Y";
							
				3.
				include:
					case SQLQG_SERVER_MAX_SEL_SIZE_OPTION_ID:
					case SQLQG_SERVER_MAX_OB_SIZE_OPTION_ID:
					case SQLQG_SERVER_MAX_GB_SIZE_OPTION_ID:
					
				ie case SQLQG_SERVER_MAX_GB_SIZE_OPTION_ID:
					
					uses three values: min_value, max_value, default_value
					
						initialization:
							max_value = atoi(SQLQG_MAX_GB_SIZE_MAX);
							min_value = atoi(SQLQG_MAX_GB_SIZE_MIN);
							default_value = atoi(SQLQG_MAX_GB_SIZE_DEFAULT);
					
					loop:
					then new_value, old_values to search
						
						initialization:
							new_value = default_value;
							old_value = min_value;
							
						// When the previous statement failed try with smaller value
						new_value = old_value + (new_value - old_value) / 2;
						
						// When the previous statement succeeded, try with larger value.
						new_value = new_value + (new_value - old_value);
						old_value = old_value + (new_value - old_value) / 2;
						
					then set the new value to generate a new statement
					
					then issue the analysis statement with new value
						if (rc == RC_OK)
							then we find the ideal value, which is new_value <however, the value is not set here, set in [[00481-00485]]>
						else
							// Store the rc as the information for making a decision of generation 
							// of the next analysis statement.
							prev_rc = rc;
					
					loop will terminate when
					
						 // Terminate the analysis if the statement succeeds and the difference becomes 
						// smaller than the threshold.
						if ((stmt_generation_count > 1) && 
							((abs(old_value - new_value) < threshold) ||(new_value == max_value)))
						{
							analysis_completed = true;
						}
						
					[NOTE] "stmt_generation_count" will increment at [[00474]]
				
				4. case SQLQG_SERVER_UPD_SET_DEFAULT_OPTION_ID:
				
					1. Construct Tuning_ANALYZE_Stmt_Generator
							Tuning_ANALYZE_Stmt_Generator *generator = 
								new Tuning_ANALYZE_Stmt_Generator(m_connection, m_table_list, option_id);
								
					2. Analyze SQL statement generate
							TString stmt = generator->generate(); [detail see db2odbct_statement]
							
					3. Create Operation (here is diff: create_IUD_operation )
							Tuning_IUD_Operation *operation = 
								m_connection->create_IUD_operation((const char*)stmt);

					4. 	int row_updated = 0;
						rc = operation->iud_row(&row_updated);
					
					5. if (row_updated == 1)
							judge = true;
							optimized_value = "Y";
							
		3. bool Tuning_Server_Option_Analyzer::judge_result( Tuning_Server_Option_Info *a_option, Tuning_Result_List *a_result_list) [00611]
		
			3.1 The following server option will check and invoke "check_existance_int" for various arguments
			
				SQLQG_SERVER_VARCHAR_BLANKPADDED_COMPARISON_OPTION_ID
				SQLQG_SERVER_CHAR_BLANKPADDED_COMPARISON_OPTION_ID
				SQLQG_SERVER_COLFUNC_EXPR_OPTION_ID
				SQLQG_SERVER_FUNCTION_IN_COUNT_OPTION_ID
				SQLQG_SERVER_COUNT_NON_DISTINCT_OPTION_ID
				
			3.2 The following server option will not check and default return "result" to be true
				However, notice that some server options, if not all, are in fact not used
				
				SQLQG_SERVER_BASIC_PRED_RHS_SCALAR_SQ_OPTION_ID
				SQLQG_SERVER_COLFUNC_DISTINCT_OPTION_ID
				SQLQG_SERVER_COLFUNC_OPTION_ID
				SQLQG_SERVER_EXISTS_PRED_OPTION_ID
				SQLQG_SERVER_GROUP_BY_OPTION_ID
				SQLQG_SERVER_MAX_GB_SIZE_OPTION_ID
				SQLQG_SERVER_MAX_OB_SIZE_OPTION_ID
				SQLQG_SERVER_MAX_SEL_SIZE_OPTION_ID
				SQLQG_SERVER_NESTED_TAB_EXPR_OPTION_ID
				SQLQG_SERVER_ORDER_BY_OPTION_ID
				SQLQG_SERVER_OUTER_JOINS_OPTION_ID
				SQLQG_SERVER_SELECT_DISTINCT_OPTION_ID
				SQLQG_SERVER_UNION_ALL_OPTION_ID
				SQLQG_SERVER_UPD_SET_DEFAULT_OPTION_ID
				
		4. bool Tuning_Server_Option_Analyzer::check_existance_int (Tuning_Result_List *result_list, int value, int count)[00684]
		
			Logic:	It will compare "a_result_data" one by one 
					<Tuning_Result_Data *a_result_data = result_list->get_first_result_data();
					a_result_data = (Tuning_Result_Data *)a_result_data->get_next_result_data();>
					
					Then, compare "a_result_data" data type <a_result_data->get_data_type()>, data value
					<a_result_data->get_int_value()> with the predefined value: rsdt_int & value 
					
					If "a_result_data" valid, then "foundNum++", if "foundNum == count", then return "true"
					